# è®­ç»ƒæ‰‹å†Œï¼šDebate MAS ä¸‰æ®µå¼å®æˆ˜ç»ƒä¹ ï¼ˆBuild â†’ Transferï¼‰

> æœ¬è®­ç»ƒå†Œé‡‡ç”¨ **Outcome â†’ Contract â†’ TODO Map â†’ Run â†’ Pass â†’ Transfer** çš„å…³å¡å¼ç»“æ„ã€‚  
> æˆ‘ä»¬ä»¥ **ETF æŠ•å†³**ä½œä¸ºç¤ºä¾‹èƒŒæ™¯ï¼Œå¸¦ä½ â€œå¡«ç©ºå¼â€æ­å»ºä¸€ä¸ªæœ€å°å¯ç”¨çš„ **Debate MAS**ï¼›æ¯å…³æœ«å°¾æä¾› **è¿ç§»æç¤ºæ¨¡æ¿**ï¼Œå¸®åŠ©ä½ æŠŠåŒä¸€å¥—æ¡†æ¶è¿ç§»åˆ°ä»»æ„ä¸šåŠ¡åœºæ™¯ï¼ˆæ— éœ€çœŸçš„å®ç°å¦ä¸€å¥—ä»£ç ï¼‰ã€‚

---

## å¼€å§‹ä¹‹å‰ï¼ˆè¯»å®Œ 60 ç§’å°±å¤Ÿï¼‰

### ä½ ä¼šå¾—åˆ°ä»€ä¹ˆ
- âœ… èƒ½è·‘ï¼šä»å‘½ä»¤è¡Œè·‘å‡ºä¸€å¥—â€œå¯å®¡è®¡â€çš„å†³ç­–äº§ç‰©ï¼ˆmemo / csv / log / transcriptï¼‰
- âœ… èƒ½æ”¹ï¼šçŸ¥é“æ”¹å“ªäº›æ–‡ä»¶ä¼šå½±å“â€œæµç¨‹/åœæœº/è¾“å‡ºâ€ï¼Œä¸ä¼šä¹±æ”¹
- âœ… èƒ½è¿ç§»ï¼šæ¢ä¸šåŠ¡æ—¶çŸ¥é“â€œæ¡†æ¶ä¸åŠ¨ï¼Œä¸šåŠ¡æ›¿æ¢åœ¨å“ªé‡Œåšâ€

### æ¯å…³æ€ä¹ˆåšï¼ˆå…­æ­¥é—­ç¯ï¼‰
æ¯ä¸€å…³éƒ½å›ºå®šæŒ‰è¿™ 6 æ­¥èµ°ï¼ˆä½ ä¼šå¾ˆå¿«å½¢æˆè‚Œè‚‰è®°å¿†ï¼‰ï¼š
- ğŸ¯ **Outcome**ï¼šè¿™ä¸€å…³åšå®Œï¼Œä½ èƒ½å¾—åˆ°ä»€ä¹ˆç»“æœ
- ğŸ§± **Contract**ï¼šä½ å¿…é¡»æ»¡è¶³çš„è¾“å…¥/è¾“å‡ºçº¦æŸ
- ğŸ—ºï¸ **TODO Map**ï¼šè¿™ä¸€å…³è¦æ”¹çš„æ–‡ä»¶/å‡½æ•°
- â–¶ï¸ **Run**ï¼šè¿è¡Œå‘½ä»¤
- âœ… **Pass**ï¼šé€šè¿‡æ ‡å‡†
- ğŸ” **Transfer**ï¼šè¿ç§»æç¤ºï¼ˆå“ªäº›ä¸åŠ¨ / å“ªäº›å¯æ›¿æ¢ / å¯æ›¿æ¢æ–¹å‘ï¼‰


---

# ç»ƒä¹ è·¯çº¿ï¼ˆè¿›åº¦æ¸…å•ï¼‰

> å®Œæˆåå¯ä»¥æŠŠ â¬œï¸ æ”¹æˆ âœ… æ¥æ‰“å¡ã€‚

| é˜¶æ®µ | å…³å¡ | ä½ ä¼šå®Œæˆä»€ä¹ˆ | çŠ¶æ€ |
|---|---|---|---|
| é˜¶æ®µä¸€ï¼šæ„ŸçŸ¥ä¸è·‘é€š | å…³å¡-01 | è·‘é€šé»˜è®¤ Demo + å‘½ä»¤å¯¹æ¯”ï¼Œæ‰¾åˆ°äº§ç‰©å¹¶ä¼šè¯» | â¬œï¸ |
| é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ | å…³å¡-02 | çŠ¶æ€è´¦æœ¬ï¼špayload / transcript / round / stop_reason | â¬œï¸ |
| é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ | å…³å¡-03 | è¾“å‡ºåè®®ï¼šCandidate / Objection / Decisionï¼ˆç»“æ„åŒ–ï¼‰ | â¬œï¸ |
| é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ | å…³å¡-04 | è¯æ®æ¡ˆå·ï¼šLoader æœ€å°å¥‘çº¦ï¼ˆfolder â†’ dossierï¼‰ | â¬œï¸ |
| é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ | å…³å¡-05 | æç¤ºè¯å·¥å‚ï¼šPersonas + å·¥å…·ç™½åå• + è¾“å‡ºæ ¼å¼çº¦æŸ | â¬œï¸ |
| é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ | å…³å¡-06 | æµç¨‹ç¼–æ’ï¼šGraph è·³è½¬ + åœæœºè§„åˆ™ | â¬œï¸ |
| é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ | å…³å¡-07 | å¼•æ“ä¸²è”ï¼šEngine æœ€å°å¾ªç¯ï¼ˆèƒ½è·‘å®Œï¼‰ | â¬œï¸ |
| é˜¶æ®µä¸‰ï¼šSkills | å…³å¡-08 | å†™ Skillï¼šä¸€ä¸ªå¯è°ƒç”¨ã€å¯è¿”å›ç»“æ„åŒ–ç»“æœçš„æŠ€èƒ½ | â¬œï¸ |
| é˜¶æ®µä¸‰ï¼šSkills | å…³å¡-09 | æ³¨å†Œä¸å‡†å…¥ï¼šregistry + allowlistï¼Œç³»ç»Ÿèƒ½è¯†åˆ«å¹¶ç­›é€‰å¯ç”¨ skill | â¬œï¸ |
| é˜¶æ®µä¸‰ï¼šSkills | å…³å¡-10 | å·¥å…·å°è£…ä¸å®ˆå«ï¼šskillâ†’tools æ˜ å°„ + ç»Ÿä¸€è°ƒç”¨å…¥å£ + allowlist æ‹¦æˆª | â¬œï¸ |

---


# é˜¶æ®µä¸€ï¼šæ„ŸçŸ¥ä¸è·‘é€šï¼ˆRun & Senseï¼‰

## å…³å¡-01ï½œè·‘é€šé»˜è®¤ Demo + å‘½ä»¤å¯¹æ¯”

<details>
<summary><b>Checkpoint 01 â€” è·‘é€šé»˜è®¤ ã€è¯¦æƒ…ã€‘</b></summary>

### ğŸ¯ ç›®æ ‡æ”¶è·ï¼ˆOutcomeï¼‰
> èƒ½è·‘é€šç³»ç»Ÿï¼Œå¹¶é€šè¿‡æ¢ä¸€æ¬¡ä»»åŠ¡æŒ‡ä»¤å®Œæˆå¯¹æ¯”ï¼šç»“è®ºä¸ºä»€ä¹ˆå˜ã€é£é™©ç‚¹æ€ä¹ˆè·Ÿç€å˜ã€‚
> 
> èƒ½æ‰¾åˆ°å¹¶è¯»æ‡‚æœ¬æ¬¡è¿è¡Œäº§ç‰©ï¼ŒçŸ¥é“å“ªäº›æ˜¯ç»™äººçœ‹çš„ï¼Œå“ªäº›æ˜¯ç»™ç¨‹åºç”¨çš„ã€‚

### ğŸ§± çº¦æŸå¥‘çº¦ï¼ˆContractï¼‰
- ä¸ä¿®æ”¹ä»»ä½• `.py` æ–‡ä»¶ï¼Œåªå…è®¸ä¿®æ”¹ `.env` æˆ–å‘½ä»¤è¡Œå‚æ•°ã€‚

### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰
**å¿…çœ‹**
- `src/debate_mas/main.py`ï¼šå…¥å£å‚æ•°ä¸é»˜è®¤å€¼  
- `src/debate_mas/protocol/renderer.py`ï¼šä¼šç”Ÿæˆå“ªäº›äº§ç‰©  
- `output_reports/*_memo.md`ï¼šå†³ç­–æ‘˜è¦  
- `output_reports/*_rebalance.csv`ï¼šç»“æ„åŒ–æŒ‡ä»¤  
- `output_reports/*_log.json`ï¼šè¿è¡Œæ—¥å¿—ä¸æ‘˜è¦ä¿¡æ¯  

**å¯é€‰**
- `src/debate_mas/loader/dossier.py`ï¼šæ¡ˆå·å¯¹è±¡æ˜¯ä»€ä¹ˆå½¢çŠ¶  
- `src/debate_mas/protocol/schema.py`ï¼šè¾“å‡ºåè®®æœ‰å“ªäº›å­—æ®µ  

### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ï¼ˆRunï¼‰

1) é»˜è®¤ Demoï¼š
```bash
python -m debate_mas
```

2) æ¢ä»»åŠ¡æŒ‡ä»¤ï¼Œå¯¹æ¯”ä¸€æ¬¡è¾“å‡ºå·®å¼‚ï¼š
```bash
python -m debate_mas --mission "åˆ†æå½“å‰é»„é‡‘ã€æœ‰è‰²é‡‘å±ETFçš„æŠ•èµ„æœºä¼š"
```

3) å¯é€‰ï¼šé¡ºæ‰‹éªŒè¯æ—¥æœŸä¸è¾“å‡ºç›®å½•ä¹Ÿå¯æ§ï¼š
```bash
python -m debate_mas --date "2025-06-26" --output_dir "./output_reports_stage1"
```

**è§‚å¯Ÿè¦ç‚¹ï¼ˆçœ‹åˆ°å³é€šè¿‡ï¼‰**
- ç»ˆç«¯å‡ºç° `ğŸŸ¦ VERBOSE_MODE=summary` å¼€å¤´ä¸ `ğŸŸ¦ VERBOSE END` ç»“å°¾  
- Hunter å‡ºç° `ğŸ› ï¸ Round 1 | Role=hunter`ï¼Œå¹¶èƒ½çœ‹åˆ°å·¥å…·è°ƒç”¨ï¼ˆå¸¸è§ï¼š`momentum / sharpe / reversal`ï¼‰  
- Auditor è‡³å°‘å‡ºç°ä¸€æ¬¡ `ğŸ› ï¸ Round ? | Role=auditor`  
- è‹¥å‡ºç° `__rerank_cutoff__`ï¼Œè¡¨ç¤ºå€™é€‰æ± åšäº† TopN æˆªæ–­  
- ç»“æŸåçœ‹åˆ° `âœ… äº§ç‰©å·²ç”Ÿæˆ`ï¼Œå¹¶æ‰“å°å‡ºäº§ç‰©è·¯å¾„æˆ–æ–‡ä»¶å
- åœ¨ `output_reports/` ç›®å½•ä¸‹ç¡®å®ç”Ÿæˆäº†æ–°æ–‡ä»¶ç»„ 

### âœ… éªŒæ”¶æ ‡å‡†ï¼ˆPassï¼‰
- ä¸¤æ¬¡è¿è¡Œéƒ½ç”Ÿæˆæ–°äº§ç‰©æ–‡ä»¶ç»„ï¼Œè‡³å°‘åŒ…å« `*_memo.md`ã€`*_rebalance.csv`ã€`*_log.json`  
- ä½ èƒ½æŒ‡å‡ºä¸¤æ¬¡ `memo.md` çš„ BUY/WATCH/REJECT æˆ–æƒé‡æ˜¯å¦å˜åŒ–  
- ä½ èƒ½æŒ‡å‡º Auditor çš„é£é™©ç‚¹æ˜¯å¦æ›´è´´è¿‘ä»»åŠ¡ä¸»é¢˜ï¼Œè€Œä¸æ˜¯åœç•™åœ¨é€šç”¨é£é™©  

### ğŸ” å¯è¿ç§»ç‚¹ï¼ˆTransferï¼‰

**1. ä¸è¦åŠ¨**
- å…¥å£å‘½ä»¤ç»“æ„ã€ä¸‰è§’è‰²è½®è½¬ã€äº§ç‰©è½ç›˜ä¸å®¡è®¡ç•™ç—•  
- æœ¬å…³ä¸æ”¹ä»»ä½• `.py` æ–‡ä»¶ä¸æ—¢æœ‰è§„åˆ™

**2. å¯æ›¿æ¢ï¼ˆä»…é€šè¿‡å‘½ä»¤è¡Œï¼‰**
- `--mission`ï¼šä»»åŠ¡æ–‡æœ¬ï¼ˆåŒä¸€å¥—æ¡†æ¶åœ¨ä¸åŒä¸»é¢˜ä¸‹ä¼šå¾—å‡ºä¸åŒç»“è®ºï¼‰
- `--date`ï¼šåŸºå‡†æ—¥æœŸï¼ˆåŒä¸€å¥—æ•°æ®åœ¨ä¸åŒæ—¥æœŸä¸‹ç»“è®ºä¼šå˜åŒ–ï¼‰
- `--output_dir`ï¼šè¾“å‡ºç›®å½•ï¼ˆäº§ç‰©è½ç›˜ä½ç½®å¯æ§ï¼‰
- `--folder`ï¼šä»…åœ¨â€œæ•°æ®å­—æ®µ/è¡¨åå¥‘çº¦ä¸€è‡´â€çš„å‰æä¸‹å¯æ›¿æ¢æ•°æ®ç›®å½•ï¼ˆå¯é€‰ï¼‰

**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
- æœ¬å…³åªåšâ€œæ¢ä»»åŠ¡æ–‡æœ¬/æ—¥æœŸ/è¾“å‡ºç›®å½•â€çš„è¿ç§»ä½“éªŒï¼›çœŸæ­£çš„â€œæ¢ææ–™å¥‘çº¦ä¸è¾“å‡ºç»“æ„â€ä¼šåœ¨åç»­å…³å¡å±•å¼€

</details>

---

# é˜¶æ®µäºŒï¼šæ ¸å¿ƒé—­ç¯ (Core Loop)

## å…³å¡-02ï½œçŠ¶æ€è´¦æœ¬ Stateï¼špayload / transcript / round / stop_reason

<details>
<summary><b>Checkpoint 02 â€” çŠ¶æ€è´¦æœ¬ State ã€è¯¦æƒ…ã€‘</b></summary>

> **payload**å¯¹åº” state é‡Œ **â€œè¦è¢«è¯»å†™çš„å­—æ®µé›†åˆâ€**ï¼ˆå« mission/ref_date/dossier_viewã€å››ä¸ªäº§ç‰©æ’æ§½ã€stop_reasonã€tool_trace ç­‰ï¼‰
>
> **transcript**å¯¹åº”`messages`ï¼ˆå¯¹è¯å†å²ï¼‰+ `history`ï¼ˆç»“æ„åŒ–è¿‡ç¨‹å†å²ï¼‰ç­‰

### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- ç†è§£å¹¶å®ç°â€œå…±äº«è´¦æœ¬â€è¿™ä»¶äº‹ï¼šå¤šè§’è‰²ä¸ç›´æ¥é€šä¿¡ï¼Œåªé€šè¿‡ `state` å…±äº«äº‹å®ä¸äº§ç‰©  
- è·‘é€šæœ€å°çŠ¶æ€æµè½¬ï¼šåˆå§‹åŒ–ä¸€è½®å¹²å‡€çŠ¶æ€ã€æ¨è¿›è½®æ¬¡ã€å†™å…¥å€™é€‰ä¸è´¨ç–‘ã€è®°å½•åœæœºåŸå›   
- æ˜ç¡®å“ªäº›å­—æ®µæ˜¯æ¡†æ¶é€šç”¨çš„ï¼Œå“ªäº›æ˜¯æœ¬é¡¹ç›®ä¸º ETF ä¾‹å­æ‰©å±•å‡ºæ¥çš„

### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ `src/debate_mas/core/state.py`  
- ä¸æ”¹ graphã€engineã€skills çš„é€»è¾‘ï¼Œä¸å¼•å…¥æ–°ä¾èµ–  
- ç›®æ ‡ä¸æ˜¯â€œæ›´èªæ˜â€ï¼Œè€Œæ˜¯ç¨³å®šã€å¯è¿½æº¯ã€å¥½æµ‹è¯•

### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰
**å¿…çœ‹**
- `src/debate_mas/core/state.py`ï¼šæœ¬å…³ä¸»æ–‡ä»¶  
- `src/debate_mas/core/config.py`ï¼šç†è§£ `MAX_ROUNDS` ä¸å·¥å…·æ²»ç†ã€è·¨è½®æ§åˆ¶å¼€å…³çš„æ¥æº  
- `src/debate_mas/loader/dossier.py`ï¼šç¡®è®¤ `Dossier` çš„å½¢çŠ¶ï¼Œä»¥åŠ `frozen_view()` çš„ç”¨é€”  

**å¿…å†™**
- `DebateState`ï¼šå­—æ®µåˆ†ç»„è¦æ¸…æ¥šï¼Œè‡³å°‘è®©è¿™äº›å­—æ®µç¨³å®šå­˜åœ¨  
  - `mission / ref_date / dossier / dossier_view`  
  - `messages / round_idx`  
  - `candidates_cur / objections_cur / diff_cur / decisions_cur`  
  - `stop_reason`  
  - `history` ä½œä¸ºå¯å¤ç›˜çš„ç»“æ„åŒ–å†å²å®¹å™¨  
- `init_state()`ï¼šå¿…é¡»è¿”å›ç¬¬ä¸€è½®å¹²å‡€çŠ¶æ€ï¼Œé¿å… engine/graph è¯»å­—æ®µæ—¶ KeyError  
- `reset_round_runtime()` ä¸ `bump_round()`ï¼šä¿è¯æ¯è½® runtime é‡ç½®å¯ç”¨  
- `push_candidates / push_objections / push_diff / push_decisions`ï¼šåŒæ—¶å†™å…¥ cur ä¸ history  

<details>
<summary><b> ğŸ“„ Checkpoint-02ï¼šstate.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/core/state.py 
from __future__ import annotations

import json
import hashlib
from typing import Any, Dict, List, Optional, Set, TypedDict

from langchain_core.messages import BaseMessage
from debate_mas.loader.dossier import Dossier

# ============================================================
# 0) å°å·¥å…·ï¼šhistory ä¸â€œç¨³å®šæ€§æŒ‡çº¹â€
# ============================================================
# æ ‡è®°è¯´æ˜
# - å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ï¼šè·‘é€šä»»ä½•å¸¦ skills çš„ Debate MAS éƒ½å¿…é¡»æœ‰
# - å»ºè®®åšï¼ˆæ¡†æ¶é€šç”¨ï¼‰ï¼šæå‡æ”¶æ•›ä¸å¯æµ‹è¯•æ€§ï¼Œä½†ä¸åšä¹Ÿèƒ½è·‘
# - åç»­å†è®²ï¼ˆæ‰©å±•ä½ï¼‰ï¼šæœ¬å…³åªè¦åˆå§‹åŒ–åˆç†ï¼Œä¸å½±å“æœ€å°é—­ç¯
# - ETFç›¸å…³ï¼ˆä»»åŠ¡æ‰©å±•ï¼‰ï¼šä¸ ETF æŠ•å†³èƒŒæ™¯å¼ºç»‘å®šï¼Œè¿ç§»åˆ°åˆ«çš„ä»»åŠ¡å¯æ›¿æ¢æˆ–åˆ å‡

_HISTORY_DEFAULT: Dict[str, List[Any]] = {
    "candidates": [],
    "objections": [],
    "diffs": [],
    "decisions": [],
}


def _ensure_history(st: "DebateState") -> None:
    """
    ç»Ÿä¸€ history åˆå§‹åŒ–ï¼Œé¿å…æ¯ä¸ª push_* éƒ½å†™ä¸€é setdefaultã€‚

    Args:
        st: DebateStateï¼Œå½“å‰è´¦æœ¬

    Returns:
        None
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
    # 1) ç¡®ä¿ st["history"] å­˜åœ¨
    # 2) ç¡®ä¿ history åŒ…å«å››ä¸ª keyï¼šcandidates / objections / diffs / decisions
    # 3) æ¯ä¸ª key çš„ value å¿…é¡»æ˜¯â€œæ–°çš„ list å¯¹è±¡â€ï¼ˆä¸è¦å¤ç”¨ _HISTORY_DEFAULT é‡Œçš„ listï¼‰
    raise NotImplementedError


def _stable_dumps(obj: Any) -> str:
    """
    æŠŠå¯¹è±¡ç¨³å®šåºåˆ—åŒ–æˆå­—ç¬¦ä¸²ï¼Œç”¨äºè®¡ç®—æŒ‡çº¹ã€‚

    Args:
        obj: ä»»æ„å¯åºåˆ—åŒ–å¯¹è±¡

    Returns:
        ç¨³å®šçš„ JSON å­—ç¬¦ä¸²
    """
    # TODOã€å»ºè®®åšï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
    # - ä¼˜å…ˆ json.dumps(obj, ensure_ascii=False, sort_keys=True, separators=(",", ":"))
    # - è‹¥å¤±è´¥ï¼ˆä¸å¯åºåˆ—åŒ–ï¼‰ï¼Œé€€åŒ–ä¸º json.dumps(str(obj), ensure_ascii=False)
    raise NotImplementedError


def _fp(obj: Any) -> str:
    """
    ç”ŸæˆæŒ‡çº¹ï¼Œç”¨äºåˆ¤æ–­è·¨è½®æ˜¯å¦â€œäº§ç‰©æ²¡å˜â€ã€‚

    Args:
        obj: ä»»æ„å¯¹è±¡

    Returns:
        sha1 åå…­è¿›åˆ¶å­—ç¬¦ä¸²
    """
    # TODOã€å»ºè®®åšï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
    # return hashlib.sha1(_stable_dumps(obj).encode("utf-8")).hexdigest()
    raise NotImplementedError


# ============================================================
# 1) è´¦æœ¬ç»“æ„ DebateState
# ============================================================

class DebateState(TypedDict, total=False):
    # ---------- è¾“å…¥ ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    mission: str
    ref_date: Optional[str]
    dossier: Dossier
    dossier_view: Dict[str, Any]

    # ---------- å¯¹è¯ä¸è½®æ¬¡ ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    messages: List[BaseMessage]
    round_idx: int

    # ---------- â€œæœ€æ–°ç‰ˆâ€ç»“æ„åŒ–äº§ç‰© ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    candidates_cur: List[Dict[str, Any]]
    objections_cur: List[Dict[str, Any]]
    diff_cur: Dict[str, Any]
    decisions_cur: List[Dict[str, Any]]

    # ---------- å†å²å®¹å™¨ ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    history: Dict[str, List[Any]]

    # ---------- åœæœºä¸å®¡è®¡ ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    stop_reason: Optional[str]
    tool_trace: List[Dict[str, Any]]

    # ---------- è¿è¡ŒæœŸè¾…åŠ© ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘ï¼šæœ¬å…³åªè¦èƒ½åˆå§‹åŒ–ã€ä¸ KeyError
    stable_rounds: int
    phase: str
    artifacts: Optional[Dict[str, str]]
    tool_cache: Dict[str, Any]

    # ---------- å…¼å®¹æ—§å­—æ®µ ----------
    # TODOã€åç»­å†è®²ï¼ˆæ‰©å±•ä½ï¼‰ã€‘ï¼šæœ¬å…³åªåˆå§‹åŒ–ï¼Œä¸è¦æ±‚ç†è§£
    candidates: List[Dict[str, Any]]
    risk_reports: List[Dict[str, Any]]
    decisions: List[Dict[str, Any]]

    # ---------- è§’è‰²å»ºè®®ä¸è¯´è¯äºº ----------
    # TODOã€åç»­å†è®²ï¼ˆæ‰©å±•ä½ï¼‰ã€‘ï¼šæœ¬å…³åªåˆå§‹åŒ–
    hunter_stop_suggest: str
    auditor_stop_suggest: str
    pm_stop_suggest: str
    _last_speaker_role: str

    # ---------- Tool Guardï¼šæ¯è½®é‡ç½® ----------
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘ï¼šreset_round_runtime è¦ä¿è¯è¿™äº›å­—æ®µæ¯è½®å¯ç”¨
    _round_tool_calls: Dict[str, int]
    _round_tool_calls_ok: Dict[str, int]
    _round_fingerprints: Set[str]
    _round_guard_denied: bool
    _round_missing_evidence: bool

    # ---------- åç»­å…³å¡çš„è·¨è½®æ§åˆ¶ä½ ----------
    # TODOã€åç»­å†è®²ï¼ˆæ‰©å±•ä½ï¼‰ã€‘ï¼šæœ¬å…³åªåˆå§‹åŒ–
    _need_evidence: bool
    _need_evidence_symbols: List[str]
    _need_evidence_actions: List[str]

    _need_more_candidates: bool
    _need_more_candidates_min: int
    _need_more_candidates_have: int
    _need_more_candidates_missing: int
    _need_more_candidates_reason: str

    _last_stable_fp: str
    _force_hunter_tool: bool

    # ---------- ETFç›¸å…³ï¼šä¸¤é˜¶æ®µ pipeline ----------
    # TODOã€ETFç›¸å…³ï¼ˆä»»åŠ¡æ‰©å±•ï¼‰ã€‘ï¼šè¿ç§»åˆ°åˆ«çš„ä»»åŠ¡å¯æ›¿æ¢æˆ–åˆ å‡
    _hunter_pipeline_stage: str
    survivor_universe: List[str]
    _need_recall_diversity: bool
    _need_recall_diversity_reason: str
    _need_rerank_composite: bool
    _need_rerank_composite_reason: str
    _hunter_round_sniper_strategies: List[str]


# ============================================================
# 2) åˆå§‹åŒ–ä¸æ¯è½® runtime é‡ç½®
# ============================================================

def init_state(
    mission: str,
    dossier: Dossier,
    ref_date: Optional[str] = None,
    messages: Optional[List[BaseMessage]] = None,
) -> DebateState:
    """
    è¿”å›ç¬¬ä¸€è½®å¹²å‡€çŠ¶æ€ï¼Œé¿å… engine/graph è¯»å­—æ®µæ—¶ KeyErrorã€‚

    Args:
        mission: æœ¬æ¬¡ä»»åŠ¡æ–‡æœ¬
        dossier: æ¡ˆå·å¯¹è±¡
        ref_date: åŸºå‡†æ—¥æœŸï¼Œå¯é€‰
        messages: åˆå§‹å¯¹è¯ï¼Œå¯é€‰

    Returns:
        st: DebateState
    """
    st: DebateState = {}

    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘æ ¸å¿ƒå­—æ®µåˆå§‹åŒ–
    # - mission / ref_date / dossier / dossier_view
    # - messages / round_idx
    # - candidates_cur / objections_cur / diff_cur / decisions_cur
    # - history / stop_reason / tool_trace
    # - stable_rounds / phase / artifacts / tool_cache

    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘dossier_view
    # - è‹¥ dossier æœ‰ frozen_view()ï¼šä½¿ç”¨å®ƒ
    # - å¦åˆ™ï¼šä½¿ç”¨ {}

    # TODOã€åç»­å†è®²ï¼ˆæ‰©å±•ä½ï¼‰ã€‘å…¶ä½™çŠ¶æ€ä½ï¼šç»™åˆç†é»˜è®¤å€¼å³å¯

    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘åˆå§‹åŒ–æœ¬è½® runtime
    reset_round_runtime(st)
    return st


def reset_round_runtime(st: DebateState) -> None:
    """
    æ¯è½® runtime é‡ç½®ï¼šå·¥å…·è°ƒç”¨æ¬¡æ•°ã€å»é‡æŒ‡çº¹ã€guard çŠ¶æ€ç­‰ã€‚

    Args:
        st: DebateState

    Returns:
        None
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘è‡³å°‘ä¿è¯è¿™äº›å­—æ®µæ¯è½®å¯ç”¨
    # st["_round_tool_calls"] = {"hunter": 0, "auditor": 0, "pm": 0}
    # st["_round_tool_calls_ok"] = {"hunter": 0, "auditor": 0, "pm": 0}
    # st["_round_fingerprints"] = set()
    # st["_round_guard_denied"] = False
    # st["_round_missing_evidence"] = False
    raise NotImplementedError


def bump_round(st: DebateState) -> None:
    """
    è½®æ¬¡æ¨è¿›ï¼šround_idx += 1ï¼Œå¹¶é‡ç½®æ¯è½® runtimeã€‚

    Args:
        st: DebateState

    Returns:
        None
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    # 1) st["round_idx"] += 1ï¼ˆæ³¨æ„ int åŒ–ï¼‰
    # 2) reset_round_runtime(st)
    raise NotImplementedError


# ============================================================
# 3) push ç³»åˆ—ï¼šæŠŠç»“æ„åŒ–äº§ç‰©è½åˆ°è´¦æœ¬
# ============================================================

def push_candidates(st: DebateState, items: List[Dict[str, Any]]) -> None:
    """
    å†™å…¥æœ¬è½®å€™é€‰ï¼Œå¹¶è¿½åŠ åˆ° historyã€‚

    Args:
        st: DebateState
        items: å€™é€‰åˆ—è¡¨

    Returns:
        None
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘
    # 1) st["candidates_cur"] = list(items or [])
    # 2) å…¼å®¹å­—æ®µï¼šst["candidates"] = st["candidates_cur"]ï¼ˆè‹¥ä½ ä»¬è¿˜åœ¨ç”¨ï¼‰
    # 3) _ensure_history(st)
    # 4) st["history"]["candidates"].append({"round": round_idx, "items": st["candidates_cur"]})
    raise NotImplementedError


def push_objections(st: DebateState, items: List[Dict[str, Any]]) -> None:
    """
    å†™å…¥æœ¬è½®è´¨ç–‘ç‚¹ï¼Œå¹¶è¿½åŠ åˆ° historyã€‚
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘åŒä¸Šï¼šå†™ objections_cur + append history
    raise NotImplementedError


def push_diff(st: DebateState, diff_obj: Dict[str, Any]) -> None:
    """
    å†™å…¥æœ¬è½® diffï¼Œå¹¶è¿½åŠ åˆ° historyã€‚
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘å†™ diff_cur + append history
    raise NotImplementedError


def push_decisions(st: DebateState, items: List[Dict[str, Any]]) -> None:
    """
    å†™å…¥æœ¬è½®è£å†³ï¼Œå¹¶è¿½åŠ åˆ° historyã€‚
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘å†™ decisions_cur + append historyï¼ˆå¯åŒæ­¥å…¼å®¹å­—æ®µ decisionsï¼‰
    raise NotImplementedError


# ============================================================
# 4) å»ºè®®å¢å¼ºï¼šå€™é€‰åˆå¹¶ä¸æ”¶æ•›
# ============================================================

def push_candidates_merge(st: DebateState, incoming: List[Dict[str, Any]]) -> None:
    """
    å€™é€‰åˆå¹¶ç­–ç•¥ï¼šåªè¡¥å……/ä¿®è®¢ï¼Œä¸å·å·åˆ æ± å­ã€‚

    è¯´æ˜ï¼š
        - è¿™æ˜¯â€œæ¡†æ¶é€šç”¨çš„äº§ç‰©åˆå¹¶æ€è·¯â€ï¼Œä½†è¿™é‡Œçš„ symbol/score æ›´è´´è¿‘ ETF å€™é€‰
        - è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ å¯ä»¥æŠŠ symbol æ”¹æˆ idï¼ŒæŠŠ score æ”¹æˆ priority

    TODOã€å»ºè®®åšï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        1) prev_items = st.get("candidates_cur", []) or []
        2) ä»¥ keyï¼ˆå¦‚ symbolï¼‰åˆå¹¶ï¼šincoming è¦†ç›–åŒ key
        3) æŒ‰ score ç”±é«˜åˆ°ä½æ’åºï¼Œæ¬¡åºç”¨ key ç¨³å®šåŒ–
        4) å†™å› candidates_curï¼Œå¹¶å†™å…¥ history

    Args:
        st: DebateState
        incoming: æ–°å¢æˆ–ä¿®è®¢çš„å€™é€‰åˆ—è¡¨

    Returns:
        None
    """
    raise NotImplementedError


def bump_stable_rounds(st: DebateState, *, reset_if_changed: bool = True) -> int:
    """
    ç”¨ candidates + objections + diff ç”ŸæˆæŒ‡çº¹ï¼›è‹¥ä¸å˜åˆ™ stable_rounds += 1ã€‚

    TODOã€å»ºè®®åšï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        1) cur = {"candidates": ..., "objections": ..., "diff": ...}
        2) cur_fp = _fp(cur)
        3) prev_fp = st.get("_last_stable_fp", "")
        4) è‹¥ç›¸ç­‰ï¼šstable_rounds += 1
        5) è‹¥ä¸ç­‰ï¼šæŒ‰ reset_if_changed é‡ç½®ï¼Œå¹¶æ›´æ–° _last_stable_fp
        6) return stable_rounds

    Args:
        st: DebateState
        reset_if_changed: è‹¥äº§ç‰©å˜åŒ–æ˜¯å¦æŠŠ stable_rounds ç½® 0

    Returns:
        stable_rounds: å½“å‰è¿ç»­ç¨³å®šè½®æ•°
    """
    raise NotImplementedError

```
</details>

### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšå°éªŒæ”¶ã€‚è¯·å…ˆåœ¨é¡¹ç›®æ ¹ç›®å½•æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼Œç„¶åå®‰è£…ä¾èµ–å¹¶è¿è¡Œæµ‹è¯•ã€‚

1) åœ¨æ ¹ç›®å½•åˆ›å»ºæ–‡ä»¶ï¼š`tests/checkpoints/test_state_min.py` 
 
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

    <details>
    <summary><b>tests/checkpoints/test_state_min.py</b></summary>

    ```py
    from __future__ import annotations

    from typing import Any

    from debate_mas.core.state import (
        init_state,
        push_candidates,
        push_objections,
        push_diff,
        push_decisions,
        bump_round,
    )

    class FakeDossier:
        """åªæä¾› frozen_view()ï¼Œé¿å…ä¾èµ–çœŸå® Dossier åˆå§‹åŒ–å‚æ•°ã€‚"""
        def frozen_view(self) -> dict[str, Any]:
            return {"ok": True}


    def _assert_has_keys(st: dict, keys: list[str]) -> None:
        missing = [k for k in keys if k not in st]
        assert not missing, f"missing keys: {missing}"


    def test_init_state_has_core_fields() -> None:
        st = init_state("x", FakeDossier(), ref_date="2025-10-26")

        core_keys = [
            "mission",
            "ref_date",
            "dossier",
            "dossier_view",
            "messages",
            "round_idx",
            "candidates_cur",
            "objections_cur",
            "diff_cur",
            "decisions_cur",
            "history",
            "stop_reason",
            "tool_trace",
        ]
        _assert_has_keys(st, core_keys)

        assert st["round_idx"] == 0
        assert isinstance(st["messages"], list)
        assert isinstance(st["dossier_view"], dict)

        for k in ["candidates", "objections", "diffs", "decisions"]:
            assert k in st["history"], f"history missing {k}"
            assert isinstance(st["history"][k], list), f"history[{k}] must be list"


    def test_push_writes_cur_and_history() -> None:
        st = init_state("x", FakeDossier())

        push_candidates(st, [{"id": "A", "score": 1}])
        push_objections(st, [{"id": "A", "risk": "x"}])
        push_diff(st, {"changed": True})
        push_decisions(st, [{"action": "WATCH"}])

        assert len(st["candidates_cur"]) == 1
        assert len(st["objections_cur"]) == 1
        assert isinstance(st["diff_cur"], dict)
        assert len(st["decisions_cur"]) == 1

        assert len(st["history"]["candidates"]) == 1
        assert len(st["history"]["objections"]) == 1
        assert len(st["history"]["diffs"]) == 1
        assert len(st["history"]["decisions"]) == 1

        assert st["history"]["candidates"][0]["round"] == 0
        assert st["history"]["objections"][0]["round"] == 0
        assert st["history"]["diffs"][0]["round"] == 0
        assert st["history"]["decisions"][0]["round"] == 0


    def test_bump_round_resets_runtime() -> None:
        st = init_state("x", FakeDossier())

        st["_round_tool_calls"]["hunter"] = 7
        bump_round(st)

        assert st["round_idx"] == 1
        assert st["_round_tool_calls"]["hunter"] == 0
        assert st["_round_guard_denied"] is False
        assert st["_round_missing_evidence"] is False

    ```
    </details>

2) ç”¨ uv å®‰è£… pytestï¼ˆä¸¤ç§æ–¹å¼äºŒé€‰ä¸€ï¼‰

```bash
# æ–¹å¼ Aï¼šæ¨èï¼ˆå†™å…¥é¡¹ç›®ä¾èµ–ï¼Œé€‚åˆæœ‰ pyproject.toml çš„ä»“åº“ï¼‰
uv add --dev pytest
```

```bash
# æ–¹å¼ Bï¼šåªåœ¨å½“å‰ç¯å¢ƒå®‰è£…ï¼ˆä¸æ”¹é¡¹ç›®ä¾èµ–å£°æ˜ï¼‰
uv pip install pytest
```

3) è¿è¡Œæµ‹è¯•

```bash
uv run pytest -q tests/checkpoints/test_state_min.py
```

### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰  
  - `3 passed in ...s`  
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `KeyError`ã€`AssertionError`ã€`ImportError`
- å¦‚æœå¤±è´¥ï¼Œä½ èƒ½ä»æŠ¥é”™ä¿¡æ¯å®šä½åˆ°ï¼š
  - ç¼ºå­—æ®µï¼š`missing keys: [...] `
  - history ç»“æ„ä¸å¯¹ï¼š`history missing ...` æˆ– `history[...] must be list`
  - runtime æ²¡é‡ç½®ï¼š`_round_tool_calls` æˆ– `_round_guard_denied` æ–­è¨€å¤±è´¥

### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `state.py` è®¾è®¡ç›®æ ‡æ˜¯ï¼š**æ¡†æ¶å­—æ®µç¨³å®šã€ä¸šåŠ¡å­—æ®µå¯æ›¿æ¢**ã€‚è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ ä¸éœ€è¦é‡å†™ Debate MASï¼Œåªè¦æŠŠâ€œä¸šåŠ¡äº§ç‰©çš„å½¢çŠ¶â€å’Œâ€œè¯»å–ææ–™çš„æ–¹å¼â€æ¢æ‰ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

è¿™äº›æ˜¯ä»»ä½•â€œå¤šè§’è‰²è¾©è®º + skills å·¥å…· + å¯å®¡è®¡è¾“å‡ºâ€çš„ Debate MAS éƒ½ç¦»ä¸å¼€çš„éª¨æ¶ã€‚è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡æ—¶ï¼Œ**å»ºè®®ä¸æ”¹å­—æ®µåã€ä¸æ”¹è¯­ä¹‰**ã€‚

<details>
<summary><b>state.pyä¸éœ€è¦åŠ¨å…·ä½“å†…å®¹çš„åœ°æ–¹</b></summary>

- **è¾“å…¥ä¸æ¡ˆå·å…¥å£**
  - `mission / ref_date / dossier / dossier_view`
  - è¯´æ˜ï¼šä¸ç®¡ä½ åš ETFã€åˆè§„ã€è¯„å®¡ï¼Œéƒ½éœ€è¦ä»»åŠ¡æ–‡æœ¬ä¸ææ–™å…¥å£ã€‚`dossier_view` æ˜¯å¯å†»ç»“çš„â€œæ‘˜è¦è§†å›¾â€ï¼Œç”¨äºæ—¥å¿—ã€æç¤ºè¯ä¸æŠ¥å‘Šå¼•ç”¨ã€‚

- **å¯¹è¯ä¸è½®æ¬¡æ¨è¿›**
  - `messages / round_idx`
  - `init_state() / bump_round()`
  - è¯´æ˜ï¼šæ‰€æœ‰è§’è‰²éƒ½è¦åœ¨åŒä¸€æ¡å¯¹è¯é“¾å’Œè½®æ¬¡ä¸Šåä½œï¼Œè½®æ¬¡æ¨è¿›å¿…é¡»ç¨³å®šå¯æµ‹ã€‚

- **ç»“æ„åŒ–äº§ç‰©çš„â€œå½“å‰å€¼ + å†å²â€**
  - `candidates_cur / objections_cur / diff_cur / decisions_cur`
  - `history`
  - `push_candidates / push_objections / push_diff / push_decisions`
  - è¯´æ˜ï¼šå¤šè§’è‰²ä¸ç›´æ¥é€šä¿¡ï¼Œå…¨é è¿™äº›å­—æ®µâ€œå…±äº«äº‹å®â€ã€‚`history` æ˜¯å¤ç›˜ä¸æŠ¥å‘Šçš„åŸºç¡€ã€‚

- **åœæœºä¸å®¡è®¡**
  - `stop_reason / tool_trace`
  - è¯´æ˜ï¼šåœæœºåŸå› ç”¨äº graph/æŠ¥å‘Šè§£é‡Šï¼›`tool_trace` æ˜¯â€œè¯æ®é“¾â€çš„æ€»å…¥å£ï¼Œåç»­å…³å¡ä¼šæŠŠå·¥å…·è°ƒç”¨å†™è¿›å»å¹¶åœ¨æŠ¥å‘Šå¼•ç”¨ã€‚

- **æ¯è½® runtime é‡ç½®**
  - `reset_round_runtime()`
  - `_round_tool_calls / _round_tool_calls_ok / _round_fingerprints / _round_guard_denied / _round_missing_evidence`
  - è¯´æ˜ï¼šåªè¦ä½ æœ‰å·¥å…·æ²»ç†ï¼ˆæ¬¡æ•°é™åˆ¶ã€åŒå‚å»é‡ã€guard æ‹¦æˆªï¼‰ï¼Œè¿™äº›è®¡æ•°å™¨ä¸çŠ¶æ€ä½å°±å¿…é¡»æ¯è½®å¯ç”¨ã€‚

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–é‡å†™**

ä¸‹é¢è¿™äº›å†…å®¹çš„â€œæ€æƒ³æ˜¯é€šç”¨çš„â€ï¼Œä½†å­—æ®µåã€åˆå¹¶ keyã€æ’åºè§„åˆ™ã€pipeline çŠ¶æ€ä½ï¼Œå¾€å¾€è·Ÿä¸šåŠ¡å¼ºç»‘å®šã€‚è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œ**å…è®¸ä½ æ”¹å®ƒä»¬**ï¼Œä½†å»ºè®®ä¿æŒâ€œå†™ cur + å†™ historyâ€çš„æ¨¡å¼ä¸å˜ã€‚

- **å€™é€‰åˆå¹¶ç­–ç•¥**
  - `push_candidates_merge()` é‡Œé»˜è®¤æŒ‰ `symbol` åˆå¹¶ã€æŒ‰ `score` æ’åºï¼Œæ›´è´´è¿‘ ETFã€‚
  - æ¢ä¸šåŠ¡æ—¶ï¼Œä½ å¯ä»¥æŠŠ â€œsymbol/scoreâ€ æ¢æˆä½ çš„ä¸»é”®ä¸ä¼˜å…ˆçº§å­—æ®µã€‚


  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ ETF å€™é€‰åˆå¹¶æ”¹æˆâ€œæ–¹æ¡ˆè¯„å®¡â€çš„ææ¡ˆåˆå¹¶</b></summary>

  ```py
  # TODOï¼šæ–¹æ¡ˆè¯„å®¡åœºæ™¯ï¼ˆproposal_id + priorityï¼‰
  def push_candidates_merge(st, incoming):
      # 1) ä»¥ proposal_id ä¸º key åˆå¹¶ï¼ˆincoming è¦†ç›–åŒ idï¼‰
      # 2) ä»¥ priority ç”±é«˜åˆ°ä½æ’åº
      # 3) å†™å› candidates_curï¼Œå¹¶ append history["candidates"]
      pass
  ```  
  </details>

- **æ”¶æ•›åˆ¤æ–­çš„æŒ‡çº¹å†…å®¹**
  - `bump_stable_rounds()` é»˜è®¤ç”¨ `candidates + objections + diff` ç”ŸæˆæŒ‡çº¹ã€‚
  - æ¢ä¸šåŠ¡æ—¶ï¼Œä½ å¯ä»¥è°ƒæ•´æŒ‡çº¹åŒ…å«çš„å­—æ®µï¼Œè®©â€œç¨³å®šâ€æ›´ç¬¦åˆä¸šåŠ¡å®šä¹‰ã€‚

  <details> 
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠç¨³å®šåˆ¤æ–­æ”¹æˆâ€œåˆåŒå®¡é˜…â€çš„æ¡æ¬¾é£é™©ç¨³å®š</b></summary>

    ```py
      # TODOï¼šåˆåŒå®¡é˜…åœºæ™¯ï¼ˆåªçœ‹ risk_flags + clause_changesï¼‰
      def bump_stable_rounds(st, reset_if_changed=True):
          # cur = {"risk_flags": st["objections_cur"], "clause_changes": st["diff_cur"]}
          # ç”¨ cur ç”ŸæˆæŒ‡çº¹ï¼Œè‹¥ç›¸åŒåˆ™ stable_rounds += 1
          pass
    ``` 
  </details> 

- **ETF pipeline ä¸è·¨è½®æ§åˆ¶ä½**
  - `_hunter_pipeline_stage / survivor_universe / _need_recall_diversity* / _need_rerank_composite*`
  - è¯´æ˜ï¼šè¿™äº›æ˜¯æœ¬é¡¹ç›®ä¸ºäº† ETF çš„ä¸¤é˜¶æ®µæµç¨‹å‡†å¤‡çš„çŠ¶æ€ä½ã€‚è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡ï¼š
    - ä½ å¯ä»¥åˆ æ‰å®ƒä»¬
    - æˆ–æ›¿æ¢æˆè‡ªå·±çš„æµç¨‹çŠ¶æ€ä½
    - ä½†è¦ä¿æŒâ€œé»˜è®¤åˆå§‹åŒ–åˆç†ï¼Œä¸è®© engine/graph KeyErrorâ€

  <details> 
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠä¸¤é˜¶æ®µ pipeline æ”¹æˆâ€œåŒ»ç–—ä¼šè¯Šâ€çš„æµç¨‹é˜¶æ®µ</b></summary>

    ```py
      # TODOï¼šåŒ»ç–—ä¼šè¯Šåœºæ™¯ï¼ˆtriage -> consult -> finalï¼‰
      # st["_pipeline_stage"] = "triage"
      # st["_need_more_tests"] = False
      # st["_need_more_tests_reason"] = ""
    ``` 
  </details> 

**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
  - **ä¸åŠ¨**ï¼š`init_state / bump_round / reset_round_runtime / push_* å†™ cur + history / stop_reason / tool_trace`
  - **å¯æ¢**ï¼šå€™é€‰çš„ä¸»é”®ä¸æ’åºå­—æ®µã€ç¨³å®šæŒ‡çº¹çš„ä¸šåŠ¡å®šä¹‰ã€ä¸šåŠ¡æµç¨‹é˜¶æ®µçŠ¶æ€ä½ï¼ˆETF pipeline éƒ¨åˆ†ï¼‰

> åªè¦ä½ éµå®ˆè¿™æ¡åŸåˆ™ï¼ŒDebate MAS çš„æ ¸å¿ƒé—­ç¯å°±èƒ½åœ¨ä¸åŒä¸šåŠ¡é‡Œå¤ç”¨ï¼Œè€Œä¸æ˜¯æ¨å€’é‡æ¥ã€‚

</details>

---

## å…³å¡-03ï½œè¾“å‡ºç»“æ„åŒ–åè®® Protocolï¼šCandidate / Objection / Decision

<details>
<summary><b>Checkpoint 03 â€” ç»“æ„åŒ–è¾“å‡ºåè®® Protocol ã€è¯¦æƒ…ã€‘</b></summary>

> **Candidate / Objection / Decision** åˆ†åˆ«å¯¹åº”ä¸‰ç±»â€œç»“æ„åŒ–äº§ç‰©â€ï¼š  
> - Candidateï¼šHunter çš„å€™é€‰ï¼ˆå†™å…¥ `state.candidates_cur`ï¼‰  
> - Objectionï¼šAuditor çš„è´¨ç–‘/é£é™©ï¼ˆå†™å…¥ `state.objections_cur`ï¼‰  
> - Decisionï¼šPM çš„æœ€ç»ˆè£å†³ï¼ˆå†™å…¥ `state.decisions_cur`ï¼Œå¹¶äº¤ç»™ Renderer è½ç›˜ï¼‰  
>
> æœ¬å…³è¦åšçš„æ˜¯ï¼š**æŠŠè¿™äº›äº§ç‰©çš„â€œå½¢çŠ¶â€å›ºå®šæˆåè®®ï¼ˆSchemaï¼‰ï¼Œå¹¶ç¡®ä¿ Renderer èƒ½ç¨³å®šæ¶ˆè´¹å¹¶è¾“å‡ºä¸‰ä»¶å¥—ã€‚**

### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- å®šä¹‰å¹¶ç¨³å®šä¸‰ç±»**ç»“æ„åŒ–äº§ç‰©**çš„æœ€å°åè®®ï¼šCandidate / Objection / Decision  
- æ˜ç¡® Schema ä¸ Renderer åˆ†å·¥ï¼šSchema è´Ÿè´£â€œç±»å‹ä¸å­—æ®µâ€ï¼ŒRenderer è´Ÿè´£â€œè½ç›˜ä¸å±•ç¤ºâ€  
- ç”¨ Pydantic æŠŠâ€œæ•°æ®å½¢çŠ¶â€å‰ç½®æ ¡éªŒï¼šè®©ç¼ºå­—æ®µ/é”™ç±»å‹å°½æ—©å¤±è´¥ï¼Œè¾“å‡ºæ›´å¯æµ‹è¯•ã€å¯å¤ç›˜


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ï¼š
  - `src/debate_mas/protocol/schema.py`
  - `src/debate_mas/protocol/renderer.py`
  - `src/debate_mas/protocol/__init__.py`
- ä¸æ”¹ graphã€engineã€skills çš„é€»è¾‘ï¼Œä¸å¼•å…¥æ–°ä¾èµ–  
- ç›®æ ‡ä¸æ˜¯â€œæ›´èªæ˜â€ï¼Œè€Œæ˜¯**åè®®æ›´ç¨³ã€æ¸²æŸ“æ›´å¯æ§ã€é”™è¯¯æ›´æ—©æš´éœ²**

### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰
**å¿…çœ‹**
- `src/debate_mas/protocol/schema.py`ï¼šåè®®å®šä¹‰ï¼ˆPydanticï¼‰  
- `src/debate_mas/protocol/renderer.py`ï¼šè¾“å‡ºæ¸²æŸ“ï¼ˆlog.json / memo.md / rebalance.csvï¼‰  
- `src/debate_mas/protocol/__init__.py`ï¼šimport è·¯å¾„ç¨³å®šæ€§
- `src/debate_mas/core/state.py`ï¼šç¡®è®¤ `decisions_cur / tool_trace / stop_reason` çš„æ¥æºä¸ç”¨é€”  

#### A) `protocol/schema.py`

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `DecisionAction`ï¼šç»Ÿä¸€æšä¸¾ `BUY / WATCH / REJECT`ï¼ˆè·¨ Persona / Skills / Core / Renderer å¯¹é½ï¼‰
- `SkillResult`ï¼šSkills çš„ç»Ÿä¸€è¿”å›ç»“æ„
  - å­—æ®µå¿…é¡»ç¨³å®šï¼š`success / data / insight / visuals / error_msg`
  - æä¾› `ok()` / `fail()` ä¸¤ä¸ª classmethodï¼ˆè®© Skills ä¸ç”¨æ‰‹å†™æ ·æ¿ï¼‰
- `ToolTraceEntry`ï¼šå·¥å…·ç•™ç—•çš„æœ€å°ç»“æ„ï¼ˆRenderer è¦èƒ½è½ç›˜ï¼‰
- `DebateMeta / DebateLog`ï¼šæœ€ç»ˆäº¤ä»˜ JSON çš„æœ€å°æœºå™¨å¯è¯»åè®®ï¼ˆlog.json çš„éª¨æ¶ï¼‰

**é€‰æ”¹ï¼ˆETF ä»»åŠ¡æ‰©å±•ï¼Œä½†ç»“æ„åŒ–æ€æƒ³é€šç”¨ï¼‰**
- `EtfCandidate`ï¼šCandidate çš„æœ€å°å­—æ®µï¼ˆä¾‹å¦‚ `symbol/score/reason/source_skill/extra`ï¼‰
- `EtfRiskReport`ï¼šObjection çš„æœ€å°å­—æ®µï¼ˆä¾‹å¦‚ `symbol/risk_score/notes + flags`ï¼‰
- `EtfDecision`ï¼šDecision çš„æœ€å°å­—æ®µï¼ˆä¾‹å¦‚ `symbol/action/weight/final_score/key_reasons/risk_warnings`ï¼‰
> è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä¸Šé¢ä¸‰ä¸ªå¯¹è±¡å¯ä»¥æ•´ä½“æ›¿æ¢æˆåˆ«çš„ä¸šåŠ¡å¯¹è±¡ï¼Œä½†â€œå¼ºç±»å‹ + å¯æ ¡éªŒâ€çš„æ€æƒ³ä¸å˜ã€‚

<details>
<summary><b> ğŸ“„ Checkpoint-03ï¼šschema.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/protocol/schema.py
"""
åè®®å®šä¹‰å±‚ (Protocol Schema)
å®šä¹‰å…¨ç³»ç»Ÿé€šç”¨çš„æ•°æ®äº¤äº’æ ‡å‡†ï¼š
- Layer 3 (Skills) ç”Ÿäº§è¿™äº›æ•°æ®
- Layer 2 (Core)   æ¶ˆè´¹/åˆå¹¶è¿™äº›æ•°æ®
- Layer 4 (Output) å±•ç¤º/è½ç›˜è¿™äº›æ•°æ®
"""
from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, ConfigDict


# =============================================================================
# 0) ç»Ÿä¸€æšä¸¾ï¼ˆè·¨å±‚å¯¹é½ï¼šPersona / Core / Skills / Rendererï¼‰
# =============================================================================
class DecisionAction(str, Enum):
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
    # ç»Ÿä¸€æšä¸¾å€¼ï¼Œè·¨å±‚å¯¹é½ï¼ˆPersona/Core/Skills/Rendererï¼‰
    BUY = "BUY"
    WATCH = "WATCH"
    REJECT = "REJECT"


# =============================================================================
# 1) é€šç”¨è¿”å›ï¼šSkillResult
# =============================================================================
class SkillResult(BaseModel):
    """
    [é€šç”¨åè®®] æŠ€èƒ½æ‰§è¡Œç»“æœæ ‡å‡†

    Teaching Notes:
    - success/insight: ç»™äººçœ‹
    - data: ç»™æœºå™¨æ¶ˆè´¹ï¼ˆå¯ä¸º List / Dict / Noneï¼‰
    - visuals: å›¾è¡¨è·¯å¾„ç•™ç—•ï¼ˆå¯ä¸ºç©ºï¼‰
    - error_msg: å¤±è´¥åŸå› ï¼ˆåªåœ¨ success=False æ—¶åº”å‡ºç°ï¼‰
    """
    model_config = ConfigDict(arbitrary_types_allowed=True)

    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘å­—æ®µå¿…é¡»ç¨³å®šå­˜åœ¨ï¼ˆSkills -> Coreï¼‰
    success: bool = Field(..., description="æ‰§è¡Œæ˜¯å¦æˆåŠŸ")
    data: Any = Field(default=None, description="ç»“æ„åŒ–è¿”å›ï¼ˆå¯¹è±¡/åˆ—è¡¨/å­—å…¸å‡å¯ï¼‰")
    insight: str = Field(..., description="è‡ªç„¶è¯­è¨€ç»“è®º")
    visuals: List[str] = Field(default_factory=list, description="ç”Ÿæˆçš„å›¾è¡¨è·¯å¾„åˆ—è¡¨")
    error_msg: Optional[str] = Field(default=None, description="é”™è¯¯ä¿¡æ¯ï¼ˆä»…å¤±è´¥æ—¶ï¼‰")

    @classmethod
    def ok(
        cls,
        data: Any = None,
        insight: str = "",
        visuals: Optional[List[str]] = None,
    ) -> "SkillResult":
        """
        å¿«æ·æ„é€ æˆåŠŸç»“æœï¼ˆdata å¯ä»¥æ˜¯ List / Dict / Noneï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # - success=True
        # - error_msg=None
        # - insight é»˜è®¤ä¸ºç©ºå­—ç¬¦ä¸²
        # - visuals é»˜è®¤ç©º list
        raise NotImplementedError

    @classmethod
    def fail(
        cls,
        error_msg: str,
        data: Any = None,
    ) -> "SkillResult":
        """
        å¿«æ·æ„é€ å¤±è´¥ç»“æœï¼ˆå…è®¸æŠŠ debug data å¸¦å›ï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # - success=False
        # - insight å½¢å¦‚ "æ‰§è¡Œå¤±è´¥: {error_msg}"
        # - visuals=[]
        # - error_msg=error_msg
        raise NotImplementedError


# =============================================================================
# 2) ä¸šåŠ¡ä¸­é—´äº§ç‰©ï¼ˆSkills äº§å‡º / Core æ¶ˆè´¹ / Output å±•ç¤ºï¼‰
# =============================================================================
# TODOã€é€‰æ”¹ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰ã€‘ï¼š
# - è¿™ä¸‰ç±»å¯¹è±¡æ˜¯ ETF ä»»åŠ¡æ‰©å±•ï¼ˆCandidate / Objection / Decisionï¼‰
# - è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡æ—¶å¯æ•´ä½“æ›¿æ¢ï¼Œä½†â€œå¼ºç±»å‹ + å¯æ ¡éªŒâ€æ€æƒ³ä¸å˜

class EtfCandidate(BaseModel):
    """
    Hunter çš„äº§ç‰©ï¼šå€™é€‰å¯¹è±¡ï¼ˆå¯è¿½æº¯ã€å¯æ’åºã€å¯è§£é‡Šï¼‰ã€‚

    Args:
        TODOï¼ˆå†™ä½ è®¤ä¸ºè¿™ä¸ªå¯¹è±¡å¿…é¡»å…·å¤‡çš„å­—æ®µå«ä¹‰ï¼Œä¾‹å¦‚ symbol/score/reason/source_skill/extraï¼‰

    Returns:
        TODOï¼ˆè¿”å›çš„æ˜¯ä¸€ä¸ª EtfCandidate å®ä¾‹ï¼›ä¼šè¢« Core å†™å…¥ state.candidates_curï¼Œå¹¶å¯è¢« Renderer/æ—¥å¿—æ¶ˆè´¹ï¼‰
    """
    # TODOã€é€‰æ”¹ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰ã€‘å­—æ®µå®šä¹‰
    symbol: str
    score: float
    reason: str
    source_skill: str
    extra: Dict[str, Any] = Field(default_factory=dict)


class EtfRiskReport(BaseModel):
    """
    Auditor çš„äº§ç‰©ï¼šé£é™©/è´¨ç–‘å¯¹è±¡ï¼ˆå¯è§£é‡Šã€å¯å®¡è®¡ï¼‰ã€‚

    Args:
        TODOï¼ˆå†™æ¯ä¸ªå­—æ®µä»£è¡¨ä»€ä¹ˆé£é™©ä¿¡å·/æ ‡è®°ï¼Œä¾‹å¦‚ risk_score/notes/flags çš„ä¸šåŠ¡å«ä¹‰ï¼‰

    Returns:
        TODOï¼ˆè¿”å›çš„æ˜¯ä¸€ä¸ª EtfRiskReport å®ä¾‹ï¼›ç”¨äºè·¨è§’è‰²å…±äº«â€œé£é™©äº‹å®â€ï¼Œå¹¶æ”¯æŒè½ç›˜å¤ç›˜ï¼‰
    """
    # TODOã€é€‰æ”¹ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰ã€‘å­—æ®µå®šä¹‰
    symbol: str
    liquidity_flag: Optional[str] = None
    premium_flag: Optional[str] = None
    sentiment_flag: Optional[str] = None
    risk_score: float = 0.0
    notes: List[str] = Field(default_factory=list)


class EtfDecision(BaseModel):
    """
    PM çš„äº§ç‰©ï¼šæœ€ç»ˆå†³ç­–å¯¹è±¡ï¼ˆå¯æ‰§è¡Œã€å¯è½ç›˜ã€å¯å›æ”¾ï¼‰ã€‚

    Args:
        TODOï¼ˆå†™æ¸…å­—æ®µå«ä¹‰ï¼šsymbol/action/weight/final_score/key_reasons/risk_warnings ç­‰ï¼‰

    Returns:
        TODOï¼ˆè¿”å› EtfDecision å®ä¾‹ï¼›ä¼šè¿›å…¥ log.json / memo.md / rebalance.csv çš„ç”Ÿæˆé“¾è·¯ï¼‰
    """
    # TODOã€é€‰æ”¹ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰ã€‘å­—æ®µå®šä¹‰
    symbol: str
    action: DecisionAction
    weight: float = Field(0.0, ge=0.0, le=1.0)
    final_score: float = 0.0
    key_reasons: List[str] = Field(default_factory=list)
    risk_warnings: List[str] = Field(default_factory=list)


# =============================================================================
# 3) Layer 4 äº¤ä»˜åè®®ï¼ˆâ€œå†³ç­–å¤‡å¿˜å½•â€ç»“æ„ï¼‰â€”â€”å¯é€‰ä½†å¼ºçƒˆå»ºè®®
# =============================================================================
class ToolTraceEntry(BaseModel):
    """
    å·¥å…·è°ƒç”¨ç•™ç—•ï¼ˆCore å¯é€‰æ”¹å…¥ï¼ŒRenderer åªè´Ÿè´£è½ç›˜ï¼‰

    Args:
        TODO

    Returns:
        TODO
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘å­—æ®µå¿…é¡»ç¨³å®šï¼ˆè½ç›˜ + å®¡è®¡ï¼‰
    tool: str
    args: Dict[str, Any] = Field(default_factory=dict)
    ok: bool = True
    insight: str = ""
    error_msg: Optional[str] = None
    visuals: List[str] = Field(default_factory=list)


class DebateMeta(BaseModel):
    """
    äº¤ä»˜ç‰©å…ƒä¿¡æ¯ï¼ˆå¼ºçƒˆå»ºè®® Core å¡«ï¼‰

    Args:
        TODO

    Returns:
        TODO
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘å­—æ®µå®šä¹‰ï¼ˆæœ€å°å¯ç”¨äº¤ä»˜åè®®ï¼‰
    mission: str = ""
    ref_date: Optional[str] = None
    rounds: int = 0
    stop_reason: Optional[str] = None
    tool_trace: List[ToolTraceEntry] = Field(default_factory=list)
    dossier_meta: Dict[str, Any] = Field(default_factory=dict)
    extras: Dict[str, Any] = Field(default_factory=dict)


class DebateLog(BaseModel):
    """
    æœ€ç»ˆäº¤ä»˜ JSON çš„ç»“æ„åŒ–åè®®ï¼ˆæœºå™¨å¯è¯»ã€å¯å›æ”¾ï¼‰

    Args:
        TODO

    Returns:
        TODO
    """
    # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘å­—æ®µå®šä¹‰ï¼ˆlog.json éª¨æ¶ï¼‰
    timestamp: str
    meta: DebateMeta = Field(default_factory=DebateMeta)
    decisions: List[EtfDecision] = Field(default_factory=list)
    visuals: List[str] = Field(default_factory=list)

```
</details>


#### B) `protocol/renderer.py`

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼šRenderer ç¨³å®šæ€§ï¼‰**
- `DebateRenderer.render()`ï¼šå¿…é¡»ç”Ÿæˆä¸‰ä»¶å¥—å¹¶è¿”å›è·¯å¾„å­—å…¸
  - `log.json`ï¼šæœºå™¨å¯è¯»ï¼ˆDebateLogï¼‰
  - `memo.md`ï¼šäººå¯è¯»ï¼ˆæ‘˜è¦ + è¡¨æ ¼ + é€æ ‡çš„è§£é‡Šï¼‰
  - `rebalance.csv`ï¼šå¯æ‰§è¡Œ/å¯äº¤æ¥ï¼ˆç¨³å®šåˆ—ï¼‰
- `_build_meta()`ï¼šå¿…é¡»å…¼å®¹ä¸¤ç§è¾“å…¥æ ¼å¼ï¼ˆé¿å… Core ä¼ å‚å˜åŠ¨å¯¼è‡´ KeyErrorï¼‰
  - æ‰å¹³ dictï¼š`{"ref_date":..., "rounds":..., ...}`
  - åŒ…ä¸€å±‚ metaï¼š`{"meta": {...}}`
- `_save_json_log()`ï¼šç¡®ä¿ `DebateLog.model_dump()` å¯ JSON åºåˆ—åŒ–å¹¶è½ç›˜
- `_collect_visuals()`ï¼šæ”¶é›† `meta.extras.visuals` + `tool_trace.visuals`ï¼Œå¹¶å»é‡ä¿åº

**é€‰æ”¹ï¼ˆå±•ç¤ºå±‚/ä¸šåŠ¡äº¤ä»˜åå¥½ï¼‰**
- `_save_markdown_memo()`ï¼šè¡¨æ ¼åˆ—/æ–‡æ¡ˆå¯ä»¥æŒ‰ä¸šåŠ¡è°ƒæ•´ï¼Œä½†è¦ä¿è¯è¯»å–å­—æ®µä¸ `EtfDecision` å¯¹é½
- `_save_rebalance_csv()`ï¼šCSV è¾“å‡ºåˆ—å¯ä»¥è°ƒæ•´ï¼Œä½†é»˜è®¤åº”ä¿æŒç¨³å®šï¼ˆæ–¹ä¾¿ä¸‹æ¸¸ï¼‰
  - ä½ ä»¬å½“å‰å†™æ³•å…è®¸é€šè¿‡â€œæ³¨é‡Šåˆ‡æ¢ columnsâ€æ¥å¢åˆ åˆ—ï¼š
    - `df = pd.DataFrame(rows, columns=[...])`
    - `# df = pd.DataFrame(rows, columns=[...])`
  - è‹¥ä¿®æ”¹åˆ—æ•°/åˆ—åï¼šéœ€è¦åŒæ­¥ä¸‹æ¸¸æ¶ˆè´¹æ–¹ï¼ˆæˆ–åœ¨ README/äº¤æ¥æ–‡æ¡£å£°æ˜ç‰ˆæœ¬ï¼‰
- `_build_base_filename()`ï¼šæ–‡ä»¶å‘½åè§„åˆ™å¯æŒ‰éœ€æ±‚å¾®è°ƒï¼ˆæˆªæ–­é•¿åº¦ã€å­—ç¬¦ç™½åå•ç­‰ï¼‰

<details>
<summary><b> ğŸ“„ Checkpoint-03ï¼šrenderer.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/protocol/renderer.py
from __future__ import annotations

import os
import json
import pandas as pd
from datetime import datetime
from typing import List, Dict, Any, Optional

from .schema import EtfDecision, DebateMeta, DebateLog, DecisionAction


class DebateRenderer:
    """
    ã€Layer 4: åè®®æ¸²æŸ“å™¨ã€‘
    å°†ç»“æ„åŒ–å¯¹è±¡æ¸²æŸ“ä¸ºç‰©ç†æ–‡ä»¶ï¼š
    - log.json  (æœºå™¨å¯è¯»ï¼Œå¯è¿½æº¯ï¼Œå¯å›æ”¾)
    - memo.md   (äººç±»å¯è¯»ï¼Œä¾¿äºæ±‡æŠ¥)
    - rebalance.csv (è°ƒä»“æŒ‡ä»¤ï¼Œä¾¿äºä¸‹æ¸¸æ‰§è¡Œ/äº¤æ¥)
    """

    def __init__(self, output_dir: str = "./output_reports"):
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # - ä¿å­˜ output_dir
        # - ç¡®ä¿ç›®å½•å­˜åœ¨ï¼ˆos.makedirsï¼‰
        raise NotImplementedError


    # ---------------------------------------------------------------------
    # Public API
    # ---------------------------------------------------------------------
    def render(
        self,
        mission: str,
        decisions: List[EtfDecision],
        extra_meta: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, str]:
        """
        æ‰§è¡Œæ¸²æŸ“æµç¨‹ï¼Œç”Ÿæˆäº¤ä»˜ä¸‰ä»¶å¥—ã€‚
        extra_meta: ç”± Core ä¼ å…¥çš„ metaï¼ˆæ¯”å¦‚ ref_date / rounds / tool_traceï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # 1) base_filename = self._build_base_filename(mission)
        # 2) ç”Ÿæˆ json/md/csv ä¸‰ä¸ªæ–‡ä»¶å¹¶è¿”å›è·¯å¾„å­—å…¸
        raise NotImplementedError


    def _build_base_filename(self, mission: str) -> str:
        """
        æ–‡ä»¶åç»Ÿä¸€æ„é€ ï¼štimestamp + safe_mission

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€é€‰æ”¹ï¼ˆå±•ç¤ºç›¸å…³ï¼‰ã€‘:
        # - timestamp æ ¼å¼ï¼ˆå¦‚ %Y%m%d_%H%M%Sï¼‰
        # - safe_mission ç™½åå•å­—ç¬¦ä¸æˆªæ–­é•¿åº¦
        raise NotImplementedError


    # ---------------------------------------------------------------------
    # JSON Log (æœºå™¨å¯è¯»)
    # ---------------------------------------------------------------------
    def _save_json_log(
        self,
        mission: str,
        decisions: List[EtfDecision],
        filename: str,
        meta: Optional[Dict[str, Any]],
    ) -> str:
        """
        è½ç›˜ log.jsonï¼ˆæœºå™¨å¯è¯»ï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # 1) meta_obj = self._build_meta(mission, meta)
        # 2) log = DebateLog(timestamp=..., meta=meta_obj, decisions=..., visuals=...)
        # 3) json.dump(log.model_dump(), ensure_ascii=False, indent=2)
        # 4) return path
        raise NotImplementedError


    def _build_meta(self, mission: str, meta: Optional[Dict[str, Any]]) -> DebateMeta:
        """
        å°† Core ä¼ æ¥çš„ extra_metaï¼ˆdictï¼‰è½¬æˆå¼ºç±»å‹ DebateMetaã€‚
        å…¼å®¹ä¸¤ç§è¾“å…¥ï¼š
        - æ‰å¹³ dictï¼š{"ref_date":..., "rounds":..., ...}
        - åŒ…ä¸€å±‚ metaï¼š{"meta": {...}}

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # 1) meta = meta or {}
        # 2) è‹¥ meta åŒ…å« {"meta": {...}}ï¼Œåˆ™å–å†…å±‚ dict
        # 3) æ„é€  DebateMeta(mission=..., ref_date=..., rounds=..., stop_reason=..., tool_trace=..., dossier_meta=..., extras=...)
        raise NotImplementedError


    def _collect_visuals(self, meta_obj: DebateMeta) -> List[str]:
        """
        æ”¶é›† visualsï¼šmeta.extras + tool_trace.visualsï¼ˆå»é‡ä¿åºï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # - ä» meta_obj.extras.get("visuals") å– list
        # - éå† meta_obj.tool_traceï¼Œæ”¶é›†æ¯æ¡çš„ visuals
        # - å»é‡ä¿åºï¼ˆseen set + out listï¼‰
        raise NotImplementedError


    # ---------------------------------------------------------------------
    # Markdown Memo (äººå¯è¯»)
    # ---------------------------------------------------------------------
    def _save_markdown_memo(
        self,
        mission: str,
        decisions: List[EtfDecision],
        filename: str,
        meta: Optional[Dict[str, Any]],
    ) -> str:
        """
        è½ç›˜ memo.mdï¼ˆäººç±»å¯è¯»ï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # 1) meta_obj = self._build_meta(mission, meta)
        # 2) ç”Ÿæˆæ‘˜è¦ï¼ˆref_date/rounds/stop_reason + BUY/REJECT ç»Ÿè®¡ï¼‰
        # 3) ç”Ÿæˆâ€œæ ¸å¿ƒå†³ç­–è¡¨â€ï¼ˆDataFrame.to_markdownï¼‰
        # 4) ç”Ÿæˆâ€œé€æ ‡çš„å†³ç­–è¯´æ˜â€
        # 5) è¿½åŠ  visuals ç•™ç—•
        # 6) å†™å…¥æ–‡ä»¶å¹¶ return path
        #
        # TODOã€é€‰æ”¹ï¼ˆå±•ç¤ºç›¸å…³ï¼‰ã€‘:
        # - è¡¨å¤´å­—æ®µã€æ–‡æ¡ˆé£æ ¼ã€é€æ ‡çš„æ®µè½ç»“æ„
        raise NotImplementedError


    # ---------------------------------------------------------------------
    # Rebalance CSVï¼ˆè°ƒä»“æŒ‡ä»¤ï¼‰
    # ---------------------------------------------------------------------
    def _save_rebalance_csv(
        self,
        mission: str,
        decisions: List[EtfDecision],
        filename: str,
        meta: Optional[Dict[str, Any]],
    ) -> str:
        """
        è½ç›˜ rebalance.csvï¼ˆè°ƒä»“æŒ‡ä»¤ï¼‰

        Args:
            TODO

        Returns:
            TODO
        """
        # TODOã€å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰ã€‘:
        # - é»˜è®¤è¾“å‡ºåˆ—ç¨³å®šï¼ˆä¾‹å¦‚ time/date/code/action/weight/reasonï¼‰
        # - path å†™å…¥ output_dirï¼Œç¼–ç  utf-8-sig
        #
        # TODOã€é€‰æ”¹ï¼ˆå±•ç¤º/äº¤ä»˜ç›¸å…³ï¼‰ã€‘:
        # - å…è®¸é€šè¿‡â€œæ³¨é‡Šåˆ‡æ¢ columnsâ€æ¥å¢åˆ åˆ—ï¼ˆæ•™å­¦å‹å¥½ï¼‰
        #   ä½†è‹¥ä¿®æ”¹åˆ—æ•°/åˆ—åï¼Œéœ€è¦åŒæ­¥ä¸‹æ¸¸æ¶ˆè´¹æ–¹æˆ–åœ¨äº¤æ¥æ–‡æ¡£å£°æ˜ç‰ˆæœ¬
        raise NotImplementedError

```
</details>

#### C) `protocol/__init__.py`

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼šimport ä½“éªŒï¼‰**
- ç›®æ ‡ï¼šæŠŠ `schema.py` çš„æ ¸å¿ƒå¯¹è±¡ä¸ `renderer.py` çš„ `DebateRenderer` **æš´éœ²åˆ° `debate_mas.protocol` é¡¶å±‚**
- å¥½å¤„ï¼š
  - å¤–éƒ¨è°ƒç”¨æ›´å¹²å‡€ï¼š`from debate_mas.protocol import SkillResult, EtfDecision, DebateRenderer`
  - ä»¥åé‡æ„ `schema.py` å†…éƒ¨ç»“æ„æ—¶ï¼Œå¤–éƒ¨ import è·¯å¾„ä¸éœ€è¦è·Ÿç€æ”¹ï¼ˆç¨³å®š APIï¼‰

<details>
<summary><b>ğŸ“„ Checkpoint-03ï¼šprotocol/__init__.py</b></summary>

```py
# src/debate_mas/protocol/__init__.py
"""
Protocol Package Initialization
å°† schema.py ä¸­çš„æ ¸å¿ƒå¯¹è±¡æš´éœ²åˆ° protocol åŒ…çš„é¡¶å±‚ï¼Œ
æ–¹ä¾¿å¤–éƒ¨ä½¿ç”¨ 'from debate_mas.protocol import EtfCandidate' è¿™ç§å†™æ³•ã€‚
"""
#å…·ä½“æš´éœ²çš„å¯¹è±¡åç§°æ ¹æ®schema.pyä¸­å®šä¹‰çš„å…·ä½“å†™
from .schema import (
    SkillResult,
    EtfCandidate,
    EtfRiskReport,
    EtfDecision,
    DecisionAction,
)
from .renderer import DebateRenderer

__all__ = [
    "SkillResult",
    "EtfCandidate",
    "EtfRiskReport",
    "EtfDecision",
    "DecisionAction",
    "DebateRenderer",
]
```
</details>

### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšå°éªŒæ”¶ã€‚

1) åœ¨æ ¹ç›®å½•åˆ›å»ºæ–‡ä»¶ï¼š`tests/test_protocol.py`
   
   è¯·é˜…è¯»ä»¥ä¸‹ä»£ç ï¼ŒæŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_protocol.py</b></summary>

   ```py
    from __future__ import annotations

    import json
    from pathlib import Path
    from typing import Any, Dict

    import pandas as pd

    from debate_mas.protocol.schema import (
        DecisionAction,
        SkillResult,
        DebateLog,
        DebateMeta,
        EtfDecision,  # è¿™é‡Œæ˜¯â€œç¤ºä¾‹ä¸šåŠ¡å¯¹è±¡â€ï¼›å¦‚æœä½ æ¢äº†ä¸šåŠ¡å¯¹è±¡ï¼Œå¯åœ¨æ­¤å¤„æ›¿æ¢ import
    )
    from debate_mas.protocol.renderer import DebateRenderer


    def test_decision_action_enum_is_stable() -> None:
        # è‹¥ä½ ç¡®å®è¦æ”¹ action å€¼ï¼šéœ€è¦åŒæ­¥ Persona/Core/Renderer/ä¸‹æ¸¸æ¶ˆè´¹æ–¹ä¸æµ‹è¯•æ–­è¨€ï¼ˆä¸€èˆ¬ä¸å»ºè®®ï¼‰
        assert {x.value for x in DecisionAction} >= {"BUY", "WATCH", "REJECT"}


    def test_skill_result_contract() -> None:
        ok = SkillResult.ok(data={"x": 1}, insight="hi")
        assert ok.success is True
        assert ok.insight == "hi"
        assert isinstance(ok.visuals, list)
        assert ok.error_msg is None

        bad = SkillResult.fail("boom", data={"debug": True})
        assert bad.success is False
        assert bad.error_msg == "boom"
        assert isinstance(bad.visuals, list)
        assert "boom" in bad.insight


    def test_debate_log_is_json_serializable() -> None:
        log = DebateLog(
            timestamp="2026-01-01T00:00:00",
            meta=DebateMeta(mission="x", rounds=1),
            decisions=[],
            visuals=[],
        )
        payload = log.model_dump()
        json.dumps(payload, ensure_ascii=False)  # must not raise


    def test_renderer_generates_three_artifacts(tmp_path: Path) -> None:
        renderer = DebateRenderer(output_dir=str(tmp_path))

        decisions = [
            EtfDecision(
                symbol="X1",
                action=DecisionAction.BUY,
                weight=0.2,
                final_score=12.3,
                key_reasons=["r1"],
                risk_warnings=["w1"],
            ),
            EtfDecision(
                symbol="X2",
                action=DecisionAction.WATCH,
                weight=0.0,
                final_score=9.9,
                key_reasons=[],
                risk_warnings=[],
            ),
        ]

        extra_meta: Dict[str, Any] = {
            "ref_date": "2025-10-26",
            "rounds": 2,
            "stop_reason": "ok",
            # tool_trace/extras/dossier_meta éƒ½æ˜¯â€œå…è®¸å­˜åœ¨â€çš„æ‰©å±•ä½ï¼Œä¸è¦æ±‚ä¸šåŠ¡å¿…é¡»å†™
            "tool_trace": [{"tool": "dummy", "ok": True, "visuals": ["v1.png"]}],
            "extras": {"visuals": ["v0.png"]},
            "dossier_meta": {"source": "unit-test"},
        }

        paths = renderer.render("unit test mission", decisions, extra_meta=extra_meta)

        for k in ["json", "md", "csv"]:
            assert k in paths
            assert Path(paths[k]).exists(), f"missing artifact: {k}"

        with open(paths["json"], "r", encoding="utf-8") as f:
            j = json.load(f)

        assert isinstance(j, dict)
        assert "timestamp" in j
        assert "meta" in j and isinstance(j["meta"], dict)
        assert "decisions" in j and isinstance(j["decisions"], list)

        # æ³¨æ„ï¼šå¦‚æœä½ çš„ renderer/schema é€‰æ‹©ä¸è¾“å‡ºå…¶ä¸­æŸäº›å­—æ®µï¼Œå¯æ ¹æ®æƒ…å†µåˆ æ”¹è¿™äº›æ–­è¨€
        assert j["meta"].get("mission") == "unit test mission"
        assert j["meta"].get("ref_date") == "2025-10-26"
        assert j["meta"].get("rounds") == 2
        assert j["meta"].get("stop_reason") == "ok"

        # è¿™æ˜¯â€œå»ºè®®é¡¹â€ï¼šå¦‚æœä½ ä¸æ‰“ç®—åš visuals èšåˆï¼Œå¯æŠŠè¿™ä¸€æ®µåˆ æ‰
        if "visuals" in j and isinstance(j["visuals"], list):
            assert "v0.png" in j["visuals"]
            assert "v1.png" in j["visuals"]

        md_text = Path(paths["md"]).read_text(encoding="utf-8")
        assert len(md_text.strip()) > 0

        # ä¸å¼ºç»‘åˆ—åï¼šå› ä¸ºåˆ—é›†åˆç”±ä¸šåŠ¡å†³å®šï¼ˆdate/code/weight æˆ– time/date/code/action/... éƒ½å…è®¸ï¼‰
        df = pd.read_csv(paths["csv"])
        assert len(df) == len(decisions)

        # ============================================================
        # B) é€‰æ”¹ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰â€” ä½ å¯ä»¥æ ¹æ®ä¸šåŠ¡è‡ªå®šä¹‰â€œæ›´ä¸¥æ ¼çš„æ–­è¨€â€
        # ============================================================
        # å¦‚æœä½ ä»¬å¸Œæœ›æŠŠ CSV å½“æˆâ€œè°ƒä»“æŒ‡ä»¤å¥‘çº¦â€ï¼Œå¯ä»¥åœ¨è¿™é‡Œå›ºå®šåˆ—é›†åˆã€‚
        #
        # ç¤ºä¾‹ 1ï¼šETF è°ƒä»“ç‰ˆï¼ˆæ›´ä¸¥æ ¼ï¼Œä½†ä¼šé™åˆ¶ä¸šåŠ¡è‡ªç”±ï¼‰
        # required_cols = ["time", "date", "code", "action", "weight", "reason"]
        # for c in required_cols:
        #     assert c in df.columns, f"csv missing column: {c}"
        #
        # ç¤ºä¾‹ 2ï¼šæç®€é‡‘èå†³ç­–ç‰ˆï¼ˆåªè¦ date/code/weightï¼‰
        # required_cols = ["date", "code", "weight"]
        # for c in required_cols:
        #     assert c in df.columns, f"csv missing column: {c}"


   ```
   </details>

> è¯´æ˜ï¼šæœ¬å…³æµ‹è¯•é»˜è®¤**ä¸å¼ºç»‘ CSV åˆ—å**ã€‚  
> å¦‚æœä½ å¸Œæœ›æŠŠ CSV å½“æˆâ€œäº¤ä»˜å¥‘çº¦â€ï¼Œåªéœ€è¦åœ¨æµ‹è¯•æ–‡ä»¶åº•éƒ¨ **é€‰æ”¹åŒº(B)** æ‰“å¼€å¹¶å¡«å†™ä½ çš„ `required_cols`ã€‚


2) è¿è¡Œæµ‹è¯•

æµ‹è¯•å‰ç¡®è®¤`test_protocol.py`æ˜¯ä¸è‡ªå·±å†™çš„ä»»åŠ¡èƒŒæ™¯è¾“å‡ºå¯¹åº”

```bash
uv run pytest -q tests/test_protocol.py
```

### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰  
  - `4 passed in ...s`  
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`AssertionError`ã€`JSONDecodeError`
  
- ä½ é€šè¿‡çš„æ˜¯â€œæ¡†æ¶å¿…æœ‰â€çš„ 4 ä¸ªéªŒæ”¶ç‚¹ï¼š

  1) **è·¨å±‚æšä¸¾ç¨³å®š**
     - `DecisionAction` è‡³å°‘åŒ…å« `BUY / WATCH / REJECT`
     - è‹¥ä½ éœ€è¦è‡ªå®šä¹‰æšä¸¾å€¼ï¼Œè¯·åŒæ­¥ä¿®æ”¹æµ‹è¯•ä¸­çš„æ–­è¨€é›†åˆï¼ˆå±äºä¸šåŠ¡é€‰æ”¹ï¼‰

  2) **Skills ç»Ÿä¸€è¿”å›åè®®å¯ç”¨**
     - `SkillResult.ok()` ä¸ `SkillResult.fail()` å¯ç”¨
     - å­—æ®µç¨³å®šå­˜åœ¨ï¼š`success / data / insight / visuals / error_msg`

  3) **äº¤ä»˜åè®®å¯åºåˆ—åŒ–**
     - `DebateLog.model_dump()` çš„ç»“æœèƒ½è¢« `json.dumps()` åºåˆ—åŒ–
     - è¯´æ˜åè®®ç»“æ„æ˜¯â€œæœºå™¨å¯è¯» + å¯è½ç›˜â€çš„

  4) **Renderer èƒ½è½ç›˜ä¸‰ä»¶å¥—ï¼ˆä¸å¼ºç»‘ä¸šåŠ¡åˆ—ï¼‰**
     - `DebateRenderer.render()` è¿”å› `{"json": ..., "md": ..., "csv": ...}`
     - ä¸‰ä¸ªæ–‡ä»¶è·¯å¾„éƒ½å­˜åœ¨ä¸”å¯è¯»å–
     - `log.json` è‡³å°‘åŒ…å«ï¼š`timestamp / meta / decisions(list)`
     - `memo.md` éç©ºå³å¯ï¼ˆæ–‡æ¡ˆç»“æ„å…è®¸ä¸šåŠ¡è‡ªå®šä¹‰ï¼‰
     - `rebalance.csv` èƒ½è¢« `pandas.read_csv` è¯»å…¥ï¼Œä¸”è¡Œæ•°ä¸ `decisions` å¯¹é½  

    
- å¦‚æœå¤±è´¥ï¼Œä½ èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°æ˜¯å“ªä¸€ç±»é—®é¢˜
  
  <details>
  <summary><b>å¸¸è§å¤±è´¥ç‚¹</b></summary>

  - **åè®®ç¼ºå­—æ®µ / å†™é”™å­—æ®µå**  
    - å¸¸è§æŠ¥é”™ï¼š`ValidationError` æˆ– `KeyError` æˆ–æ–­è¨€æç¤ºç¼º key  
    - å»æ£€æŸ¥ï¼š`SkillResult / DebateMeta / DebateLog` çš„å­—æ®µæ˜¯å¦ä¸ TODO Map ä¸€è‡´

  - **ok/fail æ²¡æŒ‰â€œæˆåŠŸ/å¤±è´¥â€è¯­ä¹‰å®ç°**  
    - å¸¸è§æŠ¥é”™ï¼š`assert ok.success is True`ã€`assert bad.success is False` ç­‰  
    - å»æ£€æŸ¥ï¼š`ok()` æ˜¯å¦ `success=True, error_msg=None`ï¼›`fail()` æ˜¯å¦ `success=False, error_msg=...`

  - **Renderer æ²¡ç”Ÿæˆä¸‰ä»¶å¥—æˆ–è·¯å¾„ä¸å¯¹**  
    - å¸¸è§æŠ¥é”™ï¼š`missing artifact: json/md/csv`  
    - å»æ£€æŸ¥ï¼š`render()` æ˜¯å¦çœŸçš„è°ƒç”¨ `_save_json_log/_save_markdown_memo/_save_rebalance_csv` å¹¶è¿”å› dict

  - **log.json ä¸å¯è§£ææˆ–ä¸ç¬¦åˆæœ€å°åè®®**  
    - å¸¸è§æŠ¥é”™ï¼š`json.JSONDecodeError` æˆ– `assert "meta" in j`  
    - å»æ£€æŸ¥ï¼š`_save_json_log()` æ˜¯å¦ç”¨ `DebateLog(...).model_dump()`ï¼Œå¹¶æ­£ç¡® `json.dump`

  - **ä½ è‡ªå®šä¹‰äº† CSV åˆ—å¯¼è‡´æµ‹è¯•å¤±è´¥**  
    - é»˜è®¤ä¸ä¼šå‘ç”Ÿï¼ˆæœ¬å…³æµ‹è¯•ä¸å¼ºç»‘åˆ—åï¼‰  
    - è‹¥ä½ è‡ªå·±æ‰“å¼€äº†æµ‹è¯•é‡Œâ€œé€‰æ”¹åŒº(B)â€çš„ä¸¥æ ¼åˆ—æ–­è¨€ï¼Œè¯·æ ¹æ®ä½ çš„ä¸šåŠ¡åˆ—é›†åˆåŒæ­¥ä¿®æ”¹ `required_cols`

  </details>


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> **å…³å¡-03** çš„ç›®æ ‡æ˜¯ï¼šæŠŠâ€œå¤šè§’è‰² + skillsâ€çš„äº§ç‰©ï¼Œç»Ÿä¸€è½åˆ° **å¼ºç±»å‹åè®®**ï¼ˆschemaï¼‰ä¸ **å¯äº¤ä»˜æ–‡ä»¶**ï¼ˆrendererï¼‰é‡Œã€‚è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡æ—¶ï¼Œä½ ä¸éœ€è¦é‡å†™ Debate MASï¼Œåªè¦æŠŠâ€œä¸šåŠ¡å¯¹è±¡â€å’Œâ€œå±•ç¤º/è½ç›˜æ ¼å¼â€æ¢æ‰ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

è¿™äº›å†…å®¹æ˜¯â€œè·¨ Persona / Skills / Core / Rendererâ€çš„ç¡¬æ¥å£ï¼šå»ºè®®å­—æ®µåã€è¯­ä¹‰ä¿æŒç¨³å®šã€‚

- **ç»Ÿä¸€å†³ç­–æšä¸¾ï¼ˆè·¨å±‚å¯¹é½ï¼‰**
  - `DecisionAction`ï¼š`BUY / WATCH / REJECT`
  - ä½œç”¨ï¼šè®© Persona çš„è¯æœ¯ã€Skills çš„äº§ç‰©ã€Core çš„åˆå¹¶ã€Renderer çš„å±•ç¤ºå…±ç”¨åŒä¸€å¥— action è¯­ä¹‰

- **Skills ç»Ÿä¸€è¿”å›ç»“æ„ï¼ˆSkills -> Coreï¼‰**
  - `SkillResult(success/data/insight/visuals/error_msg)` + `ok()/fail()`
  - ä½œç”¨ï¼šè®© Core/Graph ä¸ç”¨ä¸ºæ¯ä¸ª skill å†™ç‰¹æ®Šåˆ†æ”¯ï¼Œå¤±è´¥ä¹Ÿèƒ½è¢«å®¡è®¡ä¸è½ç›˜

- **æœ€å°å¯å›æ”¾äº¤ä»˜åè®®ï¼ˆCore -> Renderer -> æ–‡ä»¶ï¼‰**
  - `ToolTraceEntry`ï¼šå·¥å…·ç•™ç—•æœ€å°ç»“æ„ï¼ˆæ”¯æŒå®¡è®¡/å¤ç›˜ï¼‰
  - `DebateMeta / DebateLog`ï¼šlog.json çš„â€œæœ€å°æœºå™¨å¯è¯»éª¨æ¶â€

- **Renderer çš„â€œç”Ÿæˆä¸‰ä»¶å¥—â€èŒè´£**
  - `render()` ä¸€æ¬¡æ€§ç”Ÿæˆï¼š`log.json / memo.md / rebalance.csv`
  - `_build_meta()` å¿…é¡»å…¼å®¹ï¼šæ‰å¹³ dict å’Œ `{"meta": {...}}` ä¸¤ç§ä¼ å‚å½¢æ€
  - `_save_json_log()` å¿…é¡»ä¿è¯å¯ JSON åºåˆ—åŒ–è½ç›˜

<details>
<summary><b>è¿ç§»æ—¶ï¼šå“ªäº›å±äºâ€œæ¡†æ¶é€šç”¨åè®®â€ï¼Œå»ºè®®ä¸æ”¹</b></summary>

- DecisionActionï¼ˆè·¨å±‚åŠ¨ä½œæšä¸¾ï¼‰
- SkillResultï¼ˆskills çš„ç»Ÿä¸€è¿”å›ç»“æ„ + ok/fail å·¥å‚æ–¹æ³•ï¼‰
- ToolTraceEntryï¼ˆå·¥å…·ç•™ç—•æœ€å°å­—æ®µï¼štool/args/ok/insight/error_msg/visualsï¼‰
- DebateMeta / DebateLogï¼ˆlog.json çš„æœ€å°éª¨æ¶ï¼štimestamp/meta/decisions/visualsï¼‰
- DebateRenderer.render()ï¼ˆä¸‰ä»¶å¥—è¾“å‡ºï¼šjson/md/csvï¼‰
- _build_meta() çš„â€œå…¼å®¹ä¸¤ç§è¾“å…¥â€èƒ½åŠ›ï¼ˆé¿å… Core ä¼ å‚å˜åŠ¨å¯¼è‡´æ–­è£‚ï¼‰

</details>


**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢**

> è¿™éƒ¨åˆ†å±äºâ€œä½ ä»¬å½“å‰æ˜¯ ETF çš„ç¤ºä¾‹ä¸šåŠ¡â€ï¼Œè¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶å¯ä»¥æ•´ä½“æ›¿æ¢ï¼Œä½†å»ºè®®ä¿æŒâ€œå¼ºç±»å‹ + å¯æ ¡éªŒâ€çš„æ€è·¯ã€‚

- ä¸šåŠ¡å¯¹è±¡ï¼ˆç¤ºä¾‹ï¼šETFï¼‰
  - `EtfCandidate / EtfRiskReport / EtfDecision`
  - è¿ç§»æ–¹å¼ï¼šæ•´ä½“æ›¿æ¢æˆä½ çš„ä¸šåŠ¡å¯¹è±¡ï¼Œä¾‹å¦‚ï¼š
    - åˆåŒå®¡é˜…ï¼šClauseIssue / ClauseChange / ContractDecision
    - æ–¹æ¡ˆè¯„å®¡ï¼šProposal / ReviewRisk / ReviewDecision
    - å®è§‚å†³ç­–ï¼šMacroSignal / RiskState / AllocationDecision
  
  <details>
  <summary><b>ç¤ºä¾‹ï¼šæŠŠ EtfDecision æ¢æˆâ€œèµ„äº§é…ç½®å†³ç­–â€å¯¹è±¡ï¼ˆä¸šåŠ¡æ›¿æ¢ï¼‰</b></summary>

  ```py
  # ç¤ºä¾‹ï¼šAllocationDecisionï¼ˆå¯æ›¿æ¢ EtfDecisionï¼‰
    class AllocationDecision(BaseModel):
        asset: str
        action: DecisionAction
        target_weight: float = Field(0.0, ge=0.0, le=1.0)
        confidence: float = 0.0
        reasons: List[str] = Field(default_factory=list)
        risk_notes: List[str] = Field(default_factory=list)
  ```
  </details>

- å±•ç¤ºå±‚ä¸äº¤ä»˜åå¥½ï¼ˆå…è®¸å¼ºè‡ªå®šä¹‰ï¼‰
  - `memo.md` çš„ç»“æ„ã€è¡¨å¤´ã€æ–‡æ¡ˆï¼šå®Œå…¨å¯ä»¥è‡ªå®šä¹‰
  - `rebalance.csv` çš„åˆ—é›†åˆï¼šå®Œå…¨å¯ä»¥è‡ªå®šä¹‰
    - ä½ ä»¬å½“å‰å…è®¸é€šè¿‡â€œæ³¨é‡Šåˆ‡æ¢ columnsâ€æ¥å¢åˆ åˆ—
    - ä½†è¦è®°ä½ï¼šæ”¹åˆ—å/åˆ—æ•° = æ”¹äº¤ä»˜å¥‘çº¦ï¼Œéœ€è¦åŒæ­¥ï¼š
      - ä¸‹æ¸¸æ¶ˆè´¹æ–¹ï¼ˆæ‰§è¡Œå™¨/å›æµ‹å™¨/å¯è§†åŒ–å·¥å…·ï¼‰
      - æˆ–åœ¨ README/äº¤æ¥æ–‡æ¡£é‡Œå£°æ˜ç‰ˆæœ¬

  <details>
  <summary><b>CSV åˆ—è‡ªå®šä¹‰æç¤ºï¼ˆæŠŠå®ƒå½“ä½œâ€œäº¤ä»˜å¥‘çº¦â€ç®¡ç†ï¼‰</b></summary>

  - é»˜è®¤åˆ—ï¼ˆç¤ºä¾‹ï¼‰ï¼štime/date/code/action/weight/reason
  - å…è®¸è‡ªå®šä¹‰ä¸ºæ›´ç®€åˆ—ï¼ˆç¤ºä¾‹ï¼‰ï¼šdate/code/weight
  - ä¸€æ—¦è‡ªå®šä¹‰åˆ—é›†åˆï¼š
    1) åŒæ­¥ä¿®æ”¹ä¸‹æ¸¸è¯»å–é€»è¾‘
    2) æˆ–åœ¨æ–‡æ¡£ä¸­å†™æ¸…æ¥šåˆ—ç‰ˆæœ¬ï¼ˆv1/v2ï¼‰
    3) å¦‚éœ€æ›´ä¸¥æ ¼éªŒæ”¶ï¼Œåœ¨ pytest çš„â€œé€‰æ”¹åŒº(B)â€å›ºå®š required_cols

  </details>

**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**

- **ä¸åŠ¨**ï¼š`DecisionAction / SkillResult / DebateLogéª¨æ¶ / Rendererä¸‰ä»¶å¥— + _build_metaå…¼å®¹`
- **å¯æ¢**ï¼šä¸šåŠ¡å¯¹è±¡ï¼ˆ*Decision/*Candidate/*Riskï¼‰ã€memo æ–‡æ¡ˆç»“æ„ã€CSV åˆ—é›†åˆä¸å‘½åè§„åˆ™
- **æµ‹è¯•ç­–ç•¥**ï¼šå…³å¡æµ‹è¯•é»˜è®¤â€œå®½æ¾åªéªŒæ¡†æ¶â€ï¼›ä¸šåŠ¡ä»“åº“å†åŠ â€œä¸¥æ ¼å¥‘çº¦æµ‹è¯•â€

</details>

---

## å…³å¡-04ï½œè¯æ®æ¡ˆå· Loaderï¼šfolder â†’ dossier

<details>
<summary><b>Checkpoint 04 â€” è¯æ®æ¡ˆå· Loader ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³èšç„¦ **â€œè¯»å–æŒ‡å®šè·¯å¾„çš„æ¡ˆå·â€**ï¼šæŠŠä¸€ä¸ªæ–‡ä»¶å¤¹é‡Œçš„ CSV/XLSX/TXT/MD/PDF/DOCX ç­‰ææ–™ï¼Œç»Ÿä¸€è£…è¿› `Dossier`ã€‚  
> 
> **ä¸æ•™ SQL / ClickHouse**ï¼ˆæ•°æ®åº“æ¨¡å¼ä½ ä»¬å·²æœ‰å®ç°ï¼Œç»ƒä¹ è€…å¯è‡ªè¡Œé˜…è¯»æºç ï¼‰ã€‚  
>
> ç›®æ ‡æ˜¯æŠŠ Loader çš„â€œè¾“å…¥/è¾“å‡ºå½¢çŠ¶â€å›ºå®šæˆ **æœ€å°å¥‘çº¦**ï¼Œè®©åé¢çš„ Core/Graph/Agents éƒ½åªä¾èµ– Dossierï¼Œè€Œä¸æ˜¯ä¾èµ–æŸä¸ªä¸šåŠ¡çš„æ•°æ®æºã€‚


### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- å®šä¹‰å¹¶è·‘é€š **è¯æ®å…¥å£** çš„æœ€å°é—­ç¯ï¼š`folder_path â†’ Dossier`  
- å»ºç«‹â€œç»Ÿä¸€æ¡ˆå·â€è§†è§’ï¼šè®© Core/Agents **åªè¯» Dossier**ï¼Œä¸ç›´æ¥ä¾èµ–æ–‡ä»¶æ ¼å¼æˆ–æ•°æ®æº  
- æŠŠæ¡ˆå·åšæˆå¯å®¡è®¡ã€å¯å¤ç›˜çš„ç»“æ„ï¼š
  - è¡¨æ ¼è¯æ®ï¼š`structured_data[name] = DataFrame`  
  - æ–‡æœ¬è¯æ®ï¼š`unstructured_text[]`  
  - å…ƒä¿¡æ¯ç•™ç—•ï¼š`meta / tables_meta / texts_meta`  
- æ”¯æŒâ€œåˆ«åç³»ç»Ÿâ€ï¼ˆä¸ºè¿ç§»ä¸å¤šç‰ˆæœ¬æ•°æ®åšå‡†å¤‡ï¼‰ï¼š
  - æ–‡ä»¶å/è¡¨åå¯æ˜ å°„åˆ° canonical åç§°ï¼Œé¿å…æ•°æ®ç‰ˆæœ¬å‘½åä¸ä¸€è‡´å¯¼è‡´ KeyError


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ï¼š
  - `src/debate_mas/loader/dossier.py`
  - `src/debate_mas/loader/dual_mode_loader.py`
- ä¸æ”¹ graphã€engineã€skills çš„é€»è¾‘ï¼Œä¸å¼•å…¥æ–°ä¾èµ–    
- ç›®æ ‡ä¸æ˜¯â€œæ”¯æŒæ›´å¤šæ•°æ®æºâ€ï¼Œè€Œæ˜¯è®© **æ¡ˆå·å…¥å£ç¨³å®šã€ç¼ºä¾èµ–ä¸å´©æºƒã€è¯æ®å¯å†»ç»“å¯å®¡è®¡**
  - å¯¹å¯é€‰ä¾èµ–ï¼ˆ`pypdf/docx`ï¼‰å¿…é¡»åšåˆ°ï¼š**æ²¡è£…ä¹Ÿèƒ½è¿è¡Œï¼Œåªè·³è¿‡å¯¹åº”æ ¼å¼**

### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

**å¿…çœ‹**
- `src/debate_mas/dossier/dossier.py`ï¼šç»Ÿä¸€æ¡ˆå·ç»“æ„ï¼ˆDossierï¼‰
- `src/debate_mas/dossier/dual_mode_loader.py`ï¼šæœ¬åœ°æ–‡ä»¶å¤¹åŠ è½½ï¼ˆload_from_folderï¼‰
- `src/debate_mas/core/state.py`ï¼šåªè¦èƒ½æä¾› `dossier.frozen_view()`ï¼ŒCore/Agent å°±èƒ½é€è§†è¯æ®

#### A) `dossier.py`ï¼ˆæ¡ˆå·å¯¹è±¡ï¼‰

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `Dossier`ï¼šæœ€å°å­—æ®µå¿…é¡»ç¨³å®šå­˜åœ¨
  - `mission / structured_data / unstructured_text / meta`
  - `tables_meta / texts_meta`ï¼ˆç”¨äºå¯å®¡è®¡ä¸å¯å¤ç›˜ï¼‰
- `add_table()`ï¼šå†™å…¥ç»“æ„åŒ–è¡¨ + è®°å½• tables_meta
- `add_text()`ï¼šå†™å…¥æ–‡æœ¬è¯æ® + è®°å½• texts_meta
- `frozen_view()`ï¼šè¾“å‡ºåªè¯»æ‘˜è¦ï¼ˆä¸ç»™ Agent ç›´æ¥ DataFrameï¼‰
- `get_table()`ï¼šæ”¯æŒ alias/canonical æŸ¥è¡¨
- `list_tables()`ï¼šæ–¹ä¾¿è°ƒè¯•

**é€‰æ”¹ï¼ˆä¸šåŠ¡åå¥½ï¼‰**
- `table_aliases` / `_alias_to_canonical`ï¼šåˆ«åç³»ç»Ÿå¯æ‰©å±•
- `summary()`ï¼šæ‰“å°æ¡ˆå·æ¦‚è§ˆï¼ˆä¾¿äºæ•™å­¦æ¼”ç¤ºï¼‰

<details>
<summary><b> ğŸ“„ Checkpoint-04ï¼šdossier.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/dossier/dossier.py
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional

import pandas as pd


@dataclass
class Dossier:
    """
    ã€ç¬¬ä¸€å±‚ï¼šç»Ÿä¸€æ¡ˆå·ã€‘(The Unified Dossier)

    è®¾è®¡ç›®æ ‡ï¼š
    - Core/Agents ä¸ç›´æ¥è¯»æ–‡ä»¶ã€ä¸ç›´æ¥è¿æ•°æ®åº“
    - åªâ€œé€è§†â€ Dossierï¼šç»“æ„åŒ–è¡¨ + éç»“æ„åŒ–æ–‡æœ¬ + å…ƒä¿¡æ¯ç•™ç—•
    """

    # ============================================================
    # REQã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘æœ€å°å­—æ®µå¿…é¡»ç¨³å®šå­˜åœ¨
    # ============================================================
    mission: str
    structured_data: Dict[str, pd.DataFrame] = field(default_factory=dict)
    unstructured_text: List[str] = field(default_factory=list)
    meta: Dict[str, Any] = field(default_factory=dict)

    # REQã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘å¯å®¡è®¡/å¯å¤ç›˜ï¼šè®°å½•æ¯å¼ è¡¨/æ¯æ®µæ–‡æœ¬çš„å…ƒä¿¡æ¯
    tables_meta: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    texts_meta: List[Dict[str, Any]] = field(default_factory=list)

    # OPTã€é€‰æ”¹-å¯è¿ç§»å¢å¼ºã€‘åˆ«åç³»ç»Ÿï¼ˆç”¨äºå¤šç‰ˆæœ¬æ•°æ®å‘½åä¸ä¸€è‡´ï¼‰
    table_aliases: Dict[str, List[str]] = field(default_factory=dict)
    _alias_to_canonical: Dict[str, str] = field(default_factory=dict, init=False, repr=False)

    # ---------------------------
    # Alias systemï¼ˆOPTï¼‰
    # ---------------------------
    def register_table_aliases(self, mapping: Dict[str, Any]) -> None:
        """
        æ³¨å†Œåˆ«åæ˜ å°„ï¼ˆä¸¤ç§æ ¼å¼éƒ½æ”¯æŒï¼‰ï¼š
        1) {"etf_basic": ["sampled_etf_basic", "basic"], ...}
        2) {"sampled_etf_basic": "etf_basic", ...}

        Args:
            mapping: åˆ«åæ˜ å°„å­—å…¸

        Returns:
            None
        """
        # TODOã€é€‰æ”¹-å¯è¿ç§»å¢å¼ºã€‘
        # - æ”¯æŒä¸¤ç§ mapping å½¢æ€
        # - å†™å…¥ table_aliasesï¼ˆcanonical -> aliasesï¼‰
        # - å†™å…¥ _alias_to_canonicalï¼ˆalias -> canonicalï¼‰
        raise NotImplementedError

    def resolve_table_name(self, name: str) -> Optional[str]:
        """
        æŠŠä»»æ„åå­—è§£ææˆçœŸå®å­˜åœ¨çš„è¡¨åï¼š
        - å…ˆæŸ¥ structured_data æ˜¯å¦ç›´æ¥å‘½ä¸­
        - å†æŸ¥ alias -> canonical
        - å†å…œåº•å¤„ç† xxx.csv / xxx.xlsx / xxx.xls ç­‰åç¼€

        Args:
            name: ç”¨æˆ·è¾“å…¥çš„è¡¨å/åˆ«å/æ–‡ä»¶å

        Returns:
            canonical_name or None
        """
        # TODOã€é€‰æ”¹-å¯è¿ç§»å¢å¼ºã€‘
        raise NotImplementedError

    # ---------------------------
    # Core methodsï¼ˆREQï¼‰
    # ---------------------------
    def add_table(
        self,
        name: str,
        df: pd.DataFrame,
        description: str = "",
        source: str = "unknown",
        extra: Optional[Dict[str, Any]] = None,
        aliases: Optional[List[str]] = None,
    ) -> None:
        """
        æ·»åŠ è¡¨æ ¼è¯æ®ï¼ˆç»“æ„åŒ–ï¼‰

        Args:
            name: å†™å…¥ structured_data çš„è¡¨åï¼ˆå»ºè®® canonicalï¼‰
            df: DataFrame
            description: è¡¨æè¿°ï¼ˆå¯ç©ºï¼‰
            source: æ¥æºï¼ˆæ–‡ä»¶è·¯å¾„/æ•°æ®åº“/æ¥å£ç­‰ï¼‰
            extra: é¢å¤–å…ƒä¿¡æ¯ï¼ˆå¯ç©ºï¼‰
            aliases: åˆ«ååˆ—è¡¨ï¼ˆå¯ç©ºï¼‰

        Returns:
            None
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # 1) structured_data[name] = df
        # 2) tables_meta[name] è‡³å°‘åŒ…å«ï¼š
        #    - name/source/description
        #    - rows/cols/columnsï¼ˆåˆ—åå»ºè®® stripï¼‰
        #    - added_atï¼ˆæ—¶é—´æˆ³ï¼Œisoformatï¼‰
        # 3) extra åˆå¹¶åˆ° tables_meta[name]
        # 4) è‹¥ aliases å­˜åœ¨ï¼šregister_table_aliases({name: aliases})
        raise NotImplementedError

    def add_text(
        self,
        content: str,
        source: str = "Unknown",
        extra: Optional[Dict[str, Any]] = None,
    ) -> None:
        """
        æ·»åŠ æ–‡æœ¬è¯æ®ï¼ˆéç»“æ„åŒ–ï¼‰

        Args:
            content: æ–‡æœ¬å†…å®¹
            source: æ¥æºæ ‡è¯†ï¼ˆæ–‡ä»¶å/URL/æ•°æ®åº“ç­‰ï¼‰
            extra: é¢å¤–å…ƒä¿¡æ¯ï¼ˆå¯ç©ºï¼‰

        Returns:
            None
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # 1) unstructured_text.append(å¸¦æ¥æºçš„æ ¼å¼åŒ–æ–‡æœ¬ï¼Œæˆ–åŸæ–‡ä¹Ÿå¯)
        # 2) texts_meta.append è‡³å°‘åŒ…å«ï¼š
        #    - source/content_length/added_at
        # 3) extra åˆå¹¶åˆ° texts_meta[i]
        raise NotImplementedError

    def frozen_view(self) -> Dict[str, Any]:
        """
        è¾“å‡ºåªè¯»æ‘˜è¦ï¼ˆç»™ Core/Agent é€è§†æ¡ˆå·ï¼Œä¸æš´éœ²åŸå§‹ DataFrameï¼‰

        Returns:
            dict with:
              - mission
              - metaï¼ˆæµ…æ‹·è´ï¼‰
              - tables: [{name, source, rows, cols, columns[:20], description}, ...]
              - texts:  [{idx, source, length, added_at}, ...]
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # - columns å»ºè®®åªå–å‰ 20ï¼ˆé˜²çˆ†ï¼‰
        # - ä¸è¿”å› DataFrame æœ¬ä½“
        raise NotImplementedError

    def get_table(self, name: str) -> Optional[pd.DataFrame]:
        """
        æŒ‰åå­—æˆ–åˆ«åå–ç»“æ„åŒ–è¡¨æ ¼ï¼›ä¸å­˜åœ¨è¿”å› None

        Args:
            name: è¡¨åæˆ–åˆ«å

        Returns:
            DataFrame or None
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # - è‹¥å®ç°äº† aliasï¼šå…ˆ resolve_table_name å†å–
        # - å¦åˆ™ç›´æ¥ structured_data.get(name)
        raise NotImplementedError

    def list_tables(self) -> List[str]:
        """
        è¿”å›æ¡ˆå·é‡Œæ‰€æœ‰è¡¨åï¼Œæ–¹ä¾¿è°ƒè¯•

        Returns:
            list[str]
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        raise NotImplementedError

    @classmethod
    def create_empty(cls, mission: str) -> "Dossier":
        """
        å¿«é€Ÿåˆ›å»ºä¸€ä¸ªç©ºæ¡ˆå·

        Args:
            mission: ä»»åŠ¡æ–‡æœ¬

        Returns:
            Dossier
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # - è¿”å› Dossier(mission=mission)
        raise NotImplementedError
```

</details>

#### B) `dual_mode_loader.py`ï¼ˆfolder â†’ dossierï¼‰

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `load_from_folder(mission, folder_path, ...) -> Dossier`
  - è·¯å¾„ä¸å­˜åœ¨ï¼šä¸æŠ›å¼‚å¸¸ï¼Œè¿”å›ç©º dossierï¼ˆmeta é‡Œä¿ç•™ source_pathï¼‰
  - æ”¯æŒ `.csv/.xlsx/.txt/.md` è‡³å°‘å››ç±»æ–‡ä»¶
  - å¯¹ `.pdf/.docx`ï¼šä¾èµ–ç¼ºå¤±åˆ™è·³è¿‡ï¼Œä¸å´©æºƒ
- `table_map.json`ï¼ˆå¯é€‰ï¼‰ï¼šè‡ªåŠ¨è¯»å–å¹¶æ³¨å†Œåˆ«åæ˜ å°„
- `file_map`ï¼ˆå¯é€‰ï¼‰ï¼šç²¾ç¡®æ–‡ä»¶åæ˜ å°„è¡¨åï¼ˆæ•™å­¦å‹å¥½ï¼‰

**é€‰æ”¹ï¼ˆå±•ç¤º/ä¸šåŠ¡åå¥½ï¼‰**
- DEFAULT_TABLE_NAME_MAPï¼šä½ ä»¬é¡¹ç›®è‡ªå¸¦çš„é»˜è®¤æ˜ å°„å¯ä¿ç•™ï¼Œä½†æµ‹è¯•ä¸å¼ºç»‘
- Excel sheet çš„å‘½åè§„åˆ™ï¼š`base` æˆ– `base_sheet`ï¼ˆä½ å¯ä»¥è‡ªå®šä¹‰ï¼‰

<details>
<summary><b> ğŸ“„ Checkpoint-04ï¼šdual_mode_loader.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/dossier/dual_mode_loader.py
from __future__ import annotations

import json
import os
from typing import Any, Dict, Optional, List

import pandas as pd

from .dossier import Dossier

# --- å¯é€‰ä¾èµ–ï¼šæ²¡è£…ä¹Ÿä¸å´© ---
try:
    from pypdf import PdfReader
except ImportError:
    PdfReader = None

try:
    from docx import Document
except ImportError:
    Document = None


class DualModeLoader:
    """
    ã€åŒæ¨¡åŠ è½½å™¨ã€‘(Dual Mode Loader)

    æœ¬å…³åªè¦æ±‚å®ç°ï¼šload_from_folderï¼ˆæœ¬åœ°æ–‡ä»¶å¤¹æ¨¡å¼ï¼‰
    ClickHouse/SQL æ¨¡å¼ï¼šFUTUREï¼ˆå¯ä¿ç•™ä»£ç ï¼Œä½†ä¸åœ¨æœ¬å…³æ•™å­¦ä¸æµ‹è¯•èŒƒå›´ï¼‰
    """

    # TODOã€é€‰æ”¹-ä¸šåŠ¡åå¥½ã€‘ä½ ä»¬é¡¹ç›®è‡ªå¸¦é»˜è®¤æ˜ å°„å¯ä¿ç•™ï¼›æµ‹è¯•ä¸å¼ºç»‘
    DEFAULT_TABLE_NAME_MAP: Dict[str, str] = {
        # "sampled_etf_basic": "etf_basic",
        # "govcn_2025": "govcn",
        # ...
    }

    def __init__(self) -> None:
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘å…è®¸ä¸ºç©º
        pass

    def load_from_folder(
        self,
        mission: str,
        folder_path: str,
        file_map: Optional[Dict[str, str]] = None,
        table_name_map: Optional[Dict[str, str]] = None,
        table_name_map_path: Optional[str] = None,
        auto_load_table_map_json: bool = True,
    ) -> Dossier:
        """
        æ‰«ææŒ‡å®šæ–‡ä»¶å¤¹å¹¶åŠ è½½ææ–™åˆ° Dossierã€‚

        REQ æ”¯æŒæ ¼å¼ï¼ˆè‡³å°‘ï¼‰ï¼š
        - .csv  -> table
        - .xlsx -> multi-sheet -> tables
        - .txt/.md -> text

        OPT æ”¯æŒæ ¼å¼ï¼š
        - .docx/.pdf -> textï¼ˆå¯é€‰ä¾èµ–ï¼Œç¼ºå¤±åˆ™è·³è¿‡ï¼‰

        Args:
            mission: ä»»åŠ¡æ–‡æœ¬
            folder_path: æœ¬åœ°èµ„æ–™æ–‡ä»¶å¤¹è·¯å¾„
            file_map: ç²¾ç¡®æ–‡ä»¶å -> è¡¨å æ˜ å°„ï¼ˆæ•™å­¦å‹å¥½ï¼ŒOPTï¼‰
            table_name_map: åˆ«å/è¡¨åæ˜ å°„ï¼ˆruntime è¦†ç›–ï¼ŒOPTï¼‰
            table_name_map_path: table_map.json æŒ‡å®šè·¯å¾„ï¼ˆOPTï¼‰
            auto_load_table_map_json: æ˜¯å¦è‡ªåŠ¨å°è¯•è¯»å– folder/table_map.jsonï¼ˆOPTï¼‰

        Returns:
            dossier: Dossierï¼ˆå³ä½¿è·¯å¾„ä¸å­˜åœ¨ï¼Œä¹Ÿè¿”å›â€œç©º dossierâ€ï¼Œä¸æŠ›å¼‚å¸¸ï¼‰
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘1) å»ºç©º dossier + ç•™ç—• source_path
        # dossier = Dossier.create_empty(mission)
        # dossier.meta["source_path"] = folder_path

        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘2) è·¯å¾„ä¸å­˜åœ¨ï¼šä¸æŠ›å¼‚å¸¸ï¼Œç›´æ¥è¿”å›ç©º dossier
        # if not os.path.exists(folder_path): return dossier

        # TODOã€é€‰æ”¹-å¯è¿ç§»å¢å¼ºã€‘3) åˆå¹¶è¡¨åæ˜ å°„ï¼ˆä¼˜å…ˆçº§ï¼‰ï¼š
        # DEFAULT_TABLE_NAME_MAP < table_map.json < runtime table_name_map
        # å¹¶æ³¨å†Œåˆ° dossier.register_table_aliases()

        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘4) éå†æ–‡ä»¶å¹¶æŒ‰åç¼€åˆ†å‘ï¼š
        # - csv/xlsx/txt/md å¿…é¡»æ”¯æŒ
        # - docx/pdfï¼šç¼ºä¾èµ–åˆ™è·³è¿‡ï¼Œä¸å´©æºƒ
        raise NotImplementedError

    # ---------------------------
    # Private loadersï¼ˆå®ç°ç»†èŠ‚ä¸å¼ºç»‘ï¼Œä½†å»ºè®®æœ‰ï¼‰
    # ---------------------------
    def _load_csv(
        self,
        dossier: Dossier,
        path: str,
        table_name: str,
        aliases: Optional[List[str]] = None,
    ) -> None:
        """
        CSV è¯»å–ï¼šå°è¯•å¤šç¼–ç å¹¶å†™å…¥ add_table()

        Args:
            dossier: Dossier
            path: æ–‡ä»¶è·¯å¾„
            table_name: å†™å…¥ structured_data çš„è¡¨å
            aliases: åˆ«ååˆ—è¡¨ï¼ˆé€šå¸¸ç”¨ base_nameï¼‰

        Returns:
            None
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # - è‡³å°‘å°è¯• utf-8-sig / utf-8ï¼ˆä½ ä¹Ÿå¯ä»¥æ‰©å±•æ›´å¤šç¼–ç ï¼‰
        # - df.columns å»ºè®® strip
        # - dossier.add_table(name=table_name, df=df, source=path, aliases=aliases)
        raise NotImplementedError

    def _load_excel(self, dossier: Dossier, path: str, base_name: str) -> None:
        """
        Excel è¯»å–ï¼šæ¯ä¸ª sheet ä¸€å¼ è¡¨

        Args:
            dossier: Dossier
            path: æ–‡ä»¶è·¯å¾„
            base_name: æ–‡ä»¶åŸºç¡€åï¼ˆä¸å«åç¼€ï¼‰

        Returns:
            None
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        # - pd.read_excel(sheet_name=None)
        # - å• sheetï¼šè¡¨å=base_name
        # - å¤š sheetï¼šè¡¨å=base_name_sheetï¼ˆæˆ–ä½ è‡ªå®šä¹‰è§„åˆ™ï¼‰
        raise NotImplementedError

    def _load_txt(self, dossier: Dossier, path: str, filename: str) -> None:
        """
        txt/mdï¼šè¯»å–å…¨æ–‡å¹¶ add_text()

        Args:
            dossier: Dossier
            path: æ–‡ä»¶è·¯å¾„
            filename: æ–‡ä»¶åï¼ˆä½œä¸º sourceï¼‰

        Returns:
            None
        """
        # TODOã€å¿…å†™-æ¡†æ¶é€šç”¨ã€‘
        raise NotImplementedError

    def _load_docx(self, dossier: Dossier, path: str, filename: str) -> None:
        """
        docxï¼šç¼ºä¾èµ–åˆ™è·³è¿‡ï¼Œä¸å´©æºƒ

        TODOã€é€‰æ”¹-å¯è¿ç§»å¢å¼ºã€‘
        """
        # OPTï¼šDocument is None -> return
        raise NotImplementedError

    def _load_pdf(self, dossier: Dossier, path: str, filename: str) -> None:
        """
        pdfï¼šç¼ºä¾èµ–åˆ™è·³è¿‡ï¼Œä¸å´©æºƒ

        TODOã€é€‰æ”¹-å¯è¿ç§»å¢å¼ºã€‘
        """
        # OPTï¼šPdfReader is None -> return
        raise NotImplementedError
```

</details>

### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_dossier_loader.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_dossier_loader.py</b></summary>

   ```py
    from __future__ import annotations

    from pathlib import Path
    from typing import Any, Dict

    import pandas as pd

    from debate_mas.loader.dossier import Dossier
    from debate_mas.loader.dual_mode_loader import DualModeLoader


    def test_dossier_create_empty_contract() -> None:
        d = Dossier.create_empty(mission="x")
        assert isinstance(d, Dossier)
        assert d.mission == "x"

        # å¿…é¡»å­˜åœ¨çš„æœ€å°å­—æ®µï¼ˆæ¡†æ¶é€šç”¨ï¼‰
        assert isinstance(d.structured_data, dict)
        assert isinstance(d.unstructured_text, list)
        assert isinstance(d.meta, dict)
        assert isinstance(d.tables_meta, dict)
        assert isinstance(d.texts_meta, list)


    def test_add_table_and_frozen_view_contract() -> None:
        d = Dossier.create_empty(mission="x")
        df = pd.DataFrame([{"a": 1, "b": 2}])

        d.add_table(name="t1", df=df, description="demo", source="unit-test")

        assert "t1" in d.structured_data
        assert isinstance(d.tables_meta.get("t1"), dict)

        fv = d.frozen_view()
        assert isinstance(fv, dict)
        assert fv.get("mission") == "x"
        assert "tables" in fv and isinstance(fv["tables"], list)
        assert "texts" in fv and isinstance(fv["texts"], list)

        # frozen_view ä¸åº”è¯¥æš´éœ² DataFrame æœ¬ä½“
        # ï¼ˆåªè¦ tables é‡Œæ²¡æœ‰ç›´æ¥å¡ df å°±è¡Œï¼›ä¸‹é¢æ–­è¨€è¶³å¤Ÿå®½æ¾ï¼‰
        for t in fv["tables"]:
            assert "name" in t


    def test_add_text_contract() -> None:
        d = Dossier.create_empty(mission="x")
        d.add_text("hello world", source="note.md")

        assert len(d.unstructured_text) == 1
        assert len(d.texts_meta) == 1
        assert isinstance(d.texts_meta[0], dict)
        assert d.texts_meta[0].get("source") == "note.md"


    def test_loader_path_not_exist_returns_empty_dossier(tmp_path: Path) -> None:
        loader = DualModeLoader()
        missing = tmp_path / "not_exist_folder"

        dossier = loader.load_from_folder(
            mission="m",
            folder_path=str(missing),
        )
        assert isinstance(dossier, Dossier)
        assert dossier.mission == "m"
        # ä¸æŠ›å¼‚å¸¸ï¼Œå¹¶ä¸”è¿”å›ç©ºæ¡ˆå·
        assert isinstance(dossier.structured_data, dict)
        assert len(dossier.structured_data) == 0
        assert isinstance(dossier.unstructured_text, list)

        # å»ºè®®é¡¹ï¼šmeta é‡Œä¿ç•™ source_pathï¼ˆä½ å¯ä»¥æŒ‰éœ€è°ƒæ•´ï¼›å¦‚æœä½ ä¸æ‰“ç®—å†™ä¹Ÿå¯åˆ ï¼‰
        assert dossier.meta.get("source_path") == str(missing)


    def test_loader_loads_minimal_supported_files(tmp_path: Path) -> None:
        """
        å¿…æµ‹ç‚¹ï¼šè‡³å°‘æ”¯æŒ csv/xlsx/txt/md å››ç±»ã€‚
        - csv -> è¡¨
        - xlsx -> è¡¨ï¼ˆè‡³å°‘ 1 ä¸ª sheetï¼‰
        - txt/md -> æ–‡æœ¬
        """
        # --- å‡†å¤‡æµ‹è¯•æ–‡ä»¶ ---
        # 1) csv
        csv_path = tmp_path / "a.csv"
        pd.DataFrame([{"x": 1}, {"x": 2}]).to_csv(csv_path, index=False, encoding="utf-8-sig")

        # 2) xlsx
        xlsx_path = tmp_path / "b.xlsx"
        with pd.ExcelWriter(xlsx_path) as w:
            pd.DataFrame([{"y": 10}]).to_excel(w, index=False, sheet_name="S1")

        # 3) txt
        txt_path = tmp_path / "c.txt"
        txt_path.write_text("hello txt", encoding="utf-8")

        # 4) md
        md_path = tmp_path / "d.md"
        md_path.write_text("# hello md", encoding="utf-8")

        loader = DualModeLoader()
        dossier = loader.load_from_folder(mission="m", folder_path=str(tmp_path))

        # è‡³å°‘åº”æœ‰ 2 å¼ è¡¨ï¼ˆcsv + xlsxï¼‰
        assert isinstance(dossier.structured_data, dict)
        assert len(dossier.structured_data) >= 2

        # è‡³å°‘åº”æœ‰ 2 æ®µæ–‡æœ¬ï¼ˆtxt + mdï¼‰
        assert isinstance(dossier.unstructured_text, list)
        assert len(dossier.unstructured_text) >= 2

        # å…ƒä¿¡æ¯ç•™ç—•åº”åŒæ­¥å¢é•¿
        assert isinstance(dossier.tables_meta, dict)
        assert len(dossier.tables_meta) >= 2
        assert isinstance(dossier.texts_meta, list)
        assert len(dossier.texts_meta) >= 2


    def test_get_table_and_list_tables_are_available(tmp_path: Path) -> None:
        csv_path = tmp_path / "demo.csv"
        pd.DataFrame([{"x": 1}]).to_csv(csv_path, index=False, encoding="utf-8-sig")

        loader = DualModeLoader()
        dossier = loader.load_from_folder(mission="m", folder_path=str(tmp_path))

        names = dossier.list_tables()
        assert isinstance(names, list)
        assert len(names) >= 1

        # ä¸å¼ºç»‘å…·ä½“è¡¨åï¼ŒåªéªŒè¯ get_table èƒ½å–åˆ°æŸå¼ è¡¨
        t0 = names[0]
        df0 = dossier.get_table(t0)
        assert df0 is None or isinstance(df0, pd.DataFrame)
   ```

   </details>

2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_dossier_loader.py
```

> å¦‚æœä½ ä¸ç”¨ uvï¼šä¹Ÿå¯ä»¥ç”¨ `pytest -q tests/test_dossier_loader.py`

### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰  
  - `6 passed in ...s`  
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`FileNotFoundError`ã€`KeyError`ã€`AssertionError`
  
- ä½ é€šè¿‡çš„æ˜¯â€œæ¡†æ¶å¿…æœ‰â€çš„éªŒæ”¶ç‚¹ï¼š

  1) **Dossier æœ€å°å¯¹è±¡å¯åˆ›å»º**
     - `Dossier.create_empty(mission)` å¯ç”¨
     - å¿…è¦å­—æ®µç¨³å®šå­˜åœ¨ï¼š
       `mission / structured_data / unstructured_text / meta / tables_meta / texts_meta`

  2) **è¯æ®å†™å…¥å¯ç”¨**
     - `add_table()` èƒ½å†™å…¥ `structured_data` ä¸”åŒæ­¥å†™ `tables_meta`
     - `add_text()` èƒ½å†™å…¥ `unstructured_text` ä¸”åŒæ­¥å†™ `texts_meta`

  3) **åªè¯»é€è§†å¯ç”¨**
     - `frozen_view()` è¿”å› dict
     - è‡³å°‘åŒ…å«ï¼š`mission / meta / tables(list) / texts(list)`
     - ä¸è¦æ±‚è¾“å‡ºå›ºå®šå­—æ®µå…¨é›†ï¼Œä½†å»ºè®® tables/texts æ˜¯å¯è¯»æ‘˜è¦

  4) **folder â†’ dossier æœ€å°å¥‘çº¦æˆç«‹**
     - `load_from_folder()` å¯¹è·¯å¾„ä¸å­˜åœ¨ï¼šä¸å´©æºƒã€è¿”å›ç©º dossierï¼ˆmeta ä¿ç•™ source_pathï¼‰
     - è‡³å°‘æ”¯æŒ `csv/xlsx/txt/md` å››ç±»
     - å¯é€‰ä¾èµ–ï¼ˆ`pypdf/docx`ï¼‰ç¼ºå¤±æ—¶ï¼šè·³è¿‡ï¼Œä¸æŠ¥é”™

  5) **è°ƒè¯•å…¥å£å­˜åœ¨**
     - `list_tables()` å¯ç”¨ï¼Œä¾¿äºè°ƒè¯•
     - `get_table(name)` å¯ç”¨ï¼ˆå…è®¸ä½ å®ç° alias/canonical æˆ–ç›´æ¥å–ï¼‰


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> **å…³å¡-04** çš„ç›®æ ‡æ˜¯ï¼šæŠŠâ€œè¯»å–ææ–™â€ä¸â€œä¸šåŠ¡æ¨ç†â€å½»åº•è§£è€¦ã€‚
> 
> è¿ç§»åˆ°ä»»ä½•ä»»åŠ¡ï¼ˆåˆè§„ã€æŠ•ç ”ã€è¯„å®¡ã€åŒ»ç–—ä¼šè¯Šâ€¦ï¼‰æ—¶ï¼Œä½ åªéœ€è¦æ›¿æ¢â€œææ–™ä»å“ªæ¥ã€æ€ä¹ˆå‘½åã€æ€ä¹ˆç»„ç»‡â€ï¼Œè€Œ Debate MAS çš„ Core/Skills/Renderer å¯ä»¥ä¿æŒä¸å˜ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

- **ç»Ÿä¸€è¯æ®ç®±ï¼šDossier**
  - ç¨³å®šå­—æ®µï¼š`mission / structured_data / unstructured_text / meta`
  - å®¡è®¡ç•™ç—•ï¼š`tables_meta / texts_meta`
  - åŸåˆ™ï¼šAgent ä¸ç›´æ¥è¯»æ–‡ä»¶/è¿åº“ï¼Œåªçœ‹ Dossier + frozen_view()

- **åªè¯»é€è§†ï¼šfrozen_view()**
  - åŸåˆ™ï¼šç»™ Agent çš„æ˜¯æ‘˜è¦ï¼Œä¸æ˜¯ DataFrame æœ¬ä½“
  - å¥½å¤„ï¼šæç¤ºè¯æ›´ç¨³ã€æ—¥å¿—æ›´è½»ã€å¯å¤ç›˜æ›´æ¸…æ™°

- **Loader çš„â€œæœ€å°å…¥å£â€**
  - `load_from_folder(mission, folder_path, ...) -> Dossier`
  - è·¯å¾„ä¸å­˜åœ¨ä¹Ÿä¸å´©ï¼ˆè¿”å›ç©º dossierï¼Œè®©ä¸Šå±‚èƒ½ç»§ç»­ç»™å‡ºâ€œç¼ºææ–™â€çš„è§£é‡Šï¼‰

**2. ä¸šåŠ¡ç›¸å…³ï¼šå…è®¸æ›¿æ¢/æ‰©å±•**

- **åˆ«åç³»ç»Ÿ**
  - ä½ å¯ä»¥ç”¨ `table_map.json / table_name_map / file_map` ç»Ÿä¸€å‘½å
  - å¦‚æœä½ çš„ä¸šåŠ¡ä¸éœ€è¦å¤šç‰ˆæœ¬å…¼å®¹ï¼Œå¯ä»¥ä¸å®ç° aliasï¼›æµ‹è¯•ä¹Ÿä¸å¼ºç»‘

- **æ”¯æŒæ›´å¤šæ–‡ä»¶ç±»å‹**
  - pdf/docxï¼šå¯é€‰ä¾èµ–ï¼Œæ²¡è£…å°±è·³è¿‡
  - ä½ ä¹Ÿå¯ä»¥æ‰©å±•ï¼šhtmlã€pptxã€å›¾ç‰‡æ‘˜è¦ã€éŸ³é¢‘è½¬å†™ç­‰

- **Excel sheet å‘½åè§„åˆ™**
  - å• sheetï¼š`base`
  - å¤š sheetï¼š`base_sheet`ï¼ˆæˆ–è‡ªå®šä¹‰ï¼š`base__sheet`ã€ç»Ÿä¸€å°å†™ç­‰ï¼‰
  - åªè¦ä¿æŒâ€œåå­—ç¨³å®š + å…ƒä¿¡æ¯ç•™ç—•â€å³å¯

- **æ›´ä¸¥æ ¼çš„ pytest**
  - å¦‚æœä½ æŠŠæŸäº›è¡¨å½“ä½œâ€œå¿…éœ€è¾“å…¥å¥‘çº¦â€ï¼Œå¯ä»¥åœ¨æµ‹è¯•é‡ŒåŠ ï¼š
    - `assert "prices" in dossier.list_tables()`
    - `assert set(df.columns) >= {"date","close"}`
  - å¦‚æœä½ æŠŠæ–‡æœ¬å½“ä½œâ€œå¿…é¡»ææ–™â€ï¼Œå¯ä»¥åŠ ï¼š
    - `assert any("policy" in t.lower() for t in dossier.unstructured_text)`


**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**

- **ä¸åŠ¨**ï¼šDossier çš„æœ€å°å­—æ®µ + add_table/add_text/frozen_view + load_from_folder çš„â€œç¨³å®šå…¥å£â€
- **å¯æ¢**ï¼šæ–‡ä»¶å‘½åè§„åˆ™ã€åˆ«åæ˜ å°„ç­–ç•¥ã€æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€ä¸šåŠ¡å¿…éœ€è¡¨çš„ä¸¥æ ¼æ–­è¨€

</details>

---


## å…³å¡-05ï½œæç¤ºè¯å·¥å‚ Personasï¼šå·¥å…·ç™½åå• + è¾“å‡ºæ ¼å¼çº¦æŸ

<details>
<summary><b>Checkpoint 05 â€” æç¤ºè¯å·¥å‚ Personas ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³æŠŠâ€œè§’è‰²æç¤ºè¯â€ä»é›¶æ•£å­—ç¬¦ä¸²å‡çº§ä¸º **å¯å¤ç”¨çš„ Prompt Factory**ï¼š  
> ä½ å°†ç”¨ä¸€å¥—ç»Ÿä¸€æ¨¡æ¿ï¼ŒæŠŠ **ä»»åŠ¡æŒ‡ä»¤ / æ¡ˆå·æ‘˜è¦ / å·¥å…·ç™½åå• / è¾“å‡ºæ ¼å¼å¥‘çº¦** æ‹¼æˆç¨³å®šçš„ system promptã€‚  
>
> è¿™ä¸€å…³ä¸è¿½æ±‚â€œæ›´èªæ˜â€ï¼Œåªè¿½æ±‚ **æ›´ç¨³å®šã€å¯æµ‹è¯•ã€å¯è¿ç§»**ï¼š  
> - Graph/Engine ä¸å†æ‰‹æ“ prompt  
> - è§’è‰²è¾“å‡ºæ›´å®¹æ˜“è¢«è§£æï¼ˆJSON-only / åŒæ®µè¾“å‡ºï¼‰  
> - å·¥å…·ä½¿ç”¨ä¸è¶Šæƒï¼ˆç™½åå•ï¼‰  
> - è¯æ®å¼•ç”¨å¯å®¡è®¡


### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- å»ºç«‹â€œæç¤ºè¯å·¥å‚â€æœ€å°é—­ç¯ï¼š`mission + dossier_view + allowlist + slots -> system_prompt`
- æŠŠè§’è‰²å…±æ€§è§„åˆ™æŠ½æˆå¸¸é‡ï¼ˆå¼ºåˆ¶çº¦æŸï¼‰ï¼š
  - **å·¥å…·ç™½åå•**ï¼šåªèƒ½æåŠ/è°ƒç”¨ç™½åå•å†…å·¥å…·
  - **è¯æ®ä¼˜å…ˆ**ï¼šåªèƒ½åŸºäº dossier + æœ¬è½®å·¥å…·è¾“å‡º
- æŠŠè§’è‰²å·®å¼‚æ”¶æ•›åˆ° `PromptSlots`ï¼ˆå¯é…ç½®ã€å¯æ‰©å±•ï¼‰
- å›ºå®šä¸¤ç§è¾“å‡ºæ¨¡å¼ï¼š
  - `json_only=True`ï¼šåªè¾“å‡ºä¸€ä¸ª JSON ä¸¥æ ¼å¯è§£æ
  - `json_only=False`ï¼šå…ˆ Debate å† Final JSON


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ `src/debate_mas/core/personas.py`
- ä¸æ”¹ graphã€engineã€skills çš„é€»è¾‘ï¼Œä¸å¼•å…¥æ–°ä¾èµ–
- ç›®æ ‡ä¸æ˜¯â€œå†™æ›´é•¿çš„ promptâ€ï¼Œè€Œæ˜¯ï¼š
  - **prompt ç»“æ„ç¨³å®š**
  - **å·¥å…·è¶Šæƒè¢« prompt æ˜ç¡®ç¦æ­¢**
  - **è¾“å‡ºæ ¼å¼å¯¹é½åç»­è§£æå™¨éœ€æ±‚**


### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

**å¿…çœ‹**
- `src/debate_mas/core/personas.py`ï¼šæç¤ºè¯å·¥å‚ï¼ˆæœ¬å…³ï¼Œå”¯ä¸€éœ€è¦å†™ä»£ç çš„åœ°æ–¹ï¼‰
- `src/debate_mas/core/state.py`ï¼š`dossier_view` çš„æ¥æºï¼ˆæ¥è‡ª `dossier.frozen_view()`ï¼Œç†è§£ prompt é‡Œâ€œè¯æ®æ‘˜è¦â€ä»å“ªæ¥ï¼‰
- `src/debate_mas/protocol/schema.py`ï¼šæœ€ç»ˆè¦è½åœ°çš„ç»“æ„ç±»å‹ï¼ˆCANDIDATES / OBJECTIONS / DECISIONSï¼‰ï¼Œå†³å®š `output_type / output_schema_hint` æ€ä¹ˆå†™


####  `personas.py`ï¼ˆæç¤ºè¯å·¥å‚ï¼‰

æœ¬æ–‡ä»¶æ‹†æˆä¸¤å±‚ï¼š**é€šç”¨æ¨¡ç‰ˆå±‚ï¼ˆFramework Templateï¼‰** ä¸ **ä»»åŠ¡åŒ–ä¸ªæ€§å±‚ï¼ˆTask Slotsï¼‰**ã€‚  
æœ¬å…³ç»ƒä¹ é‡ç‚¹æ˜¯ï¼š**å°½é‡ä¸åŠ¨é€šç”¨å±‚ï¼Œåªæ”¹ä¸ªæ€§å±‚**ï¼›åªæœ‰å½“ä½ æ˜ç¡®è¦â€œä¼˜åŒ–æ¡†æ¶æ¨¡ç‰ˆâ€æ—¶æ‰åŠ¨é€šç”¨å±‚ã€‚

**é€šç”¨æ¨¡ç‰ˆå±‚**
- `build_universal_system_prompt(...) -> str`
  - ä½œç”¨ï¼šæŠŠ **mission + dossier_view æ‘˜è¦ + å·¥å…·ç™½åå• + è¾“å‡ºæ ¼å¼ + é£æ ¼æŒ‡å—** æ‹¼æˆä¸€ä¸ªç¨³å®šçš„ system prompt
  - å…¼å®¹ä¸¤ç§è¾“å‡ºæ¨¡å¼ï¼š`json_only=True/False`
  - è¿™ä¸€å±‚åº”è¯¥ä¿æŒ **â€œä»»åŠ¡æ— å…³â€**ï¼šä¸å†™ ETF ä¸“å±æœ¯è¯­ã€ä¸å†™æŸä¸ªè§’è‰²çš„ç»†èŠ‚è§„åˆ™
- `_ENFORCED_ROLE_RULES / _ENFORCED_TOOL_POLICY`
  - æ‰€æœ‰è§’è‰²å…±äº«çš„ç¡¬çº¦æŸï¼ˆç™½åå•ã€ç¦æ­¢ç¼–é€  tool resultã€è¯æ®å¼•ç”¨è§„åˆ™ï¼‰
  - å¿…é¡»è¢« `build_universal_system_prompt` æ³¨å…¥åˆ° prompt
- `PromptSlots`
  - è§’è‰²å·®å¼‚é…ç½®è½½ä½“
  - è¿™ä¸€å±‚ä¸åšä¸šåŠ¡å†³ç­–ï¼Œåªæä¾›â€œæ€ä¹ˆå¡«è¿› promptâ€çš„æ§½ä½

> åˆæ­¥ç»ƒä¹ ç›®æ ‡ï¼š**ä¸æ”¹é€šç”¨æ¨¡ç‰ˆå±‚**ï¼Œåªç¡®è®¤å®ƒâ€œä»»åŠ¡æ— å…³ + ç»“æ„ç¨³å®šâ€ã€‚

**ä»»åŠ¡åŒ–ä¸ªæ€§å±‚ï¼ˆæ¯ä¸ªLLMå…·ä½“çš„è®¾å®šï¼‰**
- `get_hunter_slots() / get_auditor_slots() / get_pm_slots()`
  - ä½œç”¨ï¼šæŠŠâ€œä¸šåŠ¡è§’è‰²å·®å¼‚â€å¡è¿› `PromptSlots`
  - å¿…é¡»æ˜ç¡®ä¸‰ä»¶äº‹ï¼š
    1) è§’è‰²è¦åšä»€ä¹ˆï¼ˆrole_goalï¼‰
    2) è§’è‰²å¿…é¡»éµå®ˆå“ªäº›è§„åˆ™ï¼ˆrole_rules / tool_policyï¼‰
    3) è¾“å‡ºè¦é•¿ä»€ä¹ˆæ ·ï¼ˆoutput_type / output_schema_hint / json_onlyï¼‰
- `build_role_prompts_etf(...) -> Dict[str, str]`
  - ä½œç”¨ï¼šæŠŠä¸‰å¥— slots + ä¸‰å¥— allowlist ç»„åˆæˆä¸‰æ®µ promptï¼ˆhunter/auditor/pmï¼‰
  - æ¨èåœ¨è¿™é‡Œç»Ÿä¸€å¤„ç†â€œä»»åŠ¡çº§å¼€å…³â€ï¼ˆä¾‹å¦‚ MIN_CANDIDATESã€æ˜¯å¦å¯ç”¨çº¦æŸç­‰ï¼‰ï¼Œå†™è¿› `extra_context`

> åˆæ­¥ç»ƒä¹ æ ¸å¿ƒäº§å‡ºï¼š**æŠŠåŒä¸€ä¸ªé€šç”¨æ¨¡ç‰ˆï¼Œå®ä¾‹åŒ–æˆä¸‰ç§è§’è‰² prompt**ã€‚

**å…è®¸åšçš„â€œè¿›é˜¶ä¼˜åŒ–â€**

- **OPTã€é€‰æ”¹-æ¡†æ¶ä¼˜åŒ–ã€‘åªåœ¨æ˜ç¡®éœ€è¦æ—¶å†æ”¹**
  - ä¼˜åŒ– `build_universal_system_prompt` çš„ç»“æ„/æ’ç‰ˆï¼ˆæ›´çŸ­ã€æ›´æ¸…æ™°ã€æ›´åˆ©äºè§£æï¼‰
  - å¢å¼º dossier æ‘˜è¦çš„å…¼å®¹æ€§ï¼ˆtables æ˜¯ dict/list éƒ½èƒ½ä¼˜é›…å±•ç¤ºï¼‰
  - æŠ½ helper å‡½æ•°ï¼ˆå¦‚ `_render_output_section(slots)`ï¼‰ï¼Œä½†ä¸æ”¹å˜æœ€ç»ˆå¥‘çº¦å­—æ®µä¸æ®µè½è¦ç‚¹

- **OPTã€é€‰æ”¹-ä¸šåŠ¡æ‰©å±•ã€‘æŒ‰éœ€å¢åŠ **
  - å¢åŠ æ–°è§’è‰² slotsï¼ˆanalyst / execution / complianceï¼‰
  - å¢åŠ æ–°ä»»åŠ¡ç»„åˆå™¨ï¼ˆä¾‹å¦‚ `build_role_prompts_credit_risk`ï¼‰

<details>
<summary><b>ğŸ“„ Checkpoint-05ï¼šcore/personas.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/core/personas.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from .config import CONFIG


# ============================================================
# ã€æ¡†æ¶é€šç”¨ã€‘å¼ºåˆ¶è§„åˆ™/å¼ºåˆ¶å·¥å…·æ”¿ç­–ï¼šæ‰€æœ‰è§’è‰²å…±äº«
# ============================================================
_ENFORCED_ROLE_RULES: List[str] = [
    "åªå…è®¸æåŠç™½åå•å†…å·¥å…·ï¼›ä¸å¾—å»ºè®®/æœæ’°/æš—ç¤ºä»»ä½•ç™½åå•å¤–å·¥å…·æˆ–å¤–éƒ¨æ•°æ®æºã€‚",
    "åªèƒ½åŸºäº dossier ä¸æœ¬è½®å·¥å…·è¾“å‡ºåšåˆ¤æ–­ï¼›ä¸è¦ç¼–é€ æœªå‡ºç°çš„æ•°æ®/æ–°é—»/ç»“è®ºã€‚",
]

_ENFORCED_TOOL_POLICY: List[str] = [
    "å·¥å…·è°ƒç”¨å¿…é¡»æ¥è‡ªç™½åå•ï¼›ä¸è¦ä»¥ä»»ä½•å½¢å¼ç»•è¿‡ï¼ˆä¾‹å¦‚å†™ä¼ªå·¥å…·åã€å†™å¤–éƒ¨APIã€å†™â€˜å‡è®¾æˆ‘æŸ¥åˆ°äº†â€¦â€™ï¼‰ã€‚",
    "ã€ç»å¯¹ç¦æ­¢ã€‘ç¦æ­¢è™šæ„å·¥å…·è°ƒç”¨ç»“æœã€‚ä½ å¿…é¡»å…ˆå‘å‡º Tool Callï¼Œç­‰å¾…ä¸‹ä¸€è½®çœ‹åˆ° ToolMessage åï¼Œå†åŸºäºçœŸå®ç»“æœæ’°å†™ evidenceã€‚",
    "å¦‚æœæœ¬è½®æ²¡æœ‰çœ‹åˆ° ToolMessage è¿”å›çš„ [PASS]/[REJECT] ç­‰ç»“æœï¼Œä¸¥ç¦åœ¨æ–‡å­—ä¸­å£°ç§°â€˜ç»“æœæ˜¾ç¤º...â€™ã€‚",
    "å¼•ç”¨å·¥å…·è¯æ®æ—¶å¿…é¡»æŒ‡å‘ã€æœ¬è½®ã€‘ToolMessage çš„å®é™…è¾“å‡ºï¼ˆä¸å£å¤´ç¼–é€ æ•°å€¼ï¼‰ã€‚",
]

@dataclass(frozen=True)
class PromptSlots:
    role_name: str
    role_goal: str
    role_rules: List[str]
    tool_policy: List[str]
    output_type: str
    output_schema_hint: str
    style_guide: List[str]
    json_only: bool = True  


def build_universal_system_prompt(
    *,
    mission: str,
    dossier_view: Dict[str, Any],
    allowed_tools: List[str],
    slots: PromptSlots,
    extra_context: Optional[str] = None,
) -> str:
    dv = dossier_view or {}
    tables = dv.get("tables", dv.get("tables_meta", {}))
    texts = dv.get("texts", dv.get("texts_meta", []))

    tool_list = ", ".join(allowed_tools) if allowed_tools else "ï¼ˆæ— å·¥å…·ï¼‰"

    lines: List[str] = []
    lines.append("ä½ æ˜¯ä¸€ä¸ªä»¥è¯æ®ä¸ºä¸­å¿ƒçš„é¢†åŸŸä¸“å®¶ã€‚")
    lines.append("")
    lines.append("ã€ä»»åŠ¡æŒ‡ä»¤ã€‘")
    lines.append(mission)
    lines.append("")
    lines.append("ã€æ•°æ®è¯æ®æ‘˜è¦ï¼ˆåªè¯»ï¼‰ã€‘")
    lines.append(f"- è¡¨æ ¼æ•°é‡: {len(tables) if hasattr(tables, '__len__') else 0}")
    if isinstance(tables, dict):
        tnames = list(tables.keys())[:20]
        lines.append(f"- è¡¨æ ¼åˆ—è¡¨(æœ€å¤š20): {tnames}")
    else:
        lines.append("- è¡¨æ ¼æ‘˜è¦: å·²æä¾›")
    lines.append(f"- æ–‡æœ¬æ•°é‡: {len(texts) if hasattr(texts, '__len__') else 0}")
    lines.append("")
    lines.append("ã€ä½ çš„è§’è‰²ã€‘")
    lines.append(f"- è§’è‰²å: {slots.role_name}")
    lines.append(f"- è§’è‰²ç›®æ ‡: {slots.role_goal}")
    lines.append("")
    lines.append("ã€å·¥å…·æƒé™ï¼ˆç™½åå•ï¼‰ã€‘")
    lines.append(f"- ä½ å¯è°ƒç”¨/å¯å¼•ç”¨/å¯æåŠçš„å·¥å…·ä»…é™: {tool_list}")
    lines.append("- ç¦æ­¢å‡ºç°ç™½åå•å¤–çš„ä»»ä½•å·¥å…·åï¼ˆåŒ…æ‹¬â€œæˆ‘æƒ³ç”¨XXå·¥å…·â€è¿™ç§æè®®ï¼‰ã€‚")
    lines.append("")

    lines.append("ã€è§’è‰²è§„åˆ™ï¼ˆå¿…é¡»éµå®ˆï¼‰ã€‘")
    for r in _ENFORCED_ROLE_RULES:
        lines.append(f"- {r}")
    for r in slots.role_rules:
        lines.append(f"- {r}")
    lines.append("")

    lines.append("ã€å·¥å…·ä½¿ç”¨æ”¿ç­–ï¼ˆå¿…é¡»éµå®ˆï¼‰ã€‘")
    for p in _ENFORCED_TOOL_POLICY:
        lines.append(f"- {p}")
    for p in slots.tool_policy:
        lines.append(f"- {p}")
    lines.append("")

    lines.append("ã€è¾“å‡ºæ ¼å¼ã€‘")
    if slots.json_only:
        lines.append("ä½ åªè¾“å‡ºä¸€ä¸ª JSON å¯¹è±¡ï¼Œä¸è¦è¾“å‡ºå¤šä½™æ–‡æœ¬ï¼Œä¸è¦ markdownï¼Œä¸è¦ä»£ç å—ã€‚")
        lines.append("è¾“å‡ºå­—æ®µå…è®¸ä½ è‡ªç”±å¢æ·»ï¼Œä½†å¿…é¡»åŒ…å«ä»¥ä¸‹æœ€å°å­—æ®µã€‚")
        lines.append(f"- type: å›ºå®šä¸º {slots.output_type}")
        lines.append(f"- items: åˆ—è¡¨ï¼Œå…ƒç´ ç»“æ„å‚è€ƒ: {slots.output_schema_hint}")
        lines.append("- notes: åˆ—è¡¨ï¼Œå†™å…³é”®ä¾æ®ä¸é™åˆ¶æ¡ä»¶ï¼ˆå£°æ˜å¼çŸ­å¥ï¼‰")
        lines.append("- stop_suggest: å­—ç¬¦ä¸²ï¼Œå†™ STOP æˆ– CONTINUE")
    else:
        lines.append("ä½ å¿…é¡»è¾“å‡ºä¸¤æ®µå†…å®¹ï¼ˆé¡ºåºå›ºå®šï¼‰ï¼š")
        lines.append("1) ã€Debateã€‘è‡ªç„¶è¯­è¨€çŸ­æ®µè½ï¼ˆ3-8 è¡Œï¼‰ï¼šå†™ä½ çš„è´¨ç–‘/å›åº”/å–èˆï¼Œå¿…é¡»å¼•ç”¨è¯æ®æˆ–å·¥å…·ç»“æœã€‚")
        lines.append("Debate ç¬¬ä¸€è¡Œå¿…é¡»å†™ï¼šToolUse=YES/NO + ä¸€å¥è¯åŸå› ï¼ˆä¾‹å¦‚ï¼šToolUse=NOï¼Œå› ä¸ºä»…å¯¹å·²å®¡è®¡çš„ WARN æ ‡çš„è¡¥å……æ­¢æŸæ¡ä»¶ï¼Œæ— éœ€æ–°å¢è¯æ®ï¼‰ã€‚")
        lines.append("2) ã€Final JSONã€‘ä¸€ä¸ª JSON å¯¹è±¡ï¼ˆå¿…é¡»æ”¾åœ¨æœ€åä¸€è¡Œå¼€å§‹ï¼Œä¸” JSON ç»“æŸåä¸è¦å†è¾“å‡ºä»»ä½•æ–‡å­—ï¼‰ã€‚")
        lines.append("Final JSON çš„å­—æ®µå…è®¸ä½ è‡ªç”±å¢æ·»ï¼Œä½†å¿…é¡»åŒ…å«ä»¥ä¸‹æœ€å°å­—æ®µï¼š")
        lines.append(f"- type: å›ºå®šä¸º {slots.output_type}")
        lines.append(f"- items: åˆ—è¡¨ï¼Œå…ƒç´ ç»“æ„å‚è€ƒ: {slots.output_schema_hint}")
        lines.append("- notes: åˆ—è¡¨ï¼Œå†™å…³é”®ä¾æ®ä¸é™åˆ¶æ¡ä»¶ï¼ˆå£°æ˜å¼çŸ­å¥ï¼‰")
        lines.append("- stop_suggest: å­—ç¬¦ä¸²ï¼Œå†™ STOP æˆ– CONTINUE")
        lines.append("ç¦æ­¢ï¼šåœ¨ Final JSON åè¿½åŠ ä»»ä½•æ–‡æœ¬ï¼ˆå¦åˆ™è§£æå¯èƒ½å¤±è´¥ï¼‰ã€‚")

    lines.append("")
    lines.append("ã€è¡¨è¾¾é£æ ¼ã€‘")
    for s in slots.style_guide:
        lines.append(f"- {s}")

    if extra_context:
        lines.append("")
        lines.append("ã€è¡¥å……ä¸Šä¸‹æ–‡ã€‘")
        lines.append(extra_context.strip())

    return "\n".join(lines)


# ============================================================
# ã€å¿…å†™-ä»»åŠ¡åŒ–ä¸ªæ€§ã€‘ETF ä¸‰è§’è‰² slots
# ============================================================
def get_hunter_slots() -> PromptSlots:
    # TODOã€å¿…å†™-ä»»åŠ¡åŒ–ä¸ªæ€§ã€‘å¡«ä½ ä»¬çš„ Hunter è§„åˆ™/å·¥å…·æ”¿ç­–/è¾“å‡º schema hint
    raise NotImplementedError


def get_auditor_slots() -> PromptSlots:
    # TODOã€å¿…å†™-ä»»åŠ¡åŒ–ä¸ªæ€§ã€‘å¡«ä½ ä»¬çš„ Auditor è§„åˆ™/å·¥å…·æ”¿ç­–/è¾“å‡º schema hint
    raise NotImplementedError


def get_pm_slots() -> PromptSlots:
    # TODOã€å¿…å†™-ä»»åŠ¡åŒ–ä¸ªæ€§ã€‘å¡«ä½ ä»¬çš„ PM è§„åˆ™/å·¥å…·æ”¿ç­–/è¾“å‡º schema hint
    raise NotImplementedError


def build_role_prompts_etf(
    *,
    mission: str,
    dossier_view: Dict[str, Any],
    allowlist_by_role: Dict[str, List[str]],
) -> Dict[str, str]:
    """
    ä¸€æ¬¡æ€§æ„é€ ä¸‰è§’è‰² promptï¼Œä¾¿äº Graph/Engine è°ƒç”¨ã€‚

    Args:
        mission: ä»»åŠ¡æŒ‡ä»¤æ–‡æœ¬
        dossier_view: Dossier.frozen_view() äº§ç‰©ï¼ˆåªè¯»æ‘˜è¦ï¼‰
        allowlist_by_role: {"hunter":[...], "auditor":[...], "pm":[...]}

    Returns:
        prompts: {"hunter": "...", "auditor": "...", "pm": "..."}
    """
    # TODOã€å¿…å†™-ä»»åŠ¡åŒ–ä¸ªæ€§ã€‘
    # - è¯»å– CONFIG çš„ MIN_CANDIDATES ç­‰å‚æ•°ï¼ˆå¯é€‰ï¼‰
    # - åˆ†åˆ« build_universal_system_prompt(..., slots=get_xxx_slots())
    raise NotImplementedError
```
</details>


### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_personas.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_personas.py</b></summary>

   ```py
    from __future__ import annotations

    from typing import Any, Dict, List

    import pytest

    from debate_mas.core.personas import (
        PromptSlots,
        build_universal_system_prompt,
        build_role_prompts_etf,
        get_auditor_slots,
        get_hunter_slots,
        get_pm_slots,
    )


    def _dummy_dossier_view() -> Dict[str, Any]:
        """
        ç»™ personas ç”¨çš„ frozen_view å‡æ•°æ®ï¼š
        - tables ç”¨ list[dict]ï¼ˆæ›´è´´è¿‘ Dossier.frozen_view çš„è¾“å‡ºå½¢æ€ï¼‰
        - texts ç”¨ list[dict]
        """
        return {
            "mission": "m",
            "meta": {"source_path": "/tmp/demo"},
            "tables": [
                {"name": "prices", "source": "a.csv", "rows": 2, "cols": 3, "columns": ["date", "close"]},
                {"name": "basic", "source": "b.csv", "rows": 1, "cols": 2, "columns": ["code", "name"]},
            ],
            "texts": [
                {"idx": 0, "source": "note.md", "length": 10, "added_at": "2026-01-01T00:00:00"},
            ],
        }


    def _allowlist_by_role() -> Dict[str, List[str]]:
        return {
            "hunter": ["quantitative_sniper", "theme_miner"],
            "auditor": ["market_sentry", "forensic_detective"],
            "pm": ["allocator"],
        }


    def test_promptslots_shape_is_stable() -> None:
        slots = PromptSlots(
            role_name="x",
            role_goal="y",
            role_rules=["r1"],
            tool_policy=["p1"],
            output_type="CANDIDATES",
            output_schema_hint='{"symbol":"510300"}',
            style_guide=["s1"],
            json_only=True,
        )
        assert slots.role_name == "x"
        assert slots.json_only is True
        assert isinstance(slots.role_rules, list)
        assert isinstance(slots.tool_policy, list)

    @pytest.mark.parametrize("json_only", [True, False])
    def test_build_universal_system_prompt_contains_required_sections(json_only: bool) -> None:
        dv = _dummy_dossier_view()
        slots = PromptSlots(
            role_name="role_x",
            role_goal="do something",
            role_rules=["rule_a"],
            tool_policy=["policy_b"],
            output_type="XTYPE",
            output_schema_hint='{"k":"v"}',
            style_guide=["style_1"],
            json_only=json_only,
        )

        prompt = build_universal_system_prompt(
            mission="MISSION_TEXT",
            dossier_view=dv,
            allowed_tools=["tool_a", "tool_b"],
            slots=slots,
            extra_context="EXTRA_CTX",
        )

        assert isinstance(prompt, str)

        assert "ã€ä»»åŠ¡æŒ‡ä»¤ã€‘" in prompt
        assert "MISSION_TEXT" in prompt

        assert "ã€æ•°æ®è¯æ®æ‘˜è¦ï¼ˆåªè¯»ï¼‰ã€‘" in prompt
        assert "è¡¨æ ¼æ•°é‡" in prompt
        assert "æ–‡æœ¬æ•°é‡" in prompt

        assert "ã€ä½ çš„è§’è‰²ã€‘" in prompt
        assert "è§’è‰²å" in prompt
        assert "role_x" in prompt

        assert "ã€å·¥å…·æƒé™ï¼ˆç™½åå•ï¼‰ã€‘" in prompt
        assert "tool_a" in prompt and "tool_b" in prompt

        assert "ã€è§’è‰²è§„åˆ™ï¼ˆå¿…é¡»éµå®ˆï¼‰ã€‘" in prompt
        assert "ã€å·¥å…·ä½¿ç”¨æ”¿ç­–ï¼ˆå¿…é¡»éµå®ˆï¼‰ã€‘" in prompt
        assert "ç™½åå•" in prompt
        assert "ç¦æ­¢" in prompt

        assert "ã€è¾“å‡ºæ ¼å¼ã€‘" in prompt
        if json_only:
            assert "ä½ åªè¾“å‡ºä¸€ä¸ª JSON å¯¹è±¡" in prompt
            assert "type: å›ºå®šä¸º XTYPE" in prompt
        else:
            assert "ä½ å¿…é¡»è¾“å‡ºä¸¤æ®µå†…å®¹" in prompt
            assert "Final JSON" in prompt
            assert "type: å›ºå®šä¸º XTYPE" in prompt

        assert "ã€è¡¨è¾¾é£æ ¼ã€‘" in prompt
        assert "style_1" in prompt
        assert "ã€è¡¥å……ä¸Šä¸‹æ–‡ã€‘" in prompt
        assert "EXTRA_CTX" in prompt


    def test_get_slots_functions_return_promptslots() -> None:
        hunter = get_hunter_slots()
        auditor = get_auditor_slots()
        pm = get_pm_slots()

        assert isinstance(hunter, PromptSlots)
        assert isinstance(auditor, PromptSlots)
        assert isinstance(pm, PromptSlots)

        assert hunter.role_name and hunter.role_goal and hunter.output_type
        assert auditor.role_name and auditor.role_goal and auditor.output_type
        assert pm.role_name and pm.role_goal and pm.output_type


    def test_build_role_prompts_etf_returns_three_role_prompts() -> None:
        dv = _dummy_dossier_view()
        allowlist = _allowlist_by_role()

        prompts = build_role_prompts_etf(
            mission="M",
            dossier_view=dv,
            allowlist_by_role=allowlist,
        )

        assert isinstance(prompts, dict)

        for role in ["hunter", "auditor", "pm"]:
            assert role in prompts
            assert isinstance(prompts[role], str)
            assert len(prompts[role]) > 50  
            assert "ã€è¾“å‡ºæ ¼å¼ã€‘" in prompts[role]

        for role, tools in allowlist.items():
            for t in tools:
                assert t in prompts[role]

   ```

   </details>

2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_personas.py
```


### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰  
  - `4 passed in ...s`  
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`KeyError`ã€`AssertionError`
- å¦‚æœå¤±è´¥ï¼Œä½ åº”è¯¥èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°ä¸‰ç±»é—®é¢˜ï¼š
  - **é€šç”¨æ¨¡ç‰ˆæœªæ‹¼è£…æˆåŠŸ**ï¼šç¼ºå°‘å›ºå®šæ®µè½ï¼ˆä¾‹å¦‚æ‰¾ä¸åˆ° `ã€è¾“å‡ºæ ¼å¼ã€‘` / `ã€å·¥å…·æƒé™ï¼ˆç™½åå•ï¼‰ã€‘`ï¼‰
  - **è¾“å‡ºæ¨¡å¼åˆ†æ”¯ä¸å¯¹**ï¼š`json_only=True/False` çš„æ–­è¨€ä¸é€šè¿‡ï¼ˆä¾‹å¦‚å°‘äº† â€œä½ å¿…é¡»è¾“å‡ºä¸¤æ®µå†…å®¹â€ æˆ– â€œä½ åªè¾“å‡ºä¸€ä¸ª JSON å¯¹è±¡â€ï¼‰
  - **è§’è‰²å®ä¾‹åŒ–ä¸å®Œæ•´**ï¼š`build_role_prompts_etf` æ²¡è¿”å› `hunter/auditor/pm` ä¸‰æ®µ promptï¼Œæˆ–ç™½åå•å·¥å…·æ²¡è¢«æ³¨å…¥


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `personas.py` è®¾è®¡ç›®æ ‡æ˜¯ï¼š**é€šç”¨æ¨¡ç‰ˆç¨³å®šã€ä¸šåŠ¡æ§½ä½å¯æ›¿æ¢**ã€‚è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ ä¸éœ€è¦é‡å†™ Debate MASï¼Œåªè¦æŠŠâ€œè§’è‰² slots + å·¥å…·ç™½åå• + è¾“å‡ºåè®®â€æ¢æ‰ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

è¿™äº›æ˜¯ä»»ä½•â€œå¤šè§’è‰²åä½œ + å·¥å…·ç™½åå•æ²»ç† + ç»“æ„åŒ–å¯è§£æè¾“å‡ºâ€çš„æç¤ºè¯å·¥å‚éƒ½ç¦»ä¸å¼€çš„éª¨æ¶ã€‚è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡æ—¶ï¼Œ**å»ºè®®ä¸æ”¹æ®µè½ç»“æ„ã€ä¸æ”¹è¯­ä¹‰**ã€‚

<details>
<summary><b>personas.py ä¸éœ€è¦åŠ¨çš„åœ°æ–¹</b></summary>

- **é€šç”¨æ¨¡ç‰ˆå±‚**
  - `build_universal_system_prompt(mission, dossier_view, allowed_tools, slots, extra_context)`
  - è¯´æ˜ï¼šè´Ÿè´£æŠŠä»»åŠ¡æŒ‡ä»¤ã€è¯æ®æ‘˜è¦ã€ç™½åå•ã€è§„åˆ™ã€è¾“å‡ºæ ¼å¼ã€é£æ ¼æ‹¼æˆç¨³å®šçš„ system promptã€‚
  - åŸåˆ™ï¼šä¿æŒâ€œä»»åŠ¡æ— å…³â€ï¼ˆä¸å†™ ETF ä¸“å±æœ¯è¯­ï¼Œä¸å†™æŸä¸ªè§’è‰²çš„ç»†èŠ‚ç­–ç•¥ï¼‰ã€‚

- **ç¡¬çº¦æŸæ³¨å…¥ï¼ˆæ²»ç†å±‚ï¼‰**
  - `_ENFORCED_ROLE_RULES / _ENFORCED_TOOL_POLICY`
  - è¯´æ˜ï¼šè·¨ä»»åŠ¡å®‰å…¨æŠ¤æ ï¼Œç”¨äºå‹åˆ¶ï¼š
    - è¶ŠæƒæåŠç™½åå•å¤–å·¥å…·
    - è™šæ„å·¥å…·è°ƒç”¨ç»“æœ
    - ä¸å¼•ç”¨çœŸå® ToolMessage å´å£°ç§°â€œç»“æœæ˜¾ç¤º...â€

- **è§’è‰²å·®å¼‚è½½ä½“**
  - `PromptSlots`
  - è¯´æ˜ï¼šåªæ˜¯â€œæ§½ä½ç»“æ„â€ï¼Œä¸æ‰¿æ‹…ä¸šåŠ¡æ¨ç†ï¼›å­—æ®µç¨³å®šæ„å‘³ç€è¿ç§»æˆæœ¬ä½ã€‚

- **è¾“å‡ºæ¨¡å¼å¥‘çº¦**
  - `json_only=True/False` ä¸¤åˆ†æ”¯ï¼ˆåª JSON vs Debate + Final JSONï¼‰
  - è¯´æ˜ï¼šä¿è¯ä¸Šæ¸¸ parser/renderer èƒ½ç¨³å®šåƒåˆ°ç»“æ„åŒ–è¾“å‡ºã€‚

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–é‡å†™**

ä¸‹é¢è¿™äº›å†…å®¹â€œæ€æƒ³æ˜¯é€šç”¨çš„â€ï¼Œä½†å­—æ®µã€è§„åˆ™ã€ç™½åå•ã€è¾“å‡º schema å¾€å¾€å¼ºç»‘å®šä¸šåŠ¡ã€‚è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œ**å…è®¸ä½ æ”¹å®ƒä»¬**ï¼Œä½†å»ºè®®ä¿æŒâ€œåŒä¸€é€šç”¨æ¨¡ç‰ˆ + ä¸åŒ slots å®ä¾‹åŒ–â€çš„æ¨¡å¼ä¸å˜ã€‚

- æ›¿æ¢è§’è‰² slots
  - `get_hunter_slots / get_auditor_slots / get_pm_slots`
  - æ¢ä¸šåŠ¡æ—¶ä½ å¯ä»¥æ”¹æˆï¼š
    - `analyst / reviewer / approver`
    - `triage / consult / final`
  - åªè¦ä¿è¯æ¯ä¸ª slots æ˜ç¡®ä¸‰ä»¶äº‹ï¼š
    1. è§’è‰²è¦åšä»€ä¹ˆï¼ˆ`role_goal`ï¼‰
    2. è§’è‰²å¿…é¡»éµå®ˆä»€ä¹ˆï¼ˆ`role_rules / tool_policy`ï¼‰
    3. è¾“å‡ºé•¿ä»€ä¹ˆæ ·ï¼ˆ`output_type / output_schema_hint / json_only`ï¼‰

    <details>
    <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ ETF ä¸‰è§’è‰²æ¢æˆâ€œæ–¹æ¡ˆè¯„å®¡â€ä¸‰è§’è‰²</b></summary>

    ```py
    # TODOï¼šproposal review åœºæ™¯
    def get_analyst_slots() -> PromptSlots:
        return PromptSlots(
            role_name="analyst",
            role_goal="æ•´ç†è¯æ®ï¼Œäº§å‡ºå€™é€‰æ–¹æ¡ˆä¸ä¼˜å…ˆçº§ã€‚",
            role_rules=["æ¯ä¸ªæ–¹æ¡ˆå¿…é¡»ç»™å‡º evidence æ‘˜è¦ã€‚"],
            tool_policy=["åªå¯è°ƒç”¨ç™½åå•å·¥å…·å–è¯ï¼Œä¸å¯è‡†æµ‹å¤–éƒ¨äº‹å®ã€‚"],
            output_type="PROPOSALS",
            output_schema_hint='{"proposal_id":"p1","priority":80,"reason":"...","evidence":"..."}',
            style_guide=["çŸ­å¥ã€å¯å®¡è®¡ã€é¿å…ç©ºæ³›ã€‚"],
            json_only=False,
        )
    ```

    </details>

- æ›¿æ¢ç»„åˆå™¨ï¼ˆæŠŠ slots + allowlist ç»„è£…æˆ promptï¼‰
  - build_role_prompts_etf
  - è¿ç§»æ—¶ä½ é€šå¸¸ä¼šå¤åˆ¶ä¸º build_role_prompts_xxx
  - æ¨èåœ¨ç»„åˆå™¨é‡Œç»Ÿä¸€å¤„ç†â€œä»»åŠ¡çº§å¼€å…³â€ï¼ˆé˜ˆå€¼ã€æœ€å°äº§å‡ºã€é£é™©åå¥½ï¼‰ï¼Œå†™è¿› extra_context
  
    <details>
    <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠç»„åˆå™¨æ”¹æˆ build_role_prompts_review</b></summary>

    ```py
    # TODOï¼šæŠŠä¸‰æ®µ prompt ä¸€æ¬¡æ€§æ„é€ å‡ºæ¥
    def build_role_prompts_review(mission, dossier_view, allowlist_by_role):
        analyst = build_universal_system_prompt(
            mission=mission,
            dossier_view=dossier_view,
            allowed_tools=allowlist_by_role.get("analyst", []),
            slots=get_analyst_slots(),
            extra_context="æœ¬è½®è‡³å°‘è¾“å‡º 5 ä¸ªå€™é€‰æ–¹æ¡ˆã€‚",
        )
        reviewer = ...
        approver = ...
        return {"analyst": analyst, "reviewer": reviewer, "approver": approver}
    ```

    </details>

- å¯¹é½è¾“å‡ºåè®®
  - `output_type / output_schema_hint` å¿…é¡»ä¸ `protocol/schema.py` ä¿æŒä¸€è‡´
  - å¸¸è§é—®é¢˜ï¼š
    - prompt è¦æ±‚å­—æ®µä¸ parser/renderer æœŸå¾…å­—æ®µä¸ä¸€è‡´
    - json_only æ¨¡å¼ä¸ä¸‹æ¸¸è§£æç­–ç•¥ä¸åŒ¹é…

**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
  - **ä¸åŠ¨**ï¼š`build_universal_system_prompt` çš„æ®µè½ç»“æ„ + `_ENFORCED_*` æ²»ç†è§„åˆ™ + `PromptSlots` å­—æ®µå½¢çŠ¶
  - **å¯æ¢**ï¼š`get_*_slots`ï¼ˆè§’è‰²ç›®æ ‡/è§„åˆ™/è¾“å‡ºå½¢çŠ¶/é£æ ¼ï¼‰ + `build_role_prompts_*`ï¼ˆç»„åˆä¸ä»»åŠ¡çº§å¼€å…³ï¼‰ + å„è§’è‰² allowlist
  - **å†åŠ æµ‹**ï¼šå¦‚æœä½ çš„ä¸šåŠ¡å¯¹å­—æ®µæ›´ä¸¥æ ¼ï¼ŒæŠŠæ–­è¨€åŠ åˆ° pytest

</details>

---

## å…³å¡-06ï½œæµç¨‹ç¼–æ’ Graphï¼šGraph è·³è½¬ + åœæœºè§„åˆ™

<details>
<summary><b>Checkpoint 06 â€” æµç¨‹ç¼–æ’ Graph ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³æŠŠâ€œå¤šè§’è‰²å¯¹è¯â€å‡çº§ä¸º **å¯æ§çš„æµç¨‹ç¼–æ’**ï¼š  
> ä½ å°†ç”¨ `StateGraph` æŠŠ **Hunter â†” Auditor çš„ attack/patch å¾ªç¯** ä¸²èµ·æ¥ï¼Œå¹¶åœ¨ä¸€ä¸ªç»Ÿä¸€è£å†³å™¨é‡Œå†³å®šï¼š  
> **ç»§ç»­ä¸‹ä¸€è½®**ï¼Œè¿˜æ˜¯ **æ”¶æ•›äº¤ç»™ PM å‡ºæœ€ç»ˆå†³ç­–**ã€‚  
>
> è¿™ä¸€å…³ä¸è¿½æ±‚â€œæ›´èªæ˜â€ï¼Œåªè¿½æ±‚ **æ›´å¯æ§ã€å¯åœæœºã€å¯æµ‹è¯•**ï¼š  
> - è§’è‰²è¾“å‡ºèƒ½è½è¿› stateï¼ˆcur + historyï¼‰  
> - stop_reason å¯è§£é‡Šï¼ˆä¸ºä»€ä¹ˆç»§ç»­ / ä¸ºä»€ä¹ˆåœï¼‰  
> - è§„åˆ™å¯æ’æ‹”ï¼ˆMAX_ROUNDS / MIN_CANDIDATES / CONSENSUS / STABLE ç­‰ï¼‰  
> - å·¥å…·åˆ†æ”¯ä¸æ­»å¾ªç¯ï¼ˆtool_calls æ‰èµ° tools nodeï¼‰


### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- ç†è§£å¹¶å®ç° **Graph ç¼–æ’æœ€å°é—­ç¯**ï¼š`hunter -> auditor -> (next_round | pm) -> END`
- æŠŠâ€œåœæœºè§„åˆ™â€æ”¶æ•›åˆ°ä¸€ä¸ªç»Ÿä¸€è£å†³å™¨ï¼š`_should_end_debate(state) -> "next_round" | "pm"`
- èƒ½æŠŠ LLM è¾“å‡ºï¼ˆæœ«å°¾ JSONï¼‰è§£æä¸º payloadï¼Œå¹¶è½å…¥ stateï¼š
  - `CANDIDATES -> candidates_cur + history + diff_cur`
  - `OBJECTIONS -> objections_cur + history + survivor_universe + risk_reports`
  - `DECISIONS -> decisions_cur + history`
- ç»™â€œä¸ºä»€ä¹ˆç»§ç»­/ä¸ºä»€ä¹ˆå¼ºåˆ¶â€ç•™ä¸‹å¯è¿½æº¯è½¯ trace


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ï¼š`src/debate_mas/core/graph.py`
- ä¸æ”¹ï¼šengineã€skillsã€personasã€protocol çš„æ¥å£å¥‘çº¦ï¼›ä¸å¼•å…¥æ–°ä¾èµ–
- ç›®æ ‡ä¸æ˜¯å†™æ›´å¤šèŠ‚ç‚¹ï¼Œè€Œæ˜¯ï¼š
  - **è·³è½¬é€»è¾‘ç¨³å®š**
  - **åœæœºè§„åˆ™æ¸…æ™°**


### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

**å¿…çœ‹**
- `src/debate_mas/core/graph.py`ï¼šæœ¬å…³ä¸»æ–‡ä»¶ï¼ˆæµç¨‹ç¼–æ’ + è·³è½¬ + åœæœºï¼‰
- `src/debate_mas/core/state.py`ï¼š`bump_round / push_* / bump_stable_rounds / set_need_more_candidates` ç­‰å†™è´¦æœ¬æ¥å£
- `src/debate_mas/core/config.py`ï¼š`MAX_ROUNDS / EXIT_ON_CONSENSUS / ENFORCE_MIN_CANDIDATES` ç­‰å¼€å…³æ¥æº
- `src/debate_mas/protocol/etf_debate.py`ï¼špayload è§£æä¸æ ¡éªŒï¼ˆ`try_parse_payload_with_span / validate_payload`ï¼‰
- `src/debate_mas/core/personas.py`ï¼šrole prompt ç»“æ„ï¼ˆgraph ä¼šæŠŠ system prompt ç½®é¡¶ï¼‰


#### å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰

- **Graphéª¨æ¶**ï¼š`build_etf_attack_patch_graph()` è´Ÿè´£ `hunter â†’ auditor â†’ (next_round|pm) â†’ END` çš„ä¸»å¾ªç¯ç¼–æ’  
- **è§’è‰²èŠ‚ç‚¹æŠ½è±¡**ï¼š`RoleBlock`ï¼ˆ`system_prompt / llm_invoke / tool_node / postprocess`ï¼‰ä½œä¸ºå›¾èŠ‚ç‚¹çš„æœ€å°å¥‘çº¦  
- **Systemç½®é¡¶**ï¼š`_append_system_prompt()` ä¿è¯æ¯è½® system prompt åœ¨ messages é¡¶éƒ¨ä¸”ä¸ç ´åå†å²  
- **å·¥å…·åˆ†æ”¯åˆ¤å®š**ï¼š`_last_ai_has_tool_calls()` åªåœ¨ AIMessage çœŸæœ‰ tool_calls æ—¶èµ° tools nodeï¼ˆé˜²æ­»å¾ªç¯ï¼‰  
- **PayloadæŠ½å–**ï¼š`_extract_last_payload()` æ”¯æŒ â€œDebate + æœ«å°¾ JSONâ€ ä¸ â€œçº¯ JSONâ€ ä¸¤ç§å½¢æ€  
- **Stopå»ºè®®è¯»å–**ï¼š`_get_stop_suggest()` ç»Ÿä¸€æå– `STOP/CONTINUE`ï¼ˆä¾›è£å†³å™¨ä½¿ç”¨ï¼‰  
- **åœæœºè£å†³å™¨**ï¼š`_should_end_debate()` ç»Ÿä¸€å†™å…¥ `stop_reason` å¹¶å†³å®šä¸‹ä¸€è·³ï¼ˆ`next_round` / `pm`ï¼‰  
- **è½®æ¬¡æ¨è¿›**ï¼š`next_round` èŠ‚ç‚¹é‡Œè°ƒç”¨ `bump_round()` å¹¶å®Œæˆæ¯è½® runtime é‡ç½®ï¼ˆguard/toolè®¡æ•°ç­‰ï¼‰  
- **ä¸‰æ®µè½åœ°**ï¼š`postprocess_hunter / postprocess_auditor / postprocess_pm` æŠŠ payload å†™å…¥ stateï¼ˆcur + historyï¼‰  

---

#### å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼Œè¿ç§»å¯æ›¿æ¢ï¼‰

- **Need Evidence æŠ½å–**ï¼š`_extract_need_evidence()` ä» OBJECTIONS ä¸­æå– `NEED_EVIDENCE` çš„ symbol/actions  
- **MIN_CANDIDATES å¥‘çº¦**ï¼š`_unique_candidate_count / _min_candidates_required / _min_candidates_status` åšå€™é€‰æ± è¾¾æ ‡åˆ¤å®š  
- **å€™é€‰åˆå¹¶å…¥å£**ï¼š`push_candidates_merge()`ï¼ˆstateä¾§ï¼‰+ graph çš„ hunter postprocess åˆå¹¶å†™å›  
- **Survivor Universe è®¡ç®—**ï¼š`_compute_survivor_universe()` åŸºäº objections + risk_reports åšç¡¬å‰”é™¤å¾—åˆ° U1  
- **DIFF è‡ªåŠ¨è®¡ç®—**ï¼š`_index_by_symbol / _compute_candidates_diff()` ç”Ÿæˆ ADD/UPDATE ç­‰ patchï¼ˆå†™å…¥ diff_curï¼‰  
- **è½¯Traceè§£é‡Š**ï¼š`_append_soft_trace()` ç”¨ tool_trace è®°å½•â€œä¸ºä»€ä¹ˆç»§ç»­/ä¸ºä»€ä¹ˆå¼ºåˆ¶/ä¸ºä»€ä¹ˆ diffâ€ï¼ˆéè¯æ®ä½†å¯å®¡è®¡ï¼‰  
- **å€™é€‰å­—æ®µè¡¥é½**ï¼š`_normalize_candidate_items()` ç¼ºå­—æ®µè‡ªåŠ¨è¡¥é½ï¼ˆé¿å…ä¸‹æ¸¸ parser/renderer å´©ï¼‰  
- **é£é™©æŠ¥å‘Šåˆå¹¶**ï¼š`_extract_risk_items_from_cache / _merge_risk_reports()` æŠŠ `market_sentry/forensic_detective` åˆå¹¶ä¸º risk_reports  
- **å·¥å…·ç¼“å­˜è¯»å–**ï¼š`tool_cache` è¯»å–çº¦å®šï¼ˆgraphä¾§åªè¯»ï¼‰  
- **å¼ºåˆ¶å·¥å…·è°ƒç”¨æ ‡å¿—**ï¼š`_force_hunter_tool` ä¸ `_round_missing_evidence` çš„è”åŠ¨ï¼ˆé˜²â€œè¯¥å–è¯å´æ²¡å–è¯â€ï¼‰  
- **Need More Candidates çŠ¶æ€ä½**ï¼š`set_need_more_candidates / clear_need_more_candidates`ï¼ˆstateä¾§ï¼‰+ next_round é‡Œæ‰“æ ‡/æ¸…æ ‡  

---

#### é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰

- **Two-stage Pipelineæç¤ºæ‹¼æ¥**ï¼š`_build_hunter_pipeline_sys_prompt()`ï¼ˆRECALL/RERANKï¼‰ä½œä¸º Hunter æ¯è½®é¢å¤– SystemMessage  
- **Pipelineè¾¾æ ‡åˆ¤å®š**ï¼š`_hunter_used_sniper_strategies_this_round()` + `_need_recall_diversity/_need_rerank_composite` çš„ gate  
- **Rerankæˆªæ–­**ï¼šRERANK é˜¶æ®µ `TopN` è£å‰ªï¼ˆé˜² token çˆ†ç‚¸ï¼‰ä¸ `__rerank_cutoff__` trace  
- **ç¡¬å‰”é™¤æ‰©å±•**ï¼šsurvivor_universe çš„è§„åˆ™æ‰©å±•ï¼ˆæ›´å¤š flags / æ›´å¤šé˜ˆå€¼ï¼‰  
- **æ—©åœç­–ç•¥æ‰©å±•**ï¼š`EXIT_ON_CONSENSUS / stable_rounds` ä¹‹å¤–å¢åŠ æ–°çš„ early-stop æ¡ä»¶  
- **å·¥å…·èŠ‚ç‚¹å°è£…**ï¼š`_make_tool_wrapper()` / `ToolNode` çš„è¿›ä¸€æ­¥å°è£…ï¼ˆä¾‹å¦‚ç»Ÿä¸€è®°å½• tool_traceï¼‰  
- **æ›´ä¸¥æ ¼çš„payloadæ ¡éªŒ**ï¼šå¯¹ `items` çš„ schema å­—æ®µæ›´å¼ºæ–­è¨€ï¼ˆé…åˆ tests å¢å¼ºï¼‰  


<details>
<summary><b>ğŸ“„ Checkpoint-06ï¼šcore/graph.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/core/graph.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional, Tuple

from langchain_core.messages import BaseMessage, AIMessage, SystemMessage
from langgraph.graph import StateGraph, END

from .config import CONFIG
from .state import DebateState

from debate_mas.protocol.etf_debate import try_parse_payload_with_span, validate_payload

# ============================================================
# 0) ç±»å‹ä¸å°çº¦å®š
# ============================================================

ToolRunner = Callable[[DebateState], DebateState]


@dataclass(frozen=True)
class RoleBlock:
    """
    RoleBlockï¼šæŠŠâ€œè§’è‰²èŠ‚ç‚¹â€æŠ½æˆç»Ÿä¸€ç»“æ„ï¼Œä¾¿äº graph æ‹¼è£…ä¸æµ‹è¯•ã€‚

    Args:
        role: è§’è‰²åï¼ˆå¦‚ hunter / auditor / pmï¼‰
        system_prompt: è¯¥è§’è‰²çš„ system promptï¼ˆæ¯è½®ç½®é¡¶æ³¨å…¥ï¼‰
        llm_invoke: è¾“å…¥ messagesï¼Œè¿”å› AIMessage
        tool_node: å¯é€‰ï¼›å·¥å…·èŠ‚ç‚¹ runnerï¼ˆLangGraph ToolNode æˆ–è‡ªå®šä¹‰ wrapperï¼‰
        postprocess: æœ¬è½®äº§ç‰©è½åœ°åˆ° state çš„å‡½æ•°ï¼ˆå†™ cur + history + stop_suggest ç­‰ï¼‰

    Returns:
        None
    """
    role: str
    system_prompt: str
    llm_invoke: Callable[[List[BaseMessage]], AIMessage]
    tool_node: Optional[ToolRunner]
    postprocess: Callable[[DebateState], None]


# ============================================================
# 1) é€šç”¨ï¼šsystem prompt ç½®é¡¶ + tool_calls è·¯ç”±
# ============================================================

def _append_system_prompt(messages: List[BaseMessage], system_prompt: str) -> List[BaseMessage]:
    """
    æŠŠ system prompt ç½®é¡¶ï¼Œä¸æ”¹å˜åŸ messages çš„é¡ºåºã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - è¿”å›: [SystemMessage(system_prompt)] + (messages or [])

    Args:
        messages: åŸå¯¹è¯å†å²
        system_prompt: system prompt æ–‡æœ¬

    Returns:
        æ–°çš„ messages åˆ—è¡¨
    """
    # TODO
    raise NotImplementedError


def _last_ai_has_tool_calls(state: DebateState) -> bool:
    """
    åˆ¤æ–­æœ€è¿‘ä¸€æ¡ AIMessage æ˜¯å¦åŒ…å« tool_callsï¼ˆå†³å®šèµ° tools node è¿˜æ˜¯ç›´æ¥ postprocessï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - ä» state["messages"] é€†åºæ‰¾ç¬¬ä¸€æ¡ AIMessage
        - å…¼å®¹ä¸¤ç§å­˜æ”¾ä½ç½®ï¼š
          1) getattr(m, "tool_calls", None)
          2) getattr(m, "additional_kwargs", {}).get("tool_calls")
        - æ‰¾åˆ° AIMessage åç«‹å³è¿”å› True/False
        - è‹¥æ²¡æœ‰ AIMessageï¼Œè¿”å› False

    Args:
        state: DebateState

    Returns:
        æ˜¯å¦å­˜åœ¨ tool_calls
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 2) payload æŠ½å–ï¼šæ”¯æŒâ€œè¾©è®ºæ–‡å­— + æœ«å°¾ JSONâ€
# ============================================================

def _extract_last_payload(state: DebateState, *, expected_type: str) -> Optional[Dict[str, Any]]:
    """
    ä»æœ€è¿‘çš„ AIMessage ä¸­æŠ½å–æœ«å°¾ JSON payloadï¼ˆé€šè¿‡åè®®å±‚è§£æ + æ ¡éªŒï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - é€†åºéå† messagesï¼Œåªçœ‹ AIMessage
        - obj, _span = try_parse_payload_with_span(m.content)
        - validate_payload(obj) é€šè¿‡åæ‰ç®—æˆåŠŸ
        - obj["type"].upper() == expected_type æ‰è¿”å› obj
        - å¦åˆ™ç»§ç»­å‘å‰æ‰¾
        - å…¨éƒ¨å¤±è´¥è¿”å› None

    Args:
        state: DebateState
        expected_type: æœŸæœ›ç±»å‹ï¼ˆå¦‚ "CANDIDATES" / "OBJECTIONS" / "DECISIONS"ï¼‰

    Returns:
        payload dict æˆ– None
    """
    # TODO
    raise NotImplementedError


def _get_stop_suggest(obj: Optional[Dict[str, Any]]) -> str:
    """
    è¯»å– stop_suggestï¼Œç»Ÿä¸€ä¸ºå¤§å†™ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - (obj or {}).get("stop_suggest", "")
        - strip + upper

    Args:
        obj: payload æˆ– None

    Returns:
        stop_suggestï¼ˆ"STOP"/"CONTINUE"/""ï¼‰
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 3) ETFä»»åŠ¡ï¼šNeed Evidence / MIN_CANDIDATES / Pipeline è¾…åŠ©
# ============================================================

def _extract_need_evidence(objections: List[Dict[str, Any]]) -> Tuple[bool, List[str], List[str]]:
    """
    ä» objections ä¸­æŠ½å– NEED_EVIDENCE çš„æ ‡å¿—ä½ + è¯æ®è¦æ±‚é›†åˆã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - éå† objections:
          - verdict == "NEED_EVIDENCE" -> need=True
          - æ”¶é›† symbolï¼ˆå»é‡ä¿åºï¼‰
          - æ”¶é›† required_actionsï¼ˆå»é‡ä¿åºï¼‰
        - è¿”å› (need, syms, actions)

    Args:
        objections: OBJECTIONS.items

    Returns:
        need: æ˜¯å¦éœ€è¦è¡¥è¯æ®
        syms: éœ€è¦è¡¥è¯æ®çš„ symbol åˆ—è¡¨ï¼ˆå»é‡ä¿åºï¼‰
        actions: required_actions åˆ—è¡¨ï¼ˆå»é‡ä¿åºï¼‰
    """
    # TODO
    raise NotImplementedError


def _unique_candidate_count(items: List[Dict[str, Any]]) -> int:
    """
    ç»Ÿè®¡ candidates.items çš„ unique symbol æ•°é‡ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - ä»¥ symbol å»é‡è®¡æ•°ï¼ˆstrip åéç©ºï¼‰

    Args:
        items: candidates list

    Returns:
        unique symbol count
    """
    # TODO
    raise NotImplementedError


def _min_candidates_required() -> int:
    """
    ä» CONFIG è¯»å–æœ€å°å€™é€‰æ•°è¦æ±‚ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - è‹¥ CONFIG.ENFORCE_MIN_CANDIDATES ä¸º False -> 0
        - å¦åˆ™è¿”å› int(CONFIG.HUNTER_MIN_CANDIDATES or 0)

    Args:
        None

    Returns:
        MIN_CANDIDATES
    """
    # TODO
    raise NotImplementedError


def _min_candidates_status(state: DebateState) -> Tuple[int, int, int]:
    """
    æ±‡æ€» MIN_CANDIDATES çŠ¶æ€ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - mn = _min_candidates_required()
        - have = _unique_candidate_count(state["candidates_cur"])
        - missing = max(0, mn - have)

    Args:
        state: DebateState

    Returns:
        mn: æœ€å°è¦æ±‚
        have: å½“å‰ unique æ•°
        missing: è¿˜å·®å¤šå°‘
    """
    # TODO
    raise NotImplementedError


def _hunter_used_sniper_strategies_this_round(state: DebateState) -> List[str]:
    """
    è¯»å– hunter æœ¬è½®ä½¿ç”¨è¿‡çš„å¬å›ç­–ç•¥åˆ—è¡¨ï¼ˆå»é‡ä¿åºï¼‰ã€‚

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
        - ç›´æ¥è¯» state["_hunter_round_sniper_strategies"]
        - strip + å»é‡ä¿åº

    Args:
        state: DebateState

    Returns:
        strategies: æœ¬è½®ç­–ç•¥åˆ—è¡¨
    """
    # TODO
    raise NotImplementedError


def _compute_survivor_universe(state: DebateState) -> List[str]:
    """
    è®¡ç®—å­˜æ´»æ±  survivor_universeï¼ˆU1ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - åŸºäº candidates_cur çš„ symbol
        - å‰”é™¤ objections_cur ä¸­ verdict == "REJECT"
        - å‰”é™¤ risk_reports ä¸­ liquidity_flag == "illiquid"
        - å‰”é™¤ risk_score >= CONFIG.RISK_SCORE_THRESHOLD
        - ä¿æŒå»é‡ä¿åº

    Args:
        state: DebateState

    Returns:
        survivor_universe: å­˜æ´»æ±  symbol åˆ—è¡¨
    """
    # TODO
    raise NotImplementedError


def _index_by_symbol(items: List[Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    """
    æŠŠ items æŒ‰ symbol ç´¢å¼•æˆ dictã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - å¿½ç•¥ symbol ä¸ºç©ºçš„æ¡ç›®
        - åå†™è¦†ç›–å‰å†™ï¼ˆä»¥â€œæœ€æ–°â€ä¸ºå‡†ï¼‰

    Args:
        items: list[dict]

    Returns:
        symbol -> item
    """
    # TODO
    raise NotImplementedError


def _compute_candidates_diff(prev_items: List[Dict[str, Any]], cur_items: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    è®¡ç®— DIFFï¼ˆç³»ç»Ÿè‡ªåŠ¨ç®—ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - æ–°å¢ï¼šcur_syms - prev_syms -> {"op":"ADD","symbol":...}
        - åŒæ ‡çš„å˜æ›´ï¼ˆè½»é‡å³å¯ï¼‰ï¼š
          - score å˜åŒ– -> SCORE_UPDATE
          - reason å˜åŒ– -> REASON_UPDATE
        - è¿”å› {"type":"DIFF","items":[...patches...]}

    Args:
        prev_items: ä¸Šä¸€ç‰ˆå€™é€‰
        cur_items: å½“å‰å€™é€‰

    Returns:
        diff_obj: DIFF payload
    """
    # TODO
    raise NotImplementedError


def _append_soft_trace(
    state: DebateState,
    *,
    role: str,
    tool: str,
    insight: str,
    args: Optional[Dict[str, Any]] = None,
    ok: bool = True,
) -> None:
    """
    å†™å…¥è½¯ traceï¼ˆè§£é‡Šâ€œä¸ºä»€ä¹ˆç»§ç»­/ä¸ºä»€ä¹ˆå¼ºåˆ¶/ä¸ºä»€ä¹ˆ diffâ€ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - state.setdefault("tool_trace", [])
        - append ä¸€æ¡ dictï¼ˆè‡³å°‘åŒ…å« kind/role/tool/args/ok/round_idx/insight ç­‰ç¨³å®šå­—æ®µï¼‰

    Args:
        state: DebateState
        role: "system"/"hunter"/"auditor"/"pm"
        tool: trace åç§°ï¼ˆå¦‚ "__diff__"ï¼‰
        insight: ä¸€å¥è¯è§£é‡Š
        args: å¯é€‰å‚æ•°å¿«ç…§
        ok: æ˜¯å¦ ok

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


def _make_tool_wrapper(tool_node: ToolRunner) -> ToolRunner:
    """
    å·¥å…·èŠ‚ç‚¹ wrapperï¼šç»Ÿä¸€æˆ (state)->state çš„ç­¾åã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - ç›´æ¥ return tool_node(state)

    Args:
        tool_node: å·¥å…· runner

    Returns:
        wrapper: ToolRunner
    """
    # TODO
    raise NotImplementedError


def _build_hunter_pipeline_sys_prompt(state: DebateState) -> Optional[str]:
    """
    Two-stage pipeline çš„ hunter sys prompt æ‹¼æ¥ï¼ˆRECALL / RERANKï¼‰ã€‚

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
        - è‹¥ CONFIG.HUNTER_DETERMINISTIC_PIPELINE=False -> None
        - è‹¥ CONFIG.HUNTER_PIPELINE_MODE != "two_stage" -> None
        - è¯» state["_hunter_pipeline_stage"]ï¼ˆé»˜è®¤ recallï¼‰
        - recall: æç¤º multi-strategy recallï¼ˆmin_strats/topk_eachï¼‰
        - rerank: æç¤º composite rerankï¼ˆuniverse=survivor_universeï¼‰

    Args:
        state: DebateState

    Returns:
        sys_prompt æˆ– None
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 4) postprocessï¼šæŠŠâ€œæœ¬è½®äº§ç‰©â€å†™å…¥ stateï¼ˆcur + historyï¼‰
# ============================================================

def _normalize_candidate_items(
    items: List[Dict[str, Any]],
    prev_by_sym: Dict[str, Dict[str, Any]],
) -> Tuple[List[Dict[str, Any]], int]:
    """
    è½»é‡è§„èŒƒåŒ–ï¼šç¼ºå­—æ®µè¡¥é½ï¼ˆé¿å…ä¸‹æ¸¸å´©æºƒï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - symbol ä¸ºç©º -> ä¸¢å¼ƒ
        - ç¼º score/reason/source_skill/extra æ—¶ï¼Œç”¨ prev_by_sym[symbol] çš„æ—§å€¼è¡¥é½
        - extra ä¸æ˜¯ dict æ—¶è½¬æˆ dict åŒ…èµ·æ¥
        - è¿”å› (norm_items, autofill_count)

    Args:
        items: åŸå§‹å€™é€‰ items
        prev_by_sym: ä¸Šä¸€è½®å€™é€‰ç´¢å¼•

    Returns:
        norm_items: è§„èŒƒåŒ–å€™é€‰
        autofill_count: è‡ªåŠ¨è¡¥é½å­—æ®µæ¬¡æ•°
    """
    # TODO
    raise NotImplementedError


def postprocess_hunter(state: DebateState) -> None:
    """
    Hunter çš„ postprocessï¼šè½åœ° CANDIDATES + è®¡ç®— DIFF + å†™ stop_suggest + pipeline gateã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - obj = _extract_last_payload(expected_type="CANDIDATES")
        - items å¿…é¡»æ˜¯ listï¼Œå¦åˆ™ return
        - push_candidates_merge(state, norm_items)
        - push_diff(state, diff_obj)
        - state["hunter_stop_suggest"] = _get_stop_suggest(obj)
        - _append_soft_trace(...) è®°å½•å…³é”®è§£é‡Š

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - MIN_CANDIDATES è¾¾æ ‡æ—¶æ¸…ç† need_more_candidates
        - å¦‚ state["_force_hunter_tool"] ä¸º True ä¸”æœ¬è½®æ— æœ‰æ•ˆå·¥å…·è°ƒç”¨ -> æ ‡è®° _round_missing_evidence + å¼ºåˆ¶ CONTINUE

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
        - two-stage pipelineï¼š
          - recallï¼šæ£€æŸ¥ç­–ç•¥å¤šæ ·æ€§ï¼Œä¸è¾¾æ ‡åˆ™ _need_recall_diversity=True
          - rerankï¼šæ£€æŸ¥ compositeï¼Œä¸è¾¾æ ‡åˆ™ _need_rerank_composite=True
        - rerank é˜¶æ®µ TopN æˆªæ–­ + trace

    Args:
        state: DebateState

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


def _extract_risk_items_from_cache(state: DebateState, tool_name: str) -> List[Dict[str, Any]]:
    """
    ä» tool_cache ä¸­æŠ½å–æŸå·¥å…·çš„ items åˆ—è¡¨ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - cache = state["tool_cache"].get(tool_name)
        - cache["data"]["items"] è‹¥å­˜åœ¨ä¸”æ˜¯ list åˆ™è¿”å›ï¼Œå¦åˆ™ []

    Args:
        state: DebateState
        tool_name: å·¥å…·åï¼ˆå¦‚ "market_sentry"ï¼‰

    Returns:
        items: list[dict]
    """
    # TODO
    raise NotImplementedError


def _merge_risk_reports(*lists: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    åˆå¹¶å¤šä¸ªé£é™©æŠ¥å‘Šåˆ—è¡¨ï¼ˆæŒ‰ symbol åˆå¹¶ã€é£é™©ç´¯åŠ ã€flag å–æ›´ä¸¥é‡ã€notes å»é‡ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - symbol ä½œä¸ºä¸»é”®
        - risk_score ç´¯åŠ å¹¶ cap åˆ° 100
        - liquidity_flag: ok < illiquidï¼ˆå–æ›´ä¸¥é‡ï¼‰
        - sentiment_flag: normal < negativeï¼ˆå–æ›´ä¸¥é‡ï¼‰
        - notes å»é‡ä¿åº
        - æœ€ç»ˆæŒ‰ risk_score desc æ’åº

    Args:
        *lists: å¤šä¸ªé£é™© items åˆ—è¡¨

    Returns:
        merged: åˆå¹¶åçš„é£é™©æŠ¥å‘Š
    """
    # TODO
    raise NotImplementedError


def postprocess_auditor(state: DebateState) -> None:
    """
    Auditor çš„ postprocessï¼šè½åœ° OBJECTIONS + åˆå¹¶é£é™©æŠ¥å‘Š + è®¡ç®— survivor_universe + bump_stable_roundsã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - obj = _extract_last_payload(expected_type="OBJECTIONS")
        - push_objections(state, items)
        - state["auditor_stop_suggest"] = _get_stop_suggest(obj)
        - _append_soft_trace(...) è®°å½•è¾“å‡º

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - ä» tool_cache æŠ½ market_sentry / forensic_detective é£é™© items
        - state["risk_reports"] = _merge_risk_reports(...)
        - prev_u1 = survivor_universeï¼ˆç”¨äº diff REMOVE patchï¼‰
        - state["survivor_universe"] = _compute_survivor_universe(state)
        - removed -> è¿½åŠ  hard REMOVE patches åˆ° diff_cur å¹¶ push_diff
        - bump_stable_rounds(state)
        - need_evidence: state["_need_evidence"], symbols, actions

    Args:
        state: DebateState

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


def postprocess_pm(state: DebateState) -> None:
    """
    PM çš„ postprocessï¼šè½åœ° DECISIONS + å†™ stop_suggestã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - obj = _extract_last_payload(expected_type="DECISIONS")
        - push_decisions(state, items)
        - state["pm_stop_suggest"] = _get_stop_suggest(obj)
        - _append_soft_trace(...) è®°å½•è¾“å‡º

    Args:
        state: DebateState

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 5) judgeï¼šå†³å®šä¸‹ä¸€æ­¥èµ°å‘ï¼ˆattack/patch çš„æ”¶æ•›è§„åˆ™ï¼‰
# ============================================================

def _should_end_debate(state: DebateState) -> str:
    """
    æ”¶æ•›è£å†³å™¨ï¼šå†³å®šèµ° next_round è¿˜æ˜¯ pmï¼Œå¹¶å†™ stop_reasonã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - MAX_ROUNDSï¼šåˆ°ä¸Šé™ -> stop_reason="MAX_ROUNDS_DEBATE" -> "pm"
        - guard deniedï¼š_round_guard_denied -> stop_reason="GUARD_DENIED" -> "next_round"
        - å…±è¯†åœæœºï¼ˆå¯æ§å¼€å…³ï¼‰ï¼šEXIT_ON_CONSENSUS + hunter/auditor éƒ½ STOP -> "pm"
        - ç¨³å®šåœæœºï¼ˆå¯æ§é˜ˆå€¼ï¼‰ï¼šstable_rounds è¾¾æ ‡ + auditor STOP -> "pm"
        - é»˜è®¤ï¼šstop_reason="CONTINUE_DEBATE" -> "next_round"

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - MIN_CANDIDATES gateï¼šä¸è¾¾æ ‡ -> stop_reason="MIN_CANDIDATES_NOT_MET" -> "next_round"
        - pipeline gateï¼š
          - _need_recall_diversity -> stop_reason="PIPELINE_RECALL_DIVERSITY_NOT_MET" -> "next_round"
          - _need_rerank_composite -> stop_reason="PIPELINE_RERANK_NOT_MET" -> "next_round"

    Args:
        state: DebateState

    Returns:
        next: "next_round" or "pm"
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 6) Graphï¼šHunter â†” Auditorï¼ˆattack/patchï¼‰â†’ PM
# ============================================================

def build_etf_attack_patch_graph(*, hunter: RoleBlock, auditor: RoleBlock, pm: RoleBlock) -> Any:
    """
    æ„å»º LangGraph ä¸»å›¾ï¼šhunter -> auditor -> (next_round | pm) -> ENDã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
        - g = StateGraph(DebateState)
        - add_role(rb):
          - åˆ›å»º {role}_agent / {role}_tools / {role}_postprocess ä¸‰èŠ‚ç‚¹
          - agent èŠ‚ç‚¹ï¼šæ³¨å…¥ system promptã€è°ƒç”¨ llmã€append AIMessageã€å†™ phase/_last_speaker_role
          - tools åˆ†æ”¯ï¼š_last_ai_has_tool_calls å†³å®š tools æˆ– post
          - tools -> agent å›è¾¹ï¼ˆå…è®¸å¤šæ¬¡å·¥å…·è°ƒç”¨ï¼‰
          - agent -> postprocess è¾¹ï¼ˆæ— å·¥å…·æ—¶ç›´è¾¾ï¼‰
        - hunter_post -> auditor_agent
        - auditor_post -> conditional(_should_end_debate) -> {next_round, pm}
        - pm_post -> END
        - entry_point = hunter_agent
        - return g.compile()

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
        - next_round èŠ‚ç‚¹ï¼š
          - bump_round(state)
          - MIN_CANDIDATES ä¸è¶³æ—¶ set_need_more_candidates + trace
          - å¦åˆ™ clear_need_more_candidates
          - need_evidence / guard_denied / pipeline_fix -> è®¾ç½® state["_force_hunter_tool"]
          - two-stage pipelineï¼šæŒ‰ need_more / diversity ç­‰æ¨è¿› stageï¼ˆrecall / rerankï¼‰
          - è¿½åŠ è§£é‡Šæ€§ trace

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
        - auditor å¼ºåˆ¶å·¥å…·è°ƒç”¨æç¤ºï¼ˆé¢å¤– SystemMessageï¼‰
        - hunter Two-stage sys_prompt æ³¨å…¥ï¼ˆ_build_hunter_pipeline_sys_promptï¼‰
        - æ›´ä¸¥æ ¼çš„å›¾èŠ‚ç‚¹å‘½åä¸å¯è§†åŒ– debug æ ‡è®°

    Args:
        hunter: hunter RoleBlock
        auditor: auditor RoleBlock
        pm: pm RoleBlock

    Returns:
        compiled_graph: å¯ invoke/stream çš„ LangGraph å›¾å¯¹è±¡
    """
    # TODO
    raise NotImplementedError
```

</details>


### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_graph.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_graph.py</b></summary>

   ```py
    import json
    import re
    from types import SimpleNamespace

    import pytest
    from langchain_core.messages import AIMessage, HumanMessage

    from debate_mas.core import graph as g


    def _patch_config(monkeypatch: pytest.MonkeyPatch, **overrides) -> None:
        """ç›´æ¥ monkeypatch æ¨¡å—å˜é‡ g.CONFIG ä¸ºä¸€ä¸ªå¯å˜å¯¹è±¡ï¼ˆstubï¼‰ã€‚"""
        cfg = SimpleNamespace(
            MAX_ROUNDS=3,
            EXIT_ON_CONSENSUS=True,

            ENFORCE_MIN_CANDIDATES=False,
            HUNTER_MIN_CANDIDATES=0,

            HUNTER_DETERMINISTIC_PIPELINE=True,
            HUNTER_PIPELINE_MODE="two_stage",
            HUNTER_RECALL_STRATEGIES=["momentum", "liquidity", "composite"],
            HUNTER_RECALL_MIN_STRATEGIES=2,
            HUNTER_RECALL_TOPK_PER_STRATEGY=10,
            HUNTER_RERANK_OUTPUT_TOPN=20,

            RISK_SCORE_THRESHOLD=50.0,

            ENFORCE_TOOL_ON_NEED_EVIDENCE=True,
        )
        for k, v in overrides.items():
            setattr(cfg, k, v)

        monkeypatch.setattr(g, "CONFIG", cfg, raising=True)

    def _patch_protocol(monkeypatch: pytest.MonkeyPatch) -> None:
        """
        æŠŠåè®®å±‚è§£æ/æ ¡éªŒ monkeypatch æˆâ€œå¯æ§ä¸”ç¨³å®šâ€çš„ç‰ˆæœ¬ï¼Œ
        è®©æœ¬å…³æµ‹è¯•èšç„¦åœ¨ graph ç¼–æ’ä¸çŠ¶æ€æœºé€»è¾‘ï¼Œè€Œä¸æ˜¯ JSON schema ç»†èŠ‚ã€‚
        """
        def fake_parse(text: str):
            m = re.search(r"(\{.*\})\s*$", text, re.S)
            if not m:
                return None, -1
            try:
                return json.loads(m.group(1)), m.start(1)
            except Exception:
                return None, -1

        def fake_validate(_obj):
            return None

        monkeypatch.setattr(g, "try_parse_payload_with_span", fake_parse, raising=True)
        monkeypatch.setattr(g, "validate_payload", fake_validate, raising=True)


    def _mk_ai(payload: dict) -> AIMessage:
        return AIMessage(content=json.dumps(payload, ensure_ascii=False))

    def test_append_system_prompt_prepends_and_keeps_history_order():
        msgs = [HumanMessage(content="hi"), AIMessage(content="hello")]
        out = g._append_system_prompt(msgs, system_prompt="SYS")
        assert out[0].content == "SYS"
        assert [m.content for m in out[1:]] == ["hi", "hello"]


    def test_last_ai_has_tool_calls_detects_both_storage_styles():
        state = {"messages": [AIMessage(content="x")]}
        assert g._last_ai_has_tool_calls(state) is False

        state = {
            "messages": [
                AIMessage(
                    content="x",
                    additional_kwargs={
                        "tool_calls": [
                            {"id": "1", "type": "function", "function": {"name": "foo", "arguments": "{}"}}
                        ]
                    },
                )
            ]
        }
        assert g._last_ai_has_tool_calls(state) is True

        m = AIMessage(content="x")
        setattr(m, "tool_calls", [{"name": "bar"}])
        state = {"messages": [m]}
        assert g._last_ai_has_tool_calls(state) is True


    def test_get_stop_suggest_uppercase_and_strip():
        assert g._get_stop_suggest({"stop_suggest": " stop "}) == "STOP"
        assert g._get_stop_suggest({"stop_suggest": "continue"}) == "CONTINUE"
        assert g._get_stop_suggest(None) == ""


    def test_extract_last_payload_supports_debate_plus_tail_json(monkeypatch: pytest.MonkeyPatch):
        _patch_protocol(monkeypatch)

        payload = {"type": "CANDIDATES", "stop_suggest": "STOP", "items": []}
        msg = AIMessage(content="some debate...\n" + json.dumps(payload, ensure_ascii=False))
        state = {"messages": [msg]}

        out = g._extract_last_payload(state, expected_type="CANDIDATES")
        assert out is not None
        assert out["type"] == "CANDIDATES"


    def test_should_end_debate_max_rounds_go_pm(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=2, ENFORCE_MIN_CANDIDATES=False)

        state = {"round_idx": 1, "stable_rounds": 0, "messages": []}
        nxt = g._should_end_debate(state)
        assert nxt == "pm"
        assert state.get("stop_reason") == "MAX_ROUNDS_DEBATE"


    def test_should_end_debate_guard_denied_forces_next_round(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=99, ENFORCE_MIN_CANDIDATES=False)

        state = {"round_idx": 0, "_round_guard_denied": True, "messages": []}
        nxt = g._should_end_debate(state)
        assert nxt == "next_round"
        assert state.get("stop_reason") == "GUARD_DENIED"


    def test_should_end_debate_min_candidates_gate(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=99, ENFORCE_MIN_CANDIDATES=True, HUNTER_MIN_CANDIDATES=3)

        state = {
            "round_idx": 0,
            "messages": [],
            "candidates_cur": [{"symbol": "510300"}, {"symbol": "510500"}],  # unique=2 < 3
            "hunter_stop_suggest": "STOP",
            "auditor_stop_suggest": "STOP",
        }
        nxt = g._should_end_debate(state)
        assert nxt == "next_round"
        assert state.get("stop_reason") == "MIN_CANDIDATES_NOT_MET"


    def test_should_end_debate_pipeline_gates(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=99, ENFORCE_MIN_CANDIDATES=False)

        s1 = {"round_idx": 0, "_need_recall_diversity": True, "messages": []}
        assert g._should_end_debate(s1) == "next_round"
        assert s1["stop_reason"] == "PIPELINE_RECALL_DIVERSITY_NOT_MET"

        s2 = {"round_idx": 0, "_need_rerank_composite": True, "messages": []}
        assert g._should_end_debate(s2) == "next_round"
        assert s2["stop_reason"] == "PIPELINE_RERANK_NOT_MET"


    def test_should_end_debate_consensus_stop(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=99, EXIT_ON_CONSENSUS=True, ENFORCE_MIN_CANDIDATES=False)

        state = {
            "round_idx": 0,
            "messages": [],
            "hunter_stop_suggest": "STOP",
            "auditor_stop_suggest": "STOP",
            "stable_rounds": 0,
        }
        nxt = g._should_end_debate(state)
        assert nxt == "pm"
        assert state.get("stop_reason") == "CONSENSUS_STOP"


    def test_should_end_debate_stable_and_auditor_stop(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=99, EXIT_ON_CONSENSUS=False, ENFORCE_MIN_CANDIDATES=False)

        state = {
            "round_idx": 0,
            "messages": [],
            "hunter_stop_suggest": "CONTINUE",
            "auditor_stop_suggest": "STOP",
            "stable_rounds": 1,
        }
        nxt = g._should_end_debate(state)
        assert nxt == "pm"
        assert state.get("stop_reason") == "STABLE_AND_AUDITOR_STOP"


    def test_should_end_debate_default_continue(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, MAX_ROUNDS=99, EXIT_ON_CONSENSUS=True, ENFORCE_MIN_CANDIDATES=False)

        state = {
            "round_idx": 0,
            "messages": [],
            "hunter_stop_suggest": "CONTINUE",
            "auditor_stop_suggest": "CONTINUE",
            "stable_rounds": 0,
        }
        nxt = g._should_end_debate(state)
        assert nxt == "next_round"
        assert state.get("stop_reason") == "CONTINUE_DEBATE"


    def test_graph_compiles_and_runs_one_cycle(monkeypatch: pytest.MonkeyPatch):
        """
        æœ€å°ç«¯åˆ°ç«¯ï¼šèƒ½ compile + invokeï¼Œä¸”èµ°å®Œ hunter->auditor->pmã€‚
        ä¸æ ¡éªŒä¸šåŠ¡å­—æ®µï¼Œåªæ ¡éªŒâ€œä¸»å¾ªç¯èƒ½è·‘é€š + stop_reason å†™å…¥â€ã€‚
        """
        _patch_protocol(monkeypatch)
        _patch_config(monkeypatch, MAX_ROUNDS=1, ENFORCE_MIN_CANDIDATES=False)

        hunter_rb = g.RoleBlock(
            role="hunter",
            system_prompt="HUNTER_SYS",
            llm_invoke=lambda _msgs: _mk_ai(
                {
                    "type": "CANDIDATES",
                    "stop_suggest": "STOP",
                    "items": [
                        {"symbol": "510300", "score": 80.0, "reason": "x", "source_skill": "demo", "extra": {}}
                    ],
                }
            ),
            tool_node=None,
            postprocess=g.postprocess_hunter,
        )

        auditor_rb = g.RoleBlock(
            role="auditor",
            system_prompt="AUDITOR_SYS",
            llm_invoke=lambda _msgs: _mk_ai({"type": "OBJECTIONS", "stop_suggest": "STOP", "items": []}),
            tool_node=None,
            postprocess=g.postprocess_auditor,
        )

        pm_rb = g.RoleBlock(
            role="pm",
            system_prompt="PM_SYS",
            llm_invoke=lambda _msgs: _mk_ai({"type": "DECISIONS", "stop_suggest": "STOP", "items": []}),
            tool_node=None,
            postprocess=g.postprocess_pm,
        )

        graph = g.build_etf_attack_patch_graph(hunter=hunter_rb, auditor=auditor_rb, pm=pm_rb)

        init_state = {
            "messages": [],
            "round_idx": 0,
            "stable_rounds": 0,
            "tool_trace": [],
            "tool_cache": {},
            "candidates_cur": [],
            "objections_cur": [],
            "diff_cur": {"type": "DIFF", "items": []},
            "risk_reports": [],
            "survivor_universe": [],
            "_round_tool_calls_ok": {},
            "_hunter_round_sniper_strategies": [],
        }

        out = graph.invoke(init_state)

        assert out.get("_last_speaker_role") == "pm"

        assert out.get("round_idx") == 0

        assert any(it.get("symbol") == "510300" for it in (out.get("candidates_cur") or []))

        ai_n = len([m for m in (out.get("messages") or []) if isinstance(m, AIMessage)])
        assert ai_n >= 3

        assert out.get("stop_reason") in (None, "MAX_ROUNDS_DEBATE")

   ```

   </details>

2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_graph.py
```


### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰
  - `12 passed in ...s`
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`FrozenInstanceError`ã€`KeyError`ã€`AssertionError`
- å¦‚æœå¤±è´¥ï¼Œä½ åº”è¯¥èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°ä¸‰ç±»é—®é¢˜ï¼š
  - **é…ç½®ä¸å¯ patchï¼ˆå†»ç»“å¯¹è±¡ï¼‰**  
    - æŠ¥é”™å½¢æ€ï¼š`dataclasses.FrozenInstanceError: cannot assign to field 'MAX_ROUNDS'`
    - è¯´æ˜ï¼šæµ‹è¯•é‡Œä¸åº”å†ç›´æ¥ `monkeypatch.setattr(CONFIG, ...)`ï¼›éœ€è¦ç”¨â€œé…ç½®è¯»å–å‡½æ•°/åŒ…è£…å™¨â€æˆ–åœ¨æµ‹è¯•é‡Œ patch graph æ¨¡å—å†…éƒ¨è¯»å–å£ï¼ˆä½ ç°åœ¨çš„ test_graph å·²ç»è¿™ä¹ˆåšäº†ï¼‰ã€‚
  - **Graph ä¸»å¾ªç¯æ²¡æŒ‰é¢„æœŸé—­ç¯**  
    - æŠ¥é”™å½¢æ€ï¼šç«¯åˆ°ç«¯æ–­è¨€ä¸é€šè¿‡ï¼ˆä¾‹å¦‚ `_last_speaker_role != "pm"`ã€`round_idx` æ„å¤–å˜åŒ–ï¼‰
    - è¯´æ˜ï¼šå¤šåŠæ˜¯è¾¹æ²¡è¿å¯¹ï¼ˆ`hunter_post -> auditor_agent`ã€`auditor_post -> (next_round|pm)`ã€`pm_post -> END`ï¼‰ï¼Œæˆ– tools åˆ†æ”¯å¯¼è‡´å›è¾¹ä¸æ­£ç¡®ã€‚
  - **è·¯ç”±å‡½æ•°å‰¯ä½œç”¨ä¸å›å†™**  
    - æŠ¥é”™å½¢æ€ï¼šç«¯åˆ°ç«¯é‡Œ `stop_reason is None`
    - è¯´æ˜ï¼š`_should_end_debate` ä½œä¸º conditional route åœ¨éƒ¨åˆ† LangGraph ç‰ˆæœ¬é‡Œä¸ä¼šæŠŠâ€œå¯¹ state çš„å°±åœ°å†™å…¥â€åˆå¹¶å›æœ€ç»ˆè¾“å‡ºã€‚  
      å¤„ç†ï¼šç«¯åˆ°ç«¯æµ‹è¯•ä¸è¦å¼ºä¾èµ– `stop_reason`ï¼›`stop_reason` çš„æ­£ç¡®æ€§ç”± `_should_end_debate_*` å•æµ‹è¦†ç›–ã€‚


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `core/graph.py` è®¾è®¡ç›®æ ‡æ˜¯ï¼š**å›¾ç¼–æ’ï¼ˆGraphï¼‰ç¨³å®šã€ä¸šåŠ¡å¯¹è±¡ï¼ˆETFï¼‰å¯æ›¿æ¢**ã€‚è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ ä¸éœ€è¦é‡å†™ Debate MASï¼Œåªè¦æŠŠâ€œä¸šåŠ¡ postprocess + payload ç±»å‹ + gate è§„åˆ™â€æ›¿æ¢æ‰ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

è¿™äº›æ˜¯ä»»ä½• â€œå¤šè§’è‰² attack/patch â†’ æ”¶æ•› â†’ æœ€ç»ˆå†³ç­–â€ å›¾éƒ½ç¦»ä¸å¼€çš„éª¨æ¶,è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡æ—¶ï¼Œå»ºè®®ä¿æŒç»“æ„ä¸å˜ã€‚

<details>
<summary><b>graph.py ä¸éœ€è¦åŠ¨çš„åœ°æ–¹</b></summary>

- **Graph ä¸»å¾ªç¯éª¨æ¶**
  - `build_*_graph()`ï¼šè´Ÿè´£ `roleA â†’ roleB â†’ (next_round | final_role) â†’ END` çš„ç¼–æ’
  - åŸåˆ™ï¼šèŠ‚ç‚¹å‘½åä¸è¿è¾¹ç¨³å®šï¼Œä¾¿äºæµ‹è¯•ä¸ debug

- **è§’è‰²èŠ‚ç‚¹æŠ½è±¡**
  - `RoleBlock(role/system_prompt/llm_invoke/tool_node/postprocess)`
  - åŸåˆ™ï¼šæŠŠâ€œè§’è‰²å·®å¼‚â€éƒ½å¡è¿› RoleBlockï¼Œgraph åªè´Ÿè´£æ‹¼è£…

- **system ç½®é¡¶ä¸ tools è·¯ç”±**
  - `_append_system_prompt()`ï¼šæ¯è½®æŠŠ system prompt ç½®é¡¶
  - `_last_ai_has_tool_calls()`ï¼šä¸¥æ ¼åˆ¤å®šæ‰èµ° toolsï¼Œé¿å…æ­»å¾ªç¯

- **payload æŠ½å– + stop_suggest è¯»å–**
  - `_extract_last_payload()`ï¼šå…¼å®¹â€œDebate + æœ«å°¾ JSONâ€/â€œçº¯ JSONâ€
  - `_get_stop_suggest()`ï¼šç»Ÿä¸€å¤§å°å†™ï¼Œä¾›è£å†³å™¨ä½¿ç”¨

- **æ”¶æ•›è£å†³å™¨æ¥å£**
  - `_should_end_debate()`ï¼šåªè´Ÿè´£â€œä¸‹ä¸€è·³å†³ç­–â€ï¼Œä¿æŒè¿”å› `"next_round"` / `"pm"` çš„ç¨³å®šåè®®ã€‚
- **ä¸‰æ®µè½åœ°æ¨¡å¼**
  - `postprocess_hunter / postprocess_auditor / postprocess_pm`ï¼šå›ºå®šâ€œè½åœ° cur + å†™ history + å†™ stop_suggestâ€ã€‚

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–é‡å†™**

ä¸‹é¢è¿™äº›å†…å®¹çš„**æ€æƒ³æ˜¯é€šç”¨çš„**ï¼Œä½†å­—æ®µåã€åˆå¹¶ keyã€æ’åºè§„åˆ™ã€pipeline çŠ¶æ€ä½é€šå¸¸å’Œä¸šåŠ¡å¼ºç»‘å®šã€‚  

è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œ**å…è®¸ä½ æ”¹å®ƒä»¬**ï¼Œä½†å»ºè®®ä¿æŒâ€œå†™ cur + å†™ historyâ€çš„æ¨¡å¼ä¸å˜ã€‚

- **å€™é€‰åˆå¹¶ç­–ç•¥**
  - `push_candidates_merge()`ï¼ˆstateä¾§ï¼‰ï¼šETF ç”¨ `symbol` åˆå¹¶ã€æŒ‰ `score` æ’åºã€‚
  - æ¢ä¸šåŠ¡æ—¶ï¼ŒæŠŠ `symbol/score` æ¢æˆä½ çš„ä¸»é”®ä¸ä¼˜å…ˆçº§å­—æ®µå³å¯ã€‚

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ ETF å€™é€‰åˆå¹¶æ”¹æˆâ€œæ–¹æ¡ˆè¯„å®¡â€çš„ææ¡ˆåˆå¹¶</b></summary>

  ```py
    # TODOï¼šæ–¹æ¡ˆè¯„å®¡åœºæ™¯ï¼ˆproposal_id + priorityï¼‰
    def push_candidates_merge(st, incoming):
        # 1) ä»¥ proposal_id ä¸º key åˆå¹¶ï¼ˆincoming è¦†ç›–åŒ idï¼‰
        # 2) ä»¥ priority ç”±é«˜åˆ°ä½æ’åº
        # 3) å†™å› candidates_curï¼Œå¹¶ append history["candidates"]
        pass
  ```
  </details>

- **ç¡¬å‰”é™¤/å­˜æ´»æ± è§„åˆ™**
  - `_compute_survivor_universe()`ï¼šETF ç”¨ objections(REJECT) + risk_reports(illiquid/high_risk) åšç¡¬å‰”é™¤ã€‚
  - æ¢ä¸šåŠ¡æ—¶ï¼šä¿ç•™â€œè¾“å…¥æ¥è‡ª cur çŠ¶æ€ã€è¾“å‡ºæ˜¯ä¸€ä¸ªå¯å¤ç”¨å­é›†â€çš„ç»“æ„å³å¯ã€‚

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠå­˜æ´»æ± æ”¹æˆâ€œåˆåŒå®¡é˜…â€çš„å¯æ¥å—æ¡æ¬¾é›†åˆ</b></summary>

  ```py
    # TODOï¼šåˆåŒå®¡é˜…åœºæ™¯ï¼ˆclause_id + risk_flagï¼‰
    def compute_survivors(st):
        # 1) ä» candidates_cur å– clause_id
        # 2) å‰”é™¤ objections_cur ä¸­ verdict=="REJECT" çš„ clause_id
        # 3) è¾“å‡º survivorsï¼ˆå»é‡ä¿åºï¼‰
        pass
  ```
  </details>

- **ç¨³å®šè½®æ•°/æ”¶æ•›åˆ¤æ–­çš„â€œæŒ‡çº¹å†…å®¹â€**
  - `bump_stable_rounds()` é»˜è®¤ç”¨ candidates + objections + diff åšæŒ‡çº¹ï¼ˆä½ é¡¹ç›®é‡Œå¯èƒ½åœ¨ state.pyï¼‰ã€‚
  - æ¢ä¸šåŠ¡æ—¶ï¼šæ”¹â€œæŒ‡çº¹åŒ…å«å“ªäº›å­—æ®µâ€ï¼Œè®©â€œç¨³å®šâ€ç¬¦åˆä¸šåŠ¡å®šä¹‰ã€‚

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠç¨³å®šåˆ¤æ–­æ”¹æˆâ€œèˆ†æƒ…ç ”åˆ¤â€çš„è§‚ç‚¹ä¸€è‡´æ€§</b></summary>

  ```py
    # TODOï¼šèˆ†æƒ…ç ”åˆ¤åœºæ™¯ï¼ˆonly stance + evidence_summaryï¼‰
    def bump_stable_rounds(st, reset_if_changed=True):
        # 1) fingerprint åªçœ‹ st["objections_cur"] çš„ stance å­—æ®µ
        # 2) è‹¥ fingerprint ç›¸åŒ -> stable_rounds += 1
        # 3) å¦åˆ™æŒ‰ reset_if_changed å†³å®šæ˜¯å¦æ¸…é›¶
        pass
  ```
  </details>

- **è·¨è½®æ§åˆ¶ä½ï¼ˆpipeline / å¼ºåˆ¶å·¥å…·è°ƒç”¨ / è¡¥é½å€™é€‰ï¼‰**
  - ETF çš„ `_hunter_pipeline_stage / _need_recall_diversity* / _need_rerank_composite* / _force_hunter_tool / _need_more_candidates` ç­‰ã€‚
  - è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡ï¼š
    - ä½ å¯ä»¥åˆ æ‰å®ƒä»¬ï¼ˆå¦‚æœä¸éœ€è¦ pipelineï¼‰
    - æˆ–æ›¿æ¢æˆè‡ªå·±çš„é˜¶æ®µçŠ¶æ€ä½
    - ä½†è¦ä¿æŒâ€œé»˜è®¤åˆå§‹åŒ–åˆç†ï¼Œä¸è®© graph KeyErrorâ€

**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
  - **ä¸åŠ¨**ï¼š
    - `RoleBlock` å¥‘çº¦
    - `messages` é©±åŠ¨çš„ä¸»å¾ªç¯
    - `_extract_last_payload()` çš„â€œæœ«å°¾ JSON + validateâ€æœºåˆ¶
    - ä¸‰æ®µ postprocess çš„â€œå†™ cur + å†™ history + å†™ stop_suggestâ€æ¨¡å¼
  - **å¯æ¢**ï¼š
    - â€œä¸šåŠ¡å¯¹è±¡â€å­—æ®µï¼š`symbol/score/reason` â†’ ä½ çš„ `id/priority/summary`
    - `push_*` çš„åˆå¹¶ key ä¸æ’åºè§„åˆ™
    - `_compute_survivor_universe()` çš„ç¡¬å‰”é™¤é€»è¾‘
    - `DIFF` çš„ patch ç±»å‹é›†åˆ
    - pipeline çŠ¶æ€ä½ä¸æ¨è¿›è§„åˆ™

</details>

---


## å…³å¡-07ï½œå¼•æ“ä¸²è” Engineï¼šæœ€å°å¾ªç¯

<details>
<summary><b>Checkpoint 07 â€” å¼•æ“ä¸²è” ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³æŠŠå…³å¡-06 çš„ **Graphï¼ˆå¯æ§æµç¨‹ï¼‰** æ¥åˆ° **Engineï¼ˆè¿è¡Œå…¥å£ï¼‰** ä¸Šï¼Œå½¢æˆä¸€æ¬¡å¯è·‘é€šçš„æœ€å°é—­ç¯ï¼š  
> **å‡†å¤‡è¾“å…¥ â†’ åˆå§‹åŒ– state â†’ ç»„è£… RoleBlocks â†’ æ„å»ºå¹¶è¿è¡Œ Graph â†’ æ¸²æŸ“å¹¶è½ç›˜ â†’ è¿”å› artifacts**  
>
> è¿™ä¸€å…³ä¸è¿½æ±‚â€œæ›´èªæ˜â€ï¼Œåªè¿½æ±‚ **æ›´ç¨³å®šã€æ›´å¯æµ‹ã€æ›´å¯è¿ç§»**ï¼š  
> - å…¥å£å‡½æ•° `run()` èƒ½è·‘å®Œ  
> - ä¸‰æ®µçº¯ç»„è£…å‡½æ•°æŠŠå¤æ‚åº¦æ‹†å¼€ï¼ˆä¾¿äº stub / æµ‹è¯•ï¼‰  
> - æœ€å°‘ä¸€ä¸ªè½ç›˜äº§ç‰©


### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- ç†è§£å¹¶å®ç° **Engine æœ€å°é—­ç¯**ï¼š`run()` ä¸²è” dossier/state/prompts/tools/llm/graph/renderer
- å­¦ä¼šæŠŠå¤æ‚ run æ‹†æˆ **3 ä¸ªçº¯ç»„è£…å‡½æ•°**
- è·‘é€šä¸€æ¬¡ä»»åŠ¡åï¼Œèƒ½è¿”å› `artifacts: Dict[str, str]`ï¼Œå¹¶è‡³å°‘ç”Ÿæˆä¸€ä¸ªè½ç›˜æ–‡ä»¶ï¼ˆå¦‚ transcript/jsonï¼‰


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ï¼š`src/debate_mas/core/engine.py`
- ä¸æ”¹ï¼š`core/graph.py` / `core/state.py` / `protocol` / `skills` çš„æ¥å£å¥‘çº¦ï¼›ä¸å¼•å…¥æ–°ä¾èµ–
- ä¸é‡æ„ç›®å½•ç»“æ„ï¼›åªåšâ€œæœ€å°é—­ç¯èƒ½è·‘å®Œâ€çš„å¡«ç©ºå®ç°
- å…è®¸ç”¨ monkeypatch åœ¨æµ‹è¯•ä¸­ stub å¤–éƒ¨ä¾èµ–ï¼ˆLLM / loader / renderer / skills åŠ è½½ï¼‰


### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

#### **å¿…çœ‹**
- `src/debate_mas/core/engine.py`ï¼šæœ¬å…³ä¸»æ–‡ä»¶ï¼ˆrun å…¥å£ + ä¸‰æ®µç»„è£…å‡½æ•° + transcript è½ç›˜ + renderer è¾“å‡ºï¼‰
- `src/debate_mas/core/graph.py`ï¼šGraph ç¼–æ’é—­ç¯ï¼ˆengine åªè´Ÿè´£â€œç»„è£…å¹¶è·‘â€ï¼Œä¸åº”é‡å†™ graph é€»è¾‘ï¼‰
- `src/debate_mas/core/state.py`ï¼š`init_state(...)` ä¸ state ç»“æ„çº¦å®šï¼ˆengine å¿…é¡»æŒ‰çº¦å®šåˆå§‹åŒ– keyï¼Œé¿å… KeyErrorï¼‰
- `src/debate_mas/core/config.py`ï¼šCONFIG è¯»å–ï¼ˆrole æ¨¡å‹å/æ¸©åº¦/max_tokens/verbose/data_dir ç­‰ï¼‰
- `src/debate_mas/core/personas.py`ï¼š`build_role_prompts_etf(...)`ï¼ˆengine è´Ÿè´£æŠŠ prompts æ¥å…¥ RoleBlockï¼‰
- `src/debate_mas/core/tools.py`ï¼š`build_role_tools_and_node(...)`ï¼ˆengine è´Ÿè´£æŠŠ tools + tool_node æ¥å…¥ RoleBlockï¼‰
- `src/debate_mas/loader/dual_mode_loader.py`ï¼š`DualModeLoader.load_from_folder(...)`ï¼ˆæ¡ˆå·å…¥å£ï¼‰
- `src/debate_mas/skills/registry.py`ï¼š`SkillRegistry.load_all_skills(...)`ï¼ˆrun å¼€å§‹å¿…é¡»å…ˆåŠ è½½ skillsï¼‰
- `src/debate_mas/protocol/renderer.py`ï¼š`DebateRenderer.render(...)`ï¼ˆæœ€ç»ˆäº§å‡º artifacts çš„åœ°æ–¹ï¼‰


#### **å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- **ä¸‰æ®µç»„è£…å‡½æ•°ç»“æ„å¿…é¡»ç¨³å®š**
  - `_setup_dossier_and_state()`ï¼šåªè´Ÿè´£â€œåŠ è½½ dossier + init_stateâ€
  - `_setup_prompts_tools_llms()`ï¼šåªè´Ÿè´£â€œprompts/tools/llm â†’ RoleBlockâ€
  - `_run_graph_and_render()`ï¼šåªè´Ÿè´£â€œè·‘å›¾ â†’ æ¸²æŸ“ â†’ è½ç›˜ â†’ è¿”å› artifactsâ€
- **run() å…¥å£å¿…é¡»ç¨³å®š**
  - run åªåšï¼šload skills â†’ ç»„è£…ä¸‰æ®µ â†’ return artifacts
- **transcript å¯å®¡è®¡è¾“å‡º**
  - `_serialize_messages()`ï¼šæŠŠ messages è½¬æˆ list[dict]ï¼ˆå« tool_calls / name / tool_call_idï¼‰
  - `_infer_role()`ï¼šæœ€å°è§’è‰²æ¨æ–­ç¨³å®šï¼ˆuser/assistant/tool/unknownï¼‰
- **coerce å…œåº•å¿…é¡»ç¨³å®š**
  - `_coerce_decisions()`ï¼šæŠŠ pm è¾“å‡ºç»Ÿä¸€æˆ schema åˆ—è¡¨ï¼ˆé¿å… renderer è¾“å…¥ä¸ç¨³å®šï¼‰
  - `_coerce_tool_trace()`ï¼šè¡¥é½ trace é»˜è®¤å­—æ®µï¼ˆé¿å… renderer KeyErrorï¼‰


#### **å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼Œè¿ç§»å¯æ›¿æ¢ï¼‰**
- **å€™é€‰èåˆç•™ç—•**
  - `merge_candidates(...)`ï¼šæŠŠ graph è¾“å‡ºçš„å€™é€‰æ”¹â€œæœ€ç»ˆèåˆç‰ˆâ€
  - `explain_merge(...)`ï¼šç”Ÿæˆ merge_notes æ”¾è¿› extra_metaï¼ˆä¾¿äºæ•™å­¦/å¤ç›˜ï¼‰
- **renderer çš„ extra_meta æ‰“åŒ…**
  - è‡³å°‘åŒ…å«ï¼š`stop_reason / tool_trace / transcript / candidates_cur / objections_cur / diff_cur`
- **transcript è½ç›˜**
  - æ¯æ¬¡ run åè‡³å°‘å†™å‡ºä¸€ä¸ª `*_transcript.json`ï¼ˆå¹¶æŠŠè·¯å¾„å†™è¿› artifactsï¼‰


#### **é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- **verbose_summaryï¼ˆstream å¢é‡æ‰“å°ï¼‰**
  - ç”¨ `app.stream(..., stream_mode="values")` æ‰“å°å¢é‡ tool_trace/messagesï¼ˆæ•™å­¦æ¼”ç¤ºç”¨ï¼‰
- **å¤–éƒ¨ä¾èµ–æ›´å¼ºå¥**
  - `_build_llm()` æ”¯æŒæ›´å¤š provider/ç¯å¢ƒå˜é‡ç»„åˆï¼ˆä½†ä¸è¦æ”¹ run() çš„å¯¹å¤–ç­¾åï¼‰
- **æ›´ä¸¥æ ¼çš„å‚æ•°æ ¡éªŒ**
  - mission éç©ºã€output_dir å¯å†™ã€folder_path å­˜åœ¨ç­‰ï¼ˆå¤±è´¥è¦ç»™å¯æ“ä½œçš„é”™è¯¯ä¿¡æ¯ï¼‰
- **æ›´ä¸°å¯Œçš„è½ç›˜äº§ç‰©**
  - é™¤ transcript å¤–è¿½åŠ ï¼šconfig_snapshotã€dossier æ‘˜è¦ã€top candidates æ‘˜è¦ç­‰ï¼ˆéƒ½æ”¾åœ¨ extra_meta.extrasï¼‰

<details>
<summary><b>ğŸ“„ Checkpoint-07ï¼šcore/engine.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/core/engine.py
from __future__ import annotations

import os
import json
from datetime import datetime
from typing import Any, Dict, Optional, List, Tuple

from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage, BaseMessage

from debate_mas.loader.dual_mode_loader import DualModeLoader
from debate_mas.skills.registry import SkillRegistry
from debate_mas.protocol.renderer import DebateRenderer
from debate_mas.protocol.schema import EtfDecision

from .config import CONFIG
from .state import init_state, DebateState
from .personas import build_role_prompts_etf

from .graph import (
    RoleBlock,
    build_etf_attack_patch_graph,
    postprocess_hunter,
    postprocess_auditor,
    postprocess_pm,
)

from .blend_rank import merge_candidates, explain_merge
from .tools import build_role_tools_and_node

load_dotenv()

# ============================================================
# 0) LLM / coercion helpers
# ============================================================

def _build_llm(
    model_name: str,
    *,
    temperature: float = 0.2,
    max_tokens: int = 4000,
) -> ChatOpenAI:
    """
    ç»Ÿä¸€ LLM æ„é€ å™¨ï¼šæ„å»º ChatOpenAI å®¢æˆ·ç«¯ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ä»ç¯å¢ƒå˜é‡è¯»å– api_key / api_baseï¼ˆå­—æ®µåæŒ‰é¡¹ç›®çº¦å®šï¼‰
      - ç¼ºå¤±æ—¶ raise RuntimeErrorï¼ˆæŠ¥é”™ä¿¡æ¯è¦èƒ½æŒ‡å¯¼æ’æŸ¥ï¼‰
      - è¿”å› ChatOpenAI(...)

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - å¯¹ temperature/max_tokens åšè½»é‡è¾¹ç•Œå¤„ç†

    Args:
        model_name: æ¨¡å‹å
        temperature: é‡‡æ ·æ¸©åº¦
        max_tokens: æœ€å¤§è¾“å‡º token

    Returns:
        llm: ChatOpenAI å®¢æˆ·ç«¯
    """
    # TODO
    raise NotImplementedError


def _coerce_decisions(decisions: List[Dict[str, Any]]) -> List[EtfDecision]:
    """
    æŠŠ PM è¾“å‡ºç»Ÿä¸€è½¬æˆ EtfDecision åˆ—è¡¨ï¼ˆschema å½’ä¸€åŒ–ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å…¥å‚å¯èƒ½æ˜¯ list[dict] / list[EtfDecision] æ··åˆ
      - ç»Ÿä¸€è½¬æˆ list[EtfDecision]
      - å¿½ç•¥æ— æ³•è½¬æ¢çš„æ¡ç›®ï¼ˆæˆ–é€‰æ‹© raiseï¼ŒäºŒé€‰ä¸€ä¿æŒä¸€è‡´ï¼‰

    Args:
        decisions: åŸå§‹ decisions åˆ—è¡¨

    Returns:
        out: EtfDecision åˆ—è¡¨
    """
    # TODO
    raise NotImplementedError


def _coerce_tool_trace(trace: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    tool_trace å­—æ®µè¡¥é½ï¼šä¿è¯ renderer ä¸å› ç¼ºå­—æ®µå´©æºƒã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - åªä¿ç•™ dict æ¡ç›®
      - ä¸ºå…³é”®å­—æ®µ setdefaultï¼škind/args/ok/denied/insight/error_msg/visuals/produced_n/elapsed_ms/round_idx/role
      - è¿”å›è¡¥é½åçš„ trace

    Args:
        trace: åŸå§‹ trace

    Returns:
        out: è§„èŒƒåŒ– trace
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 1) Transcript åºåˆ—åŒ–å·¥å…·
# ============================================================

def _infer_role(m: BaseMessage) -> str:
    """
    æ¨æ–­æ¶ˆæ¯è§’è‰²ï¼šuser / assistant / tool / unknownã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - isinstance(HumanMessage) -> "user"
      - isinstance(AIMessage) -> "assistant"
      - isinstance(ToolMessage) -> "tool"
      - å…œåº•ï¼šè¯» m.type æˆ–è¿”å› "unknown"

    Args:
        m: BaseMessage

    Returns:
        role: str
    """
    # TODO
    raise NotImplementedError


def _serialize_messages(msgs: List[BaseMessage]) -> List[Dict[str, Any]]:
    """
    æŠŠ messages åºåˆ—åŒ–æˆå¯è½ç›˜çš„ transcriptã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - è¾“å‡º list[dict]ï¼Œè‡³å°‘åŒ…å« role/content
      - è‹¥å­˜åœ¨ tool_callsï¼ˆä¸¤ç§å­˜å‚¨é£æ ¼ï¼‰å†™å…¥ tool_calls
      - è‹¥å­˜åœ¨ name/tool_call_id ä¹Ÿå†™å…¥

    Args:
        msgs: messages

    Returns:
        out: transcript list
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 2) run() çš„ 3 ä¸ªâ€œçº¯ç»„è£…å‡½æ•°â€
# ============================================================

def _setup_dossier_and_state(
    *,
    mission: str,
    ref_date: Optional[str],
    folder_path: Optional[str],
    seed_user_message: Optional[str],
) -> Tuple[Any, DebateState]:
    """
    å‡†å¤‡ dossier + åˆå§‹åŒ– DebateStateï¼ˆåªåšç»„è£…ï¼Œä¸è·‘å›¾ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ä½¿ç”¨ DualModeLoader ä» folder_path åŠ è½½ dossierï¼ˆfolder_path None åˆ™èµ°é»˜è®¤ï¼‰
      - seed_user_message è‹¥å­˜åœ¨ï¼šæ”¾å…¥ messagesï¼ˆHumanMessageï¼‰
      - è°ƒç”¨ init_state(...) ç”Ÿæˆ st

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - folder_path é»˜è®¤ç”¨ CONFIG.DATA_DIR
      - init_state éœ€å†™å…¥ mission/ref_date/dossier/messages

    Args:
        mission: ä»»åŠ¡æè¿°
        ref_date: å‚è€ƒæ—¥æœŸï¼ˆå¯é€‰ï¼‰
        folder_path: æ¡ˆå·ç›®å½•ï¼ˆå¯é€‰ï¼‰
        seed_user_message: ç§å­æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰

    Returns:
        dossier: æ¡ˆå·å¯¹è±¡
        st: DebateState
    """
    # TODO
    raise NotImplementedError


def _setup_prompts_tools_llms(
    *,
    mission: str,
    dossier: Any,
    ref_date: Optional[str],
    st: DebateState,
) -> Tuple[Dict[str, str], RoleBlock, RoleBlock, RoleBlock]:
    """
    å‡†å¤‡ prompts + tools + llmsï¼Œå¹¶ç»„è£…æˆ RoleBlockï¼ˆä¸‰è§’è‰²ï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - prompts = build_role_prompts_etf(...)
      - ä¸º hunter/auditor/pm æ„å»º tools + tool_node
      - ä¸ºä¸‰è§’è‰²æ„å»º llmï¼Œå¹¶ bind_tools
      - ç»„è£… RoleBlockï¼šrole/system_prompt/llm_invoke/tool_node/postprocess

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - prompts éœ€è¦ä¼ å…¥ allowlist_by_roleï¼ˆæ¥è‡ª CONFIGï¼‰
      - postprocess åˆ†åˆ«ä½¿ç”¨ postprocess_hunter/postprocess_auditor/postprocess_pm

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - per-role temperature / max_tokensï¼šä» CONFIG è¯»å–å¹¶è®¾ç½®é»˜è®¤å€¼
      - tool_node å…è®¸ä¸º Noneï¼ˆæµ‹è¯•åœºæ™¯ï¼‰

    Args:
        mission: ä»»åŠ¡æè¿°
        dossier: æ¡ˆå·å¯¹è±¡
        ref_date: å‚è€ƒæ—¥æœŸï¼ˆå¯é€‰ï¼‰
        st: DebateStateï¼ˆç”¨äº tools æ„å»º/ä¸Šä¸‹æ–‡ï¼‰

    Returns:
        prompts: role -> prompt æ–‡æœ¬
        hunter_block: RoleBlock
        auditor_block: RoleBlock
        pm_block: RoleBlock
    """
    # TODO
    raise NotImplementedError


def _run_graph_and_render(
    *,
    mission: str,
    ref_date: Optional[str],
    output_dir: str,
    st: DebateState,
    hunter_block: RoleBlock,
    auditor_block: RoleBlock,
    pm_block: RoleBlock,
    verbose_summary: bool,
) -> Dict[str, str]:
    """
    è·‘å›¾ + æ¸²æŸ“è¾“å‡ºï¼šæœ¬å…³æœ€å°é—­ç¯æ‰§è¡Œç‚¹ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - app = build_etf_attack_patch_graph(...)
      - verbose_summary=Falseï¼šç›´æ¥ invoke(st) å¾— final_state
      - verbose_summary=Trueï¼šå¯é€‰ stream æ‰“å°ï¼ˆå¯å…ˆç•™ç©ºæˆ–æœ€å°å®ç°ï¼‰
      - åºåˆ—åŒ– messages -> transcript
      - renderer.render(...) è¿”å› artifacts

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - candidates åˆå¹¶ç•™ç—•ï¼ˆmerge + explainï¼‰ï¼Œå†™å› final_state
      - extra_meta æ‰“åŒ…ï¼ˆè‡³å°‘åŒ…å« stop_reason / transcript / cur çŠ¶æ€å¿«ç…§ï¼‰
      - transcript ä»¥ json è½ç›˜åˆ° output_dirï¼Œå¹¶æŠŠè·¯å¾„å¡è¿› artifacts

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - verbose å¢é‡æ‰“å°ï¼štool_trace/messages å¢é‡æ‘˜è¦
      - é”™è¯¯å…œåº•ï¼šè½ç›˜å¤±è´¥ä¸åº”ä¸­æ–­ä¸»æµç¨‹ï¼ˆå¯æ‰“å° warningï¼‰

    Args:
        mission: ä»»åŠ¡æè¿°
        ref_date: å‚è€ƒæ—¥æœŸï¼ˆå¯é€‰ï¼‰
        output_dir: è¾“å‡ºç›®å½•
        st: åˆå§‹ DebateState
        hunter_block/auditor_block/pm_block: RoleBlock
        verbose_summary: æ˜¯å¦ stream å¢é‡æ‘˜è¦

    Returns:
        artifacts: Dict[str, str]
    """
    # TODO
    raise NotImplementedError


# ============================================================
# 3) ä¸€é”®è¿è¡Œå…¥å£
# ============================================================

def run(
    mission: str,
    *,
    ref_date: Optional[str] = None,
    folder_path: Optional[str] = None,
    output_dir: str = "./output_reports",
    seed_user_message: Optional[str] = None,
) -> Dict[str, str]:
    """
    ä¸€é”®è¿è¡Œå…¥å£ï¼ˆå¯¹å¤– APIï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - SkillRegistry.load_all_skills(...)
      - dossier, st = _setup_dossier_and_state(...)
      - prompts, hunter_block, auditor_block, pm_block = _setup_prompts_tools_llms(...)
      - return _run_graph_and_render(...)

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - verbose_summary è¯»å– CONFIG.VERBOSE
      - output_dir é»˜è®¤ "./output_reports"

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - å‚æ•°è½»é‡æ ¡éªŒï¼ˆmission éç©ºï¼‰
      - output_dir mkdir(exist_ok=True)

    Args:
        mission: ä»»åŠ¡æè¿°
        ref_date: å‚è€ƒæ—¥æœŸï¼ˆå¯é€‰ï¼‰
        folder_path: æ¡ˆå·ç›®å½•ï¼ˆå¯é€‰ï¼‰
        output_dir: è¾“å‡ºç›®å½•
        seed_user_message: ç§å­æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰

    Returns:
        artifacts: Dict[str, str]
    """
    # TODO
    raise NotImplementedError

```
</details>


### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_engine.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_engine.py</b></summary>

   ```py
    import json
    from types import SimpleNamespace
    from pathlib import Path

    import pytest
    from langchain_core.messages import AIMessage, HumanMessage, ToolMessage

    from debate_mas.core import engine as e



    def _patch_config(monkeypatch: pytest.MonkeyPatch, **overrides) -> None:
        """
        ç›´æ¥ monkeypatch æ¨¡å—å˜é‡ e.CONFIG ä¸ºä¸€ä¸ªå¯å˜å¯¹è±¡ï¼ˆstubï¼‰ï¼Œé¿å… FrozenInstanceErrorã€‚
        """
        cfg = SimpleNamespace(
            DATA_DIR="__DATA_DIR__",
            VERBOSE=False,

            HUNTER_MODEL="stub-hunter",
            AUDITOR_MODEL="stub-auditor",
            PM_MODEL="stub-pm",

            ROLE_TEMPERATURE={"hunter": 0.9, "auditor": 0.3, "pm": 0.1},
            ROLE_MAX_TOKENS={"hunter": 1200, "auditor": 800, "pm": 800},
            MAX_TOKENS_DEFAULT=1000,

            ROLE_TOOL_ALLOWLIST={"hunter": [], "auditor": [], "pm": []},

            HUNTER_BLEND={"demo": 1.0},
        )

        def _get_model_config():
            return {"stub": True}

        cfg.get_model_config = _get_model_config

        for k, v in overrides.items():
            setattr(cfg, k, v)

        monkeypatch.setattr(e, "CONFIG", cfg, raising=True)


    class DummyLLM:
        """
        æœ€å° LLM stubï¼š
        - bind_tools(tools) -> self
        - invoke(messages) -> AIMessage
        """
        def __init__(self, role: str):
            self.role = role
            self.bound_tools = None

        def bind_tools(self, tools):
            self.bound_tools = tools
            return self

        def invoke(self, _messages):
            return AIMessage(content=f"[{self.role}] ok")


    def _patch_llm(monkeypatch: pytest.MonkeyPatch) -> None:
        def fake_build_llm(model_name: str, *, temperature: float = 0.2, max_tokens: int = 4000):
            role = "unknown"
            if "hunter" in model_name: role = "hunter"
            if "auditor" in model_name: role = "auditor"
            if "pm" in model_name: role = "pm"
            return DummyLLM(role=role)

        monkeypatch.setattr(e, "_build_llm", fake_build_llm, raising=True)


    def _patch_loader_and_state(monkeypatch: pytest.MonkeyPatch):
        calls = {"load": [], "init_state": []}

        class DummyLoader:
            def load_from_folder(self, *, mission: str, folder_path: str):
                calls["load"].append({"mission": mission, "folder_path": folder_path})
                return {"dossier": True, "folder": folder_path}

        def fake_init_state(*, mission, dossier, ref_date, messages):
            calls["init_state"].append(
                {"mission": mission, "dossier": dossier, "ref_date": ref_date, "messages": messages}
            )
            return {
                "mission": mission,
                "ref_date": ref_date,
                "dossier": dossier,
                "dossier_view": {"meta": "stub"},
                "messages": list(messages or []),

                "round_idx": 0,
                "stable_rounds": 0,
                "tool_trace": [],
                "tool_cache": {},

                "candidates_cur": [],
                "objections_cur": [],
                "diff_cur": {"type": "DIFF", "items": []},
                "risk_reports": [],
                "survivor_universe": [],

                "decisions": [],
            }

        monkeypatch.setattr(e, "DualModeLoader", DummyLoader, raising=True)
        monkeypatch.setattr(e, "init_state", fake_init_state, raising=True)
        return calls


    def _patch_prompts_tools(monkeypatch: pytest.MonkeyPatch):
        calls = {"prompts": [], "tools": []}

        def fake_build_prompts_etf(*, mission, dossier_view, allowlist_by_role):
            calls["prompts"].append(
                {"mission": mission, "dossier_view": dossier_view, "allowlist_by_role": allowlist_by_role}
            )
            return {"hunter": "HUNTER_SYS", "auditor": "AUDITOR_SYS", "pm": "PM_SYS"}

        def fake_build_role_tools_and_node(*, role, dossier, ref_date, state):
            calls["tools"].append({"role": role, "ref_date": ref_date})
            return ([], None, None)

        monkeypatch.setattr(e, "build_role_prompts_etf", fake_build_prompts_etf, raising=True)
        monkeypatch.setattr(e, "build_role_tools_and_node", fake_build_role_tools_and_node, raising=True)
        return calls


    def _patch_graph_and_renderer(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
        """
        è®© _run_graph_and_render çœŸæ­£è·‘åˆ°ï¼š
        - build graph -> invoke -> final_state
        - transcript åºåˆ—åŒ– + è½ç›˜
        - renderer.render è¿”å› artifacts
        """
        class DummyGraph:
            def __init__(self, final_state):
                self._final_state = final_state

            def invoke(self, _st):
                return self._final_state

            def stream(self, _st, stream_mode="values"):
                yield self._final_state

        def fake_build_graph(*, hunter, auditor, pm):
            final_state = {
                "round_idx": 0,
                "stable_rounds": 0,
                "stop_reason": "MAX_ROUNDS_DEBATE",

                "_last_speaker_role": "pm",

                "messages": [
                    AIMessage(content='{"type":"CANDIDATES","stop_suggest":"STOP","items":[{"symbol":"510300","score":80.0,"reason":"x","source_skill":"demo","extra":{}}]}'),
                    AIMessage(content='{"type":"OBJECTIONS","stop_suggest":"STOP","items":[]}'),
                    AIMessage(content='{"type":"DECISIONS","stop_suggest":"STOP","items":[]}'),
                ],

                "tool_trace": [{"kind": "trace", "role": "system", "tool": "__test__", "ok": True, "insight": "ok"}],
                "tool_cache": {},

                "candidates_cur": [{"symbol": "510300", "score": 80.0, "reason": "x", "source_skill": "demo", "extra": {}}],
                "objections_cur": [],
                "diff_cur": {"type": "DIFF", "items": []},

                "decisions": [],  
                "dossier_view": {"meta": "stub"},
            }
            return DummyGraph(final_state)

        class FakeRenderer:
            def __init__(self, output_dir: str):
                self.output_dir = output_dir

            def render(self, *, mission: str, decisions, extra_meta):
                return {"memo": str(Path(self.output_dir) / "memo.md")}

        def fake_merge_candidates(cands_list, source_weights=None):
            if not cands_list:
                return []
            x = cands_list[0] or []
            return list(x)

        def fake_explain_merge(_merged, top_n=5):
            return "merge_notes: stub"

        monkeypatch.setattr(e, "build_etf_attack_patch_graph", fake_build_graph, raising=True)
        monkeypatch.setattr(e, "DebateRenderer", FakeRenderer, raising=True)
        monkeypatch.setattr(e, "merge_candidates", fake_merge_candidates, raising=True)
        monkeypatch.setattr(e, "explain_merge", fake_explain_merge, raising=True)


    def _patch_skill_registry(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(e.SkillRegistry, "load_all_skills", lambda force_reload=False: None, raising=True)


    def test_infer_role_and_serialize_messages():
        msgs = [
            HumanMessage(content="hi"),
            AIMessage(content="hello"),
            ToolMessage(content="tool ok", tool_call_id="t1"),
        ]

        out = e._serialize_messages(msgs)

        assert out[0]["role"] == "user"
        assert out[1]["role"] == "assistant"
        assert out[2]["role"] == "tool"
        assert out[2]["tool_call_id"] == "t1"


    def test_serialize_messages_captures_tool_calls_in_both_styles():
        m1 = AIMessage(
            content="x",
            additional_kwargs={
                "tool_calls": [{"id": "1", "type": "function", "function": {"name": "foo", "arguments": "{}"}}]
            },
        )
        m2 = AIMessage(content="y")
        setattr(m2, "tool_calls", [{"name": "bar"}])

        out = e._serialize_messages([m1, m2])
        assert "tool_calls" in out[0]
        assert "tool_calls" in out[1]


    def test_setup_dossier_and_state_injects_seed_message_and_defaults(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch, DATA_DIR="DATA_DEFAULT")
        calls = _patch_loader_and_state(monkeypatch)

        dossier, st = e._setup_dossier_and_state(
            mission="m",
            ref_date="2025-10-26",
            folder_path=None, 
            seed_user_message="seed",
        )

        assert dossier["folder"] == "DATA_DEFAULT"
        assert isinstance(st["messages"][0], HumanMessage)
        assert st["messages"][0].content == "seed"

        assert calls["load"][0]["folder_path"] == "DATA_DEFAULT"
        assert calls["init_state"][0]["mission"] == "m"
        assert calls["init_state"][0]["ref_date"] == "2025-10-26"


    def test_setup_prompts_tools_llms_builds_roleblocks(monkeypatch: pytest.MonkeyPatch):
        _patch_config(monkeypatch)
        _patch_llm(monkeypatch)
        calls = _patch_prompts_tools(monkeypatch)

        st = {"dossier_view": {"meta": "stub"}}
        prompts, hunter_rb, auditor_rb, pm_rb = e._setup_prompts_tools_llms(
            mission="m",
            dossier={"dossier": True},
            ref_date="2025-10-26",
            st=st,
        )

        assert prompts["hunter"] == "HUNTER_SYS"
        assert hunter_rb.role == "hunter"
        assert auditor_rb.role == "auditor"
        assert pm_rb.role == "pm"

        assert len(calls["prompts"]) == 1
        assert {c["role"] for c in calls["tools"]} == {"hunter", "auditor", "pm"}

        assert isinstance(hunter_rb.llm_invoke([]), AIMessage)


    def test_run_graph_and_render_creates_transcript_and_returns_artifacts(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
        _patch_config(monkeypatch, VERBOSE=False)
        _patch_graph_and_renderer(monkeypatch, tmp_path)

        st = {
            "messages": [],
            "tool_trace": [],
            "tool_cache": {},
            "candidates_cur": [],
            "objections_cur": [],
            "diff_cur": {"type": "DIFF", "items": []},
            "dossier_view": {"meta": "stub"},
            "round_idx": 0,
            "stable_rounds": 0,
        }

        rb = e.RoleBlock(
            role="hunter",
            system_prompt="SYS",
            llm_invoke=lambda _ms: AIMessage(content="x"),
            tool_node=None,
            postprocess=lambda _st: None,
        )

        artifacts = e._run_graph_and_render(
            mission="m",
            ref_date="2025-10-26",
            output_dir=str(tmp_path),
            st=st,
            hunter_block=rb,
            auditor_block=rb,
            pm_block=rb,
            verbose_summary=False,
        )

        assert isinstance(artifacts, dict)
        assert "memo" in artifacts

        transcript_path = artifacts.get("transcript")
        if transcript_path:
            p = Path(transcript_path)
            assert p.exists()
            data = json.loads(p.read_text(encoding="utf-8"))
            assert data["mission"] == "m"
            assert data["ref_date"] == "2025-10-26"
            assert isinstance(data["transcript"], list)
        else:
            files = list(Path(tmp_path).glob("*_transcript.json"))
            assert len(files) >= 1


    def test_run_entrypoint_smoke(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
        _patch_config(monkeypatch, VERBOSE=False, DATA_DIR="DATA_DEFAULT")
        _patch_skill_registry(monkeypatch)
        _patch_llm(monkeypatch)
        _patch_loader_and_state(monkeypatch)
        _patch_prompts_tools(monkeypatch)
        _patch_graph_and_renderer(monkeypatch, tmp_path)

        artifacts = e.run(
            "m",
            ref_date="2025-10-26",
            folder_path=None,
            output_dir=str(tmp_path),
            seed_user_message="seed",
        )

        assert isinstance(artifacts, dict)
        assert "memo" in artifacts
   ```

   </details>

2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_engine.py
```


### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰
  - `6 passed in ...s`
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`FrozenInstanceError`ã€`KeyError`ã€`RuntimeError: ç¼ºå°‘ç¯å¢ƒå˜é‡...`
- å¦‚æœå¤±è´¥ï¼Œä½ åº”è¯¥èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°ä¸‰ç±»é—®é¢˜ï¼š
  - **ç»„è£…æ²¡ä¸²èµ·æ¥**ï¼š`run()` æ²¡æŒ‰â€œä¸‰æ®µç»„è£…å‡½æ•°â€è°ƒç”¨ï¼Œæˆ– RoleBlock æ²¡æ­£ç¡®æ„å»º
  - **è½ç›˜ä¸ç¨³å®š**ï¼štranscript æ²¡å†™å‡º / è·¯å¾„æ²¡å›å¡« artifacts
  - **ä¾èµ–è€¦åˆå¤ªæ·±**ï¼šæµ‹è¯•æ— æ³• stubï¼ˆè¯´æ˜ engine é‡ŒæŠŠâ€œç»„è£…â€ä¸â€œä¸šåŠ¡ç»†èŠ‚/å¤–éƒ¨ I/Oâ€ç¼ åœ¨ä¸€èµ·ï¼‰


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `core/engine.py` è®¾è®¡ç›®æ ‡æ˜¯ï¼š**æŠŠå¤–éƒ¨ä¸–ç•Œï¼ˆdossier/tools/llm/rendererï¼‰ç²˜èµ·æ¥ï¼Œä½†ä¸æŠŠä¸šåŠ¡å†™æ­»ã€‚**
> 
> è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ é€šå¸¸åªéœ€è¦æ¢â€œæ•°æ®å…¥å£/è§’è‰² prompts/å·¥å…·/æ¸²æŸ“å™¨â€ï¼Œè€Œä¸å¿…é‡å†™ä¸»æµç¨‹ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

<details>
<summary><b>engine.py ä¸éœ€è¦åŠ¨çš„åœ°æ–¹</b></summary>

- **run() å¯¹å¤–ç­¾å**
  - `run(mission, ref_date=None, folder_path=None, output_dir=..., seed_user_message=None)`
  - åŸåˆ™ï¼šä¿æŒâ€œæ•™å­¦å‹å¥½ + å¯è„šæœ¬åŒ–è°ƒç”¨â€çš„ç»Ÿä¸€å…¥å£

- **ä¸‰æ®µç»„è£…å‡½æ•°ç»“æ„**
  - `_setup_dossier_and_state()`ï¼šåªè´Ÿè´£ dossier + init_state
  - `_setup_prompts_tools_llms()`ï¼šåªè´Ÿè´£ prompts/tools/llm â†’ RoleBlock
  - `_run_graph_and_render()`ï¼šåªè´Ÿè´£è·‘å›¾ + transcript + renderer

- **transcript åºåˆ—åŒ–ä¸è½ç›˜**
  - `_infer_role() / _serialize_messages()`
  - åŸåˆ™ï¼šå¯å®¡è®¡ã€å¯å¤ç›˜ï¼ˆå“ªæ€•æ¢ä¸šåŠ¡ä¹Ÿå€¼å¾—ä¿ç•™ï¼‰

- **coerce å…œåº•**
  - `_coerce_decisions() / _coerce_tool_trace()`
  - åŸåˆ™ï¼šä¿è¯ renderer è¾“å…¥ç¨³å®šï¼Œä¸è¦è®©ä¸‹æ¸¸å› ä¸ºå­—æ®µç¼ºå¤±å´©æºƒ

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–é‡å†™**

è¿™éƒ¨åˆ†å±äºâ€œä½ ä»¬å½“å‰æ˜¯ ETF çš„ç¤ºä¾‹ä¸šåŠ¡â€ã€‚  

è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶å¯ä»¥**æ•´ä½“æ›¿æ¢**ï¼Œä½†å»ºè®®ä¿ç•™åŒä¸€æ¡åŸåˆ™ï¼š**å¼ºç±»å‹ï¼ˆStrong Typesï¼‰+ å¯æ ¡éªŒï¼ˆValidatableï¼‰**ï¼Œè®© Graph/Engine çš„è¾“å…¥è¾“å‡ºé•¿æœŸç¨³å®šã€å¯æµ‹è¯•ã€‚

- **å€™é€‰åˆå¹¶ç­–ç•¥**
  - `EtfCandidate / EtfRiskReport / EtfDecision`
  - è¿ç§»æ–¹å¼ï¼šæ•´ä½“æ›¿æ¢æˆä½ çš„ä¸šåŠ¡å¯¹è±¡ï¼Œä¾‹å¦‚ï¼š
    - åˆåŒå®¡é˜…ï¼š`ClauseIssue / ClauseChange / ContractDecision`
    - æ–¹æ¡ˆè¯„å®¡ï¼š`Proposal / ReviewRisk / ReviewDecision`
    - å®è§‚å†³ç­–ï¼š`MacroSignal / RiskState / AllocationDecision`

  <details>
  <summary><b>ç¤ºä¾‹ï¼šæŠŠ EtfDecision æ¢æˆâ€œèµ„äº§é…ç½®å†³ç­–â€å¯¹è±¡</b></summary>

  ```py
    # ç¤ºä¾‹ï¼šAllocationDecisionï¼ˆå¯æ›¿æ¢ EtfDecisionï¼‰
    from pydantic import BaseModel, Field
    from typing import List, Literal

    DecisionAction = Literal["BUY", "SELL", "HOLD", "REBALANCE"]

    class AllocationDecision(BaseModel):
        asset: str
        action: DecisionAction
        target_weight: float = Field(0.0, ge=0.0, le=1.0)
        confidence: float = Field(0.0, ge=0.0, le=1.0)
        reasons: List[str] = Field(default_factory=list)
        risk_notes: List[str] = Field(default_factory=list)
  ```
  </details>

- **è¾“å…¥è½½ä½“ï¼šdossier**
  - ETF å½“å‰ç”¨ `DualModeLoader().load_from_folder(...)` ä»æ–‡ä»¶å¤¹åŠ è½½
  - è¿ç§»æ–¹å¼ï¼šæ›¿æ¢åŠ è½½å™¨å³å¯ï¼ˆDB/API/æ¶ˆæ¯é˜Ÿåˆ—éƒ½è¡Œï¼‰ï¼Œä½†**ä¿æŒè¾“å‡ºä»æ˜¯ dossier å¯¹è±¡**ï¼ˆgraph/tools åªé€ä¼ ï¼Œä¸å¼ºä¾èµ–åº•å±‚å­˜å‚¨ï¼‰

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ dossier æ¥æºä»â€œæ–‡ä»¶å¤¹â€æ¢æˆâ€œæ•°æ®åº“/æ¥å£â€</b></summary>

  ```py
    # TODOï¼šæ”¹é€  _setup_dossier_and_state çš„ dossier åŠ è½½
    def _setup_dossier_and_state(...):
        # 1) ç”¨ä½ çš„ DBLoader / APIClient æ›¿ä»£ DualModeLoader
        # 2) ä¿æŒè¿”å›ä»æ˜¯ dossierï¼ˆgraph/tools åªé€ä¼ ï¼‰
        # 3) init_state çš„ mission/ref_date/messages ç»“æ„ä¸å˜
        pass
  ```
  </details>

- **è§’è‰²è®¾å®šï¼šprompts**
  - ETF å½“å‰ç”¨ `build_role_prompts_etf(...)` ç”Ÿæˆ hunter/auditor/pm çš„ system prompts
  - è¿ç§»æ–¹å¼ï¼šæ›¿æ¢ prompts ç”Ÿæˆå™¨ + å¯¹åº” postprocess

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠä¸‰è§’è‰² prompts æ”¹æˆä½ å®šä¹‰çš„è§’è‰²</b></summary>

  ```py
    # TODOï¼šæ”¹é€  _setup_prompts_tools_llms çš„ prompts æ„é€ 
    def _setup_prompts_tools_llms(...):
        # 1) ç”¨ build_role_prompts_xxx æ›¿æ¢ build_role_prompts_etf
        # 2) RoleBlock ä¸‰ä»¶å¥—ä¸å˜ï¼šsystem_prompt / llm_invoke / postprocess
        # 3) postprocess_* æ›¿æ¢æˆä½ çš„ä¸šåŠ¡è½åœ°é€»è¾‘ï¼ˆå†™ cur + historyï¼‰
        pass
  ```
  </details>

- **äº§ç‰©è¾“å‡ºï¼šrenderer + artifacts**
  - ETF å½“å‰ç”¨ `DebateRenderer.render(...)` è¾“å‡º memo/CSV ç­‰ï¼Œå¹¶æŠŠ transcript/extra_meta æ”¾è¿›å¯å¤ç›˜äº§ç‰©
  - è¿ç§»æ–¹å¼ï¼šæ›¿æ¢ Rendererï¼ˆdocx/json/dashboard/æ•°æ®åº“å†™å…¥å‡å¯ï¼‰ï¼Œä½†å»ºè®®ç»§ç»­è¾“å‡º `artifacts: Dict[str, str]` ä½œä¸ºç»Ÿä¸€â€œäº¤ä»˜ç´¢å¼•â€

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠè¾“å‡ºä»â€œæŠ•èµ„æŠ¥å‘Šâ€æ¢æˆâ€œä½ çš„äº§ç‰©æ ¼å¼â€</b></summary>

  ```py
    # TODOï¼šæ”¹é€  _run_graph_and_render çš„ renderer
    def _run_graph_and_render(...):
        # 1) ç”¨ä½ çš„ Rendererï¼ˆä¾‹å¦‚è¾“å‡º docx/json/dashboardï¼‰
        # 2) extra_meta å»ºè®®ä¿ç•™ transcript/stop_reason/tool_traceï¼ˆå¤ç›˜å¾ˆæœ‰ç”¨ï¼‰
        # 3) artifacts ä»è¿”å› Dict[str, str]ï¼ˆè·¯å¾„æˆ–æ ‡è¯†ï¼‰
        pass
  ```
  </details>


**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
  - **ä¸åŠ¨**ï¼š
    - `DecisionAction / SkillResult / DebateLog` éª¨æ¶
    - `Renderer ä¸‰ä»¶å¥— + _build_meta å…¼å®¹`ï¼ˆè‡³å°‘èƒ½æ¥å— transcript/stop_reason/tool_traceï¼‰
    - `RoleBlock` çš„å¥‘çº¦ä¸ Engine ä¸‰æ®µç»„è£…ç»“æ„
  - **å¯æ¢**ï¼š
    - â€œä¸šåŠ¡å¯¹è±¡â€å­—æ®µï¼š(`*Decision/*Candidate/*Risk`)
    - memo æ–‡æ¡ˆç»“æ„
    - CSV åˆ—é›†åˆä¸å‘½åè§„åˆ™

</details>

---


# é˜¶æ®µä¸‰ï¼šæŠ€èƒ½ (Skills)

## å…³å¡-08ï½œå†™ Skillï¼šä»¥quantitative_sniperä¸ºä¾‹

<details>
<summary><b>Checkpoint 08 â€” å†™ Skill ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³æŠŠä¸€ä¸ª Skill ä½œä¸º**å¯è¿ç§»ã€å¯æ•™å­¦ã€å¯å®¡è®¡**çš„â€œæœ€å°äº§å“â€äº¤ä»˜
>   
> **æ•°æ®å¥‘çº¦ï¼ˆData Contractï¼‰â†’ æŒ‡æ ‡å…¬å¼ï¼ˆMetricsï¼‰â†’ å¯è¿è¡Œé€»è¾‘ï¼ˆscriptsï¼‰â†’ è¾“å‡ºæ¨¡æ¿ï¼ˆtemplatesï¼‰â†’ å•æµ‹éªŒæ”¶ï¼ˆpytestï¼‰**   



### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- å†™å‡ºä¸€ä¸ªå®Œæ•´skillæŠ€èƒ½åŒ…ï¼šåŒ…å«æ•°æ®å¥‘çº¦ã€å…¬å¼è¯´æ˜ã€è¾“å‡ºæ¨¡æ¿ä¸å¯è¿è¡Œé€»è¾‘
- Skill èƒ½é€šè¿‡ç»Ÿä¸€æ¥å£è¢«ç³»ç»Ÿè°ƒç”¨ï¼š`SkillHandler.execute(ctx, ...) -> SkillResult`
- è¾“å‡ºæ˜¯**å¼ºç±»å‹ + å¯æ ¡éªŒ**çš„ç»“æ„åŒ–ç»“æœï¼ˆitems + meta ç¨³å®šï¼‰
- ç”¨ pytest å•æµ‹éªŒè¯ï¼šè¾“å…¥ä¸€ä»½æœ€å°è¡Œæƒ…è¡¨ â†’ è¾“å‡º top_k å€™é€‰åˆ—è¡¨


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³æ”¹åŠ¨èŒƒå›´ï¼š`src/debate_mas/skills/inventory/quantitative_sniper/**`
- ä¸æ”¹ï¼š`skills/base.py` / `skills/registry.py` / `protocol` / `core/tools.py` çš„æ¥å£å¥‘çº¦ï¼›ä¸å¼•å…¥æ–°ä¾èµ–
- å¿…é¡»è¿”å›ç»“æ„åŒ–ç»“æœï¼ˆè‡³å°‘åŒ…å« `data.items`ï¼‰ï¼Œæ— æ•°æ®/ç¼ºåˆ—å¿…é¡» `fail` ä¸”ç»™å¯è§£é‡Šä¿¡æ¯


### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

#### å¿…çœ‹
- `src/debate_mas/skills/base.py`ï¼šSkill ç»Ÿä¸€æ¥å£ï¼ˆBaseFinanceSkill / SkillContext / apply_date_filterï¼‰
- `src/debate_mas/protocol`ï¼š`SkillResult / EtfCandidate` ç­‰ schemaï¼ˆä½ çš„è¾“å‡ºå¿…é¡»éµå®ˆï¼‰
- `src/debate_mas/core/tools.py`ï¼šSkill å¦‚ä½•è¢«åŒ…è£…æˆ toolï¼ˆä½ åªè¦è¾“å‡ºç¨³å®šå³å¯ï¼‰
- `src/debate_mas/skills/inventory/quantitative_sniper/`ï¼šæœ¬å…³æŠ€èƒ½åŒ…ç›®å½•ï¼ˆä½ å°†è¡¥é½å…¶â€œå¯äº¤ä»˜å½¢æ€â€ï¼‰

#### æŠ€èƒ½åŒ…ç›®å½•ç»“æ„

```md
skills/inventory/quantitative_sniper/    # [æŠ€èƒ½] é‡åŒ–ç‹™å‡»æ‰‹ (ç­›é€‰/æ’åº)
â”œâ”€â”€ __init__.py                          # åŒ…æ ‡è¯†
â”œâ”€â”€ SKILL.md                             # å®šä¹‰æŠ€èƒ½è§’è‰²ã€å‚æ•°Schemaã€Prompt
â”œâ”€â”€ references/                          # skillè¯´æ˜æ–‡æ¡£
â”‚   â”œâ”€â”€ data_contract.md                 # æ•°æ®ä¾èµ–å¥‘çº¦
â”‚   â”œâ”€â”€ metrics.md                       # æ•°å­¦å…¬å¼å®šä¹‰
â”‚   â””â”€â”€ README.md                        # æŠ€èƒ½ä½¿ç”¨/æ‹“å±•è¯´æ˜
â”œâ”€â”€ scripts/                             # æ‰§è¡Œé€»è¾‘
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ dataloader.py                    # æ•°æ®è·å–ã€æ¸…æ´—
â”‚   â”œâ”€â”€ algo.py                          # ç­–ç•¥è®¡ç®—é€»è¾‘
â”‚   â””â”€â”€ handler.py                       # æŠ€èƒ½è·¯ç”±
â””â”€â”€ templates/                           # è¾“å‡ºæ¨¡æ¿
    â”œâ”€â”€ output.json                      # ç»“æ„åŒ–è¾“å‡ºæ¨¡æ¿
    â””â”€â”€ output.md                        # è¾“å‡ºæ–‡æœ¬æ‘˜è¦æ¨¡æ¿
```

> é‡ç‚¹å­¦ä¹ ï¼š  
> - `handler.py` æ˜¯â€œç³»ç»Ÿå…¥å£ + å¥‘çº¦æ‰§è¡Œè€…â€  
> - `dataloader.py` æŠŠâ€œæ•°æ®æ¸…æ´—/å¥‘çº¦æ ¡éªŒâ€ç‹¬ç«‹å‡ºæ¥ï¼ˆä¾¿äºå¤ç”¨ä¸å•æµ‹ï¼‰  
> - `algo.py` åªæ”¾çº¯è®¡ç®—ï¼ˆçº¯å‡½æ•°é£æ ¼ï¼Œä¾¿äºæ›¿æ¢ç­–ç•¥/å¤ç”¨ç­–ç•¥ï¼‰  
> - `SKILL.md + references/* + templates/*` è®©æŠ€èƒ½å…·å¤‡â€œå¯å¤ç›˜ + å¯è¿ç§» + å¯æ•™å­¦â€çš„å®Œæ•´æ€§


#### A) `scripts/dataloader.py`

æ•°æ®åŠ è½½ä¸å¥‘çº¦æ‰§è¡Œ

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- ä» `ctx.dossier.get_table("etf_daily")` è¯»æ•°æ®
- `ref_date` é˜²æœªæ¥è¿‡æ»¤ï¼ˆç”¨ base çš„ apply_date_filter æˆ–ä¼ å…¥ï¼‰
- åˆ—åæ ‡å‡†åŒ–ï¼ˆlower + data->dateï¼‰
- ç±»å‹æ¸…æ´—ï¼šcode(str)/date(datetime)/close(float)/amount(float)
- æ£€æŸ¥å¿…éœ€åˆ—ï¼šç¼ºå¤±åˆ™ fail
- universe è¿‡æ»¤ï¼šæ”¯æŒ list / EtfCandidate-like / str(json/é€—å·)

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- è¿”å› `(df, universe_size)`ï¼Œè®© handler åš meta æ³¨å…¥

<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šscripts/dataloader.pyç»ƒä¹ éª¨æ¶</b></summary>

```py
#src/debate_mas/skills/inventory/quantitative_sniper/scripts/dataloader.py
from __future__ import annotations

import json
from typing import Any, Callable, List, Optional, Tuple, Union

import pandas as pd

from debate_mas.protocol import SkillResult
from debate_mas.skills.base import SkillContext

REQ_COLS = ("code", "date", "close")


def normalize_universe(
    universe: Optional[Union[List[str], str, list[Any]]]
) -> Optional[List[str]]:
    """
    å°† universe å…¥å‚ç»Ÿä¸€å½’ä¸€åŒ–ä¸º List[str]ï¼ˆæˆ– Noneï¼‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - universe å…è®¸ None / list / str
      - list å†…å…ƒç´ å…è®¸ï¼šstr / dict / EtfCandidate-likeï¼ˆæœ‰ symbol å±æ€§ï¼‰
      - str å…è®¸ï¼šJSON list å­—ç¬¦ä¸² æˆ– é€—å·åˆ†éš”å­—ç¬¦ä¸²
      - å»é‡ + strip + è¿‡æ»¤ç©ºå€¼

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - æ”¯æŒæ¢è¡Œåˆ†éš”ï¼ˆæŠŠ "\\n" å½“ä½œ ","ï¼‰
      - æ”¯æŒè¾“å…¥ä¸ºå•ä¸ªæ•°å­—/å­—ç¬¦ä¸²çš„ JSONï¼ˆå¦‚ '"510300"' / 510300ï¼‰

    Args:
        universe: ç”¨æˆ·ä¼ å…¥çš„å€™é€‰èŒƒå›´ï¼ˆNone è¡¨ç¤ºå…¨å¸‚åœºï¼‰

    Returns:
        codes: å½’ä¸€åŒ–åçš„ ETF code åˆ—è¡¨ï¼›ä¸ºç©ºåˆ™è¿”å› None
    """
    # TODO
    raise NotImplementedError


def load_etf_daily(
    ctx: SkillContext,
    universe: Optional[Union[List[str], str, list[Any]]],
    *,
    apply_date_filter: Callable[[pd.DataFrame, str], pd.DataFrame],
) -> Tuple[pd.DataFrame, Optional[int]] | SkillResult:
    """
    ä» dossier è¯»å– etf_dailyï¼Œå¹¶æ‰§è¡Œæ•°æ®å¥‘çº¦ä¸æ¸…æ´—ï¼Œè¿”å›å¯ç”¨äºç­–ç•¥è®¡ç®—çš„ dfã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      1) è¯»æ•°æ®ï¼š
         - df = ctx.dossier.get_table("etf_daily")
         - df None/empty -> SkillResult.fail(å¯è§£é‡ŠåŸå› )

      2) é˜²æœªæ¥è¿‡æ»¤ï¼š
         - ä½¿ç”¨ apply_date_filter(df, ctx.ref_date)
         - è¿‡æ»¤å empty -> SkillResult.fail(è¯´æ˜ ref_date æˆªæ­¢æ— æ•°æ®)

      3) åˆ—åæ ‡å‡†åŒ–ï¼š
         - columns å…¨éƒ¨ lower + strip
         - å…¼å®¹ data -> dateï¼ˆå½“ date ä¸å­˜åœ¨è€Œ data å­˜åœ¨æ—¶ï¼‰

      4) ç±»å‹æ¸…æ´—ï¼š
         - code -> str
         - date -> datetimeï¼ˆerrors="coerce"ï¼‰
         - close -> numericï¼ˆerrors="coerce"ï¼‰
         - amount è‹¥å­˜åœ¨ -> numericï¼ˆerrors="coerce"ï¼‰
         - æ¸…æ´—å¼‚å¸¸ -> SkillResult.fail(åŒ…å«å¼‚å¸¸ä¿¡æ¯)

      5) å¿…éœ€åˆ—æ£€æŸ¥ï¼š
         - ç¼ºå¤± REQ_COLS ä»»ä¸€é¡¹ -> SkillResult.fail(æ˜ç¡®ç¼ºå“ªäº›åˆ—)
         - dropna(subset=REQ_COLS) å empty -> SkillResult.fail(è¯´æ˜æ¸…æ´—åæ— æœ‰æ•ˆæ•°æ®)

      6) universe è¿‡æ»¤ï¼š
         - universe_list = normalize_universe(universe)
         - è‹¥å­˜åœ¨ universe_setï¼šåªä¿ç•™ df["code"] âˆˆ universe_set
         - è¿‡æ»¤å empty -> SkillResult.fail(æ˜ç¡®â€œuniverse æœ‰å¤šå°‘ï¼Œä½†æ— åŒ¹é…â€)

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - è¿”å› universe_sizeï¼ˆNone è¡¨ç¤ºå…¨å¸‚åœºï¼›å¦åˆ™è¿”å› len(universe_set)ï¼‰
      - å¯¹ df åšæœ€å°æ’åºï¼ˆä¾‹å¦‚æŒ‰ date å‡åºï¼‰ï¼Œä¾¿äºä¸‹æ¸¸ groupby

    Args:
        ctx: SkillContextï¼ˆå¿…é¡»èƒ½æä¾› dossier ä¸ ref_dateï¼‰
        universe: å€™é€‰æ± ï¼ˆNone=å…¨å¸‚åœºï¼›å¯ä¸º list/str/EtfCandidate-likeï¼‰
        apply_date_filter: é˜²æœªæ¥è¿‡æ»¤å‡½æ•°ï¼ˆç”± Skill/base æä¾›æˆ–ç”±ä¸Šå±‚æ³¨å…¥ï¼‰

    Returns:
        (df, universe_size):
          - df: æ¸…æ´—åçš„è¡Œæƒ…è¡¨ï¼ˆè‡³å°‘åŒ…å« code/date/closeï¼›amount å¯é€‰ï¼‰
          - universe_size: None æˆ– intï¼ˆä»…å½“ä¼ å…¥ universe ä¸”æˆåŠŸè¿‡æ»¤æ—¶ï¼‰
        æˆ– SkillResult.fail(...):
          - åœ¨ç¼ºè¡¨/ç¼ºåˆ—/æ¸…æ´—å¤±è´¥/universe æ— åŒ¹é…ç­‰æƒ…å†µä¸‹è¿”å›
    """
    # TODO
    raise NotImplementedError
```
</details>


#### B) `scripts/algo.py`

çº¯ç­–ç•¥è®¡ç®—ï¼šdf -> df_score

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- æ¯ä¸ªç­–ç•¥è¾“å‡º `df_score`ï¼Œè‡³å°‘åŒ…å«ï¼š
  - `symbol, score, reason, extra`
- score ç»Ÿä¸€æ˜ å°„åˆ° 0~100 percentile
- threshold é€»è¾‘ï¼ˆquantile / psrï¼‰è¦è¿”å› attrs.meta

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- æä¾› `run_strategy(df, params)` è·¯ç”±


<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šscripts/algo.pyç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/skills/inventory/quantitative_sniper/scripts/algo.py
from __future__ import annotations

from typing import Any, Dict, List, Optional

import pandas as pd

# ============================================================
# TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘
# - è¿™é‡Œæ˜¯â€œçº¯è®¡ç®—å±‚â€ï¼šä¸è¯» ctxã€ä¸åš failï¼ˆäº¤ç»™ handler/dataloaderï¼‰
# - æ¯ä¸ªç­–ç•¥å‡½æ•°éƒ½å¿…é¡»è¿”å› df_scoreï¼ˆæˆ–ç©º dfï¼‰
# - df_score è‡³å°‘åŒ…å«ï¼šsymbol, score, reason, extra
# - score å¿…é¡»ç»Ÿä¸€æ˜ å°„åˆ° 0~100ï¼ˆpercentileï¼‰
# - threshold é€»è¾‘ï¼ˆquantile / psrï¼‰éœ€è¦æŠŠ meta å†™å…¥ df_score.attrs["threshold_meta"]
# ============================================================

# ============================================================
# TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘
# - æä¾› run_strategy(df, params) ä½œä¸ºç»Ÿä¸€è·¯ç”±
# - æä¾› user_defined_strategy(df, params) ä½œä¸ºç»ƒä¹ å…¥å£
# ============================================================


def pct_rank_0_100(values: pd.Series, *, neutral: float = 50.0) -> pd.Series:
    """
    å°†æ¨ªæˆªé¢æ•°å€¼æ˜ å°„ä¸º [0,100] åˆ†ä½å¾—åˆ†ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - è½¬ numericï¼ˆerrors="coerce"ï¼‰
      - rank(pct=True) * 100
      - NaN ç”¨ neutral å¡«å……ï¼ˆå…¨ NaN -> å…¨ neutralï¼‰

    Args:
        values: ä¸€ç»„æ¨ªæˆªé¢æ•°å€¼
        neutral: ç¼ºå¤±æ—¶çš„ä¸­æ€§å¾—åˆ†ï¼ˆé»˜è®¤ 50ï¼‰

    Returns:
        scores: ä¸ values ç­‰é•¿çš„åˆ†ä½å¾—åˆ†ï¼ˆ0~100ï¼‰
    """
    # TODO
    raise NotImplementedError


def apply_threshold_quantile(
    df_score: pd.DataFrame,
    *,
    top_k: int,
    quantile_q: Optional[float],
    enabled: bool,
) -> pd.DataFrame:
    """
    åˆ†ä½é˜ˆå€¼è¿‡æ»¤ï¼šæŠŠ score ä½äº cutoff çš„æ ·æœ¬è¿‡æ»¤æ‰ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - enabled=False æˆ– df_score empty -> åŸæ ·è¿”å›
      - quantile_q=None æ—¶ï¼šç”¨ top_k è‡ªåŠ¨æ¨å¯¼ä¸€ä¸ª q
      - è®¡ç®— cutoff = score.quantile(q)
      - è¿‡æ»¤åä¸è¶³ top_kï¼šå›é€€ä¸åšè¿‡æ»¤ï¼ˆè¿”å›åŸ df_scoreï¼‰
      - æ— è®ºæ˜¯å¦è¿‡æ»¤ï¼Œéƒ½åº”å†™ df_score.attrs["threshold_meta"]ï¼ˆåŒ…å« q/cutoff/passed/before/fallbackï¼‰

    Args:
        df_score: è‡³å°‘åŒ…å« score åˆ—çš„æ•°æ®æ¡†
        top_k: æœŸæœ›è¿”å›æ•°é‡
        quantile_q: æ‰‹åŠ¨åˆ†ä½é˜ˆå€¼ï¼ˆ0~1ï¼‰ï¼›None è¡¨ç¤ºè‡ªåŠ¨æ¨å¯¼
        enabled: æ˜¯å¦å¯ç”¨

    Returns:
        out: è¿‡æ»¤åçš„ df_scoreï¼ˆå¹¶å¸¦ attrs["threshold_meta"]ï¼‰
    """
    # TODO
    raise NotImplementedError


def apply_threshold_psr(
    df_score: pd.DataFrame,
    *,
    top_k: int,
    psr_confidence: float,
) -> pd.DataFrame:
    """
    PSR é˜ˆå€¼è¿‡æ»¤ï¼šä»…ä¿ç•™ psr >= confidence çš„æ ·æœ¬ï¼Œä¸è¶³ top_k æ—¶æ”¾å®½æˆ–å›é€€ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å…ˆæŒ‰ psr_confidence è¿‡æ»¤
      - è‹¥ä¸è¶³ top_kï¼šæ”¾å®½åˆ°ä¸€ä¸ªè¾ƒä½é˜ˆå€¼ï¼›ä»ä¸ºç©ºåˆ™å›é€€ä¸ºä¸è¿‡æ»¤
      - å†™ attrs["threshold_meta"]ï¼ˆconfidence/effective/fallback/passed/beforeï¼‰

    Args:
        df_score: è‡³å°‘åŒ…å« psr åˆ—ä¸ score åˆ—çš„æ•°æ®æ¡†
        top_k: æœŸæœ›è¿”å›æ•°é‡
        psr_confidence: ç½®ä¿¡åº¦é˜ˆå€¼ï¼ˆ0~1ï¼‰

    Returns:
        out: è¿‡æ»¤åçš„ df_scoreï¼ˆå¹¶å¸¦ attrs["threshold_meta"]ï¼‰
    """
    # TODO
    raise NotImplementedError


def scan_momentum(df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    """
    åŠ¨é‡ç­–ç•¥ï¼šæ ¹æ®çª—å£æ”¶ç›Šï¼ˆæˆ–ä½ å®šä¹‰çš„åŠ¨é‡ rawï¼‰è®¡ç®— scoreã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ä» params è¯»å– window/top_k/threshold_mode/quantile_q ç­‰
      - å¯¹æ¯ä¸ª symbol è®¡ç®—ä¸€ä¸ª raw æŒ‡æ ‡ï¼ˆå¦‚çª—å£æ”¶ç›Šï¼‰
      - raw -> pct_rank_0_100 -> score
      - ç”Ÿæˆ reasonï¼ˆå« window ä¸å…³é”® raw/pct ä¿¡æ¯ï¼‰
      - extra å­—å…¸å¿…é¡»åŒ…å« raw ä¸ pctï¼ˆç”¨äºå¯è§£é‡Šä¸å®¡è®¡ï¼‰
      - threshold_mode=="quantile" æ—¶è°ƒç”¨ apply_threshold_quantile
      - è¿”å› df_scoreï¼ˆç©ºåˆ™è¿”å›ç©º dfï¼‰

    Args:
        df: é¢„å¤„ç†åçš„è¡Œæƒ…è¡¨ï¼ˆè‡³å°‘åŒ…å« code/date/closeï¼‰
        params: ç­–ç•¥å‚æ•°ï¼ˆwindow/top_k/threshold_mode ç­‰ï¼‰

    Returns:
        df_score: è‡³å°‘åŒ…å« symbol/score/reason/extra çš„ DataFrame
    """
    # TODO
    raise NotImplementedError


def select_by_sharpe(df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    """
    å¤æ™®ç­–ç•¥ï¼šè®¡ç®— SRï¼Œå¹¶å¯ç»“åˆ PSR å¾—åˆ°å»å™ªåçš„æ’åºæŒ‡æ ‡ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - è®¡ç®—æ”¶ç›Šåºåˆ—ï¼ˆpct_changeï¼‰å¹¶å¾—åˆ° sr_hat
      - è®¡ç®— psrï¼ˆéœ€è¦ n/skew/kurt ç­‰ï¼‰
      - å®šä¹‰æ’åºç”¨çš„ adjusted æŒ‡æ ‡ï¼ˆä¾‹å¦‚ sr_hat ä¸ psr çš„ç»„åˆï¼‰
      - adjusted -> pct_rank_0_100 -> score
      - threshold_mode=="psr" æ—¶è°ƒç”¨ apply_threshold_psr
      - ç”Ÿæˆ reason/extraï¼ˆextra è‡³å°‘åŒ…å« sr/psr/adjusted/pctï¼‰

    Args:
        df: é¢„å¤„ç†åçš„è¡Œæƒ…è¡¨
        params: ç­–ç•¥å‚æ•°ï¼ˆwindow/top_k/threshold_mode/psr_confidence/psr_ref_sharpe ç­‰ï¼‰

    Returns:
        df_score: è‡³å°‘åŒ…å« symbol/score/reason/extra çš„ DataFrame
    """
    # TODO
    raise NotImplementedError


def scan_reversal(df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    """
    åè½¬ç­–ç•¥ï¼šåŸºäºå‡çº¿ä¹–ç¦»/è¶…è·Œç¨‹åº¦ç”Ÿæˆ scoreã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - è®¡ç®— bias æˆ–å…¶ä»–è¶…è·ŒæŒ‡æ ‡ï¼Œå¹¶è½¬æˆâ€œè¶Šè¶…è·Œè¶Šé«˜â€çš„ raw
      - raw -> pct_rank_0_100 -> score
      - å¯é€‰ï¼šåªä¿ç•™ raw>0 çš„æ ·æœ¬ï¼ˆä½“ç°â€œè¶…è·Œæ‰å…¥é€‰â€ï¼‰
      - threshold_mode=="quantile" æ—¶è°ƒç”¨ apply_threshold_quantile
      - reason/extra éœ€åŒ…å« bias/raw/pct ç­‰å…³é”®å˜é‡

    Args:
        df: é¢„å¤„ç†åçš„è¡Œæƒ…è¡¨
        params: ç­–ç•¥å‚æ•°

    Returns:
        df_score: è‡³å°‘åŒ…å« symbol/score/reason/extra çš„ DataFrame
    """
    # TODO
    raise NotImplementedError


def scan_composite(df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    """
    ä¸‰å› å­èåˆï¼šå°†å¤šä¸ªå› å­çš„åˆ†ä½å¾—åˆ†åŠ æƒæ±‡æ€»æˆæœ€ç»ˆ scoreã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - åˆ†åˆ«è®¡ç®—å¤šä¸ª rawï¼ˆå¦‚ mom_raw / sharpe_adj / rev_rawï¼‰
      - åˆ†åˆ«è½¬æˆ pctï¼ˆç¼ºå¤± -> neutral=50ï¼‰
      - è¯»å–/å½’ä¸€åŒ–æƒé‡ composite_weightsï¼ˆsum=1ï¼‰
      - score = Î£ w_i * pct_i
      - reason éœ€è¦èƒ½è§£é‡Šâ€œå„å› å­è´¡çŒ®â€
      - extra éœ€åŒ…å«ï¼šraw/pct/weights/score ç­‰
      - threshold_mode=="quantile" æ—¶è°ƒç”¨ apply_threshold_quantile

    Args:
        df: é¢„å¤„ç†åçš„è¡Œæƒ…è¡¨
        params: ç­–ç•¥å‚æ•°ï¼ˆwindow/top_k/composite_weights ç­‰ï¼‰

    Returns:
        df_score: è‡³å°‘åŒ…å« symbol/score/reason/extra çš„ DataFrame
    """
    # TODO
    raise NotImplementedError


def user_defined_strategy(df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    """
    å­¦ç”Ÿç»ƒä¹ å…¥å£ï¼šè‡ªå®šä¹‰ä¸€ä¸ªæŒ‡æ ‡å¹¶è¾“å‡º df_scoreã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å¿…é¡»è¿”å› df_scoreï¼Œä¸”åŒ…å« symbol/score/reason/extra
      - score ä»éœ€æ˜ å°„åˆ° 0~100 percentile
      - extra å¿…é¡»åŒ…å«ä½ çš„å…³é”®ä¸­é—´å˜é‡ï¼ˆä¾¿äºè®²è§£/è¯„åˆ†ï¼‰

    Args:
        df: é¢„å¤„ç†åçš„è¡Œæƒ…è¡¨
        params: ç­–ç•¥å‚æ•°ï¼ˆwindow/top_k ç­‰ï¼‰

    Returns:
        df_score: è‡³å°‘åŒ…å« symbol/score/reason/extra çš„ DataFrame
    """
    # TODO
    raise NotImplementedError


def run_strategy(df: pd.DataFrame, params: Dict[str, Any]) -> pd.DataFrame:
    """
    ç­–ç•¥è·¯ç”±ï¼šæ ¹æ® params["strategy"] è°ƒç”¨å¯¹åº”ç­–ç•¥å‡½æ•°ã€‚

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - åšä¸€ä¸ªæ¸…æ™°çš„ dispatchï¼ˆif/elif æˆ– dict æ˜ å°„ï¼‰
      - unknown strategy -> raise ValueErrorï¼ˆäº¤ç»™ handler æ•è·å¹¶ failï¼‰

    Args:
        df: é¢„å¤„ç†åçš„è¡Œæƒ…è¡¨
        params: ç­–ç•¥å‚æ•°ï¼ˆå¿…é¡»åŒ…å« strategyï¼‰

    Returns:
        df_score: å¯¹åº”ç­–ç•¥è¾“å‡ºçš„ df_score
    """
    # TODO
    raise NotImplementedError

```
</details>


#### C) `scripts/handler.py`ï¼ˆSkill ç³»ç»Ÿå…¥å£ï¼šexecuteï¼‰
**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `execute(ctx, ...)` è´Ÿè´£ï¼š
  1) è°ƒ dataloader æ‹¿åˆ° clean df + universe_sizeï¼ˆæˆ– failï¼‰
  2) ç»„è£… paramsï¼ˆstrategy/window/top_k/min_amount/...ï¼‰
  3) è°ƒ algo.run_strategy å¾—åˆ° df_score
  4) æ’åºæˆªæ–­ top_kï¼Œå°è£…ä¸º `EtfCandidate` åˆ—è¡¨
  5) è¿”å› `SkillResult.ok(data={type/items/meta}, insight=...)`
- ç©ºç»“æœå¿…é¡»è¿”å› okï¼ˆitems=[]ï¼‰ï¼Œä½† insight è¦è§£é‡Šâ€œä¸ºä»€ä¹ˆä¸ºç©ºâ€
- å¼‚å¸¸è¦è½¬æˆ `SkillResult.fail("å¯è§£é‡Šä¿¡æ¯")`ï¼ˆä¸è¦ silentï¼‰

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- ä¿ç•™ `user_defined` ç­–ç•¥ç»ƒä¹ å…¥å£ï¼šfail æˆ– NotImplemented å‡å¯ï¼Œä½†ä¿¡æ¯è¦æ˜ç¡®


<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šscripts/handler.pyç»ƒä¹ éª¨æ¶</b></summary>

```py
# scripts/handler.py
from __future__ import annotations

from typing import Any, Dict, List, Literal, Optional, Union

import pandas as pd

from debate_mas.protocol import EtfCandidate, SkillResult
from debate_mas.skills.base import BaseFinanceSkill, SkillContext

from .dataloader import load_etf_daily
from .algo import run_strategy

Strategy = Literal["momentum", "sharpe", "reversal", "composite", "user_defined"]


class SkillHandler(BaseFinanceSkill):
    """
    Skill ç³»ç»Ÿå…¥å£ï¼šè´Ÿè´£æŠŠ â€œæ•°æ® -> ç­–ç•¥ -> EtfCandidateListâ€ ä¸²èµ·æ¥ã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘
    - execute(ctx, ...) è´Ÿè´£ï¼š
      1) è°ƒ dataloader æ‹¿åˆ° clean df + universe_sizeï¼ˆæˆ– failï¼‰
      2) ç»„è£… paramsï¼ˆstrategy/window/top_k/min_amount/...ï¼‰
      3) è°ƒ algo.run_strategy å¾—åˆ° df_score
      4) æ’åºæˆªæ–­ top_kï¼Œå°è£…ä¸º EtfCandidate åˆ—è¡¨
      5) è¿”å› SkillResult.ok(data={type/items/meta}, insight=...)

    - ç©ºç»“æœå¿…é¡»è¿”å› okï¼ˆitems=[]ï¼‰ï¼Œä½† insight è¦è§£é‡Šâ€œä¸ºä»€ä¹ˆä¸ºç©ºâ€
    - å¼‚å¸¸è¦è½¬æˆ SkillResult.fail("å¯è§£é‡Šä¿¡æ¯")ï¼ˆä¸è¦ silentï¼‰

    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘
    - ä¿ç•™ user_defined ç­–ç•¥ç»ƒä¹ å…¥å£ï¼šfail æˆ– NotImplemented å‡å¯ï¼Œä½†ä¿¡æ¯è¦æ˜ç¡®
    """

    def execute(
        self,
        ctx: SkillContext,
        strategy: Strategy = "momentum",
        window: int = 20,
        top_k: int = 5,
        min_amount: float = 0.0,
        universe: Optional[Union[List[str], str, list[Any]]] = None,
        liquidity_filter: Literal["amount_latest", "amihud"] = "amount_latest",
        amount_scale: float = 1000.0,
        illiq_quantile: float = 0.8,
        threshold_mode: Literal["none", "quantile", "psr"] = "none",
        quantile_q: Optional[float] = None,
        psr_confidence: float = 0.95,
        psr_ref_sharpe: float = 0.0,
        composite_weights: Optional[Union[Dict[str, float], str]] = None,
        **kwargs: Any,
    ) -> SkillResult:
        """
        Args:
            ctx:
                - ctx.dossier: è¯»å–æ¡ˆå·æ•°æ®ï¼ˆè‡³å°‘åŒ…å« etf_daily è¡¨ï¼‰
                - ctx.ref_date: é˜²æœªæ¥åˆ‡ç‰‡ä½¿ç”¨
                - ctx.agent_role: å¯å†™å…¥ metaï¼ˆå¯é€‰ï¼‰
            strategy:
                - ç­–ç•¥åç§°ï¼ˆéœ€ä¸ algo.run_strategy æ”¯æŒçš„ç­–ç•¥å¯¹é½ï¼‰
            window/top_k/min_amount/...:
                - ç­–ç•¥/è¿‡æ»¤/é˜ˆå€¼ç›¸å…³å‚æ•°ï¼ˆéœ€è¦æ‰“åŒ…è¿› params ä¼ ç»™ algoï¼‰
            universe:
                - None / list / dict-like / EtfCandidate-like / str(json/é€—å·)ï¼ˆç”± dataloader è´Ÿè´£è§£æï¼‰
            **kwargs:
                - é¢„ç•™æ‰©å±•ä½ï¼ˆå¯å¿½ç•¥æˆ–å†™å…¥ metaï¼‰

        Returns:
            SkillResult:
              - ok: data.type == "EtfCandidateList"
              - fail: åŒ…å«å¯è§£é‡Šé”™è¯¯ä¿¡æ¯ï¼ˆç¼ºè¡¨/ç¼ºåˆ—/å¼‚å¸¸ç­‰ï¼‰
        """
        try:
            # 1) Data: dataloaderï¼ˆå¥‘çº¦/æ¸…æ´—/é˜²æœªæ¥/universeï¼‰
            # TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
            # - è°ƒç”¨ load_etf_daily(ctx, universe, apply_date_filter=...)
            # - å¤„ç†è¿”å›å€¼ï¼š
            #   - è‹¥è¿”å› SkillResultï¼ˆfailï¼‰ï¼Œç›´æ¥ return
            #   - è‹¥è¿”å› (df, universe_size)ï¼Œç»§ç»­æ‰§è¡Œ
            loaded = load_etf_daily(
                ctx=ctx,
                universe=universe,
                apply_date_filter=self.apply_date_filter, 
            )
            if isinstance(loaded, SkillResult):
                return loaded
            df, universe_size = loaded  # df: clean DataFrame

            # 2) Params: ç»„è£…ç­–ç•¥å‚æ•°ï¼ˆä¼ ç»™ algoï¼‰
            # TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
            # - å¿…é¡»åŒ…å« strategy/window/top_k
            # - æŠŠ liquidity/threshold/composite ç­‰å‚æ•°ä¸€å¹¶ä¼ ä¸‹å»
            # - æŠŠ ref_date/universe_size ç­‰å†™å…¥ metaï¼ˆå¯é€‰ï¼Œä½†å»ºè®®ï¼‰
            params: Dict[str, Any] = {
                "strategy": strategy,
                "window": int(window),
                "top_k": int(top_k),
                "min_amount": float(min_amount),
                "liquidity_filter": str(liquidity_filter),
                "amount_scale": float(amount_scale),
                "illiq_quantile": float(illiq_quantile),
                "threshold_mode": str(threshold_mode),
                "quantile_q": quantile_q,
                "psr_confidence": float(psr_confidence),
                "psr_ref_sharpe": float(psr_ref_sharpe),
                "composite_weights": composite_weights,
                # meta-onlyï¼ˆå¯é€‰ï¼‰
                "ref_date": ctx.ref_date,
                "universe_size": universe_size,
                "agent_role": getattr(ctx, "agent_role", None),
            }

            # 3) Algo: çº¯è®¡ç®— df -> df_score
            # TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
            # - è°ƒ run_strategy(df, params)
            # - df_score è‡³å°‘åº”åŒ…å« symbol/score/reason/extra
            df_score = run_strategy(df, params)

            # 4) Pack: df_score -> EtfCandidateList
            # TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
            # - df_score å¯èƒ½ä¸ºç©ºï¼šå¿…é¡»è¿”å› ok(items=[]) + å¯è§£é‡Š insight
            # - éç©ºï¼š
            #   - æŒ‰ score desc æ’åº
            #   - head(top_k) æˆªæ–­
            #   - æ¯è¡Œ -> EtfCandidate(symbol/score/reason/source_skill/extra)
            # - threshold_metaï¼šä» df_score.attrs["threshold_meta"] è¯»å–å¹¶å†™å…¥ meta/extra
            candidates: List[EtfCandidate] = []

            # TODO: å¤„ç†ç©º df_scoreï¼ˆå¿…é¡» okï¼‰
            if df_score is None or df_score.empty:
                return SkillResult.ok(
                    data={
                        "type": "EtfCandidateList",
                        "items": [],
                        "meta": {
                            "strategy": strategy,
                            "window": int(window),
                            "top_k": int(top_k),
                            "universe_size": universe_size,
                            "liquidity_filter": str(liquidity_filter),
                            "threshold_mode": str(threshold_mode),
                            "threshold_meta": None,
                            "score_scale": "percentile_0_100",
                            "ref_date": ctx.ref_date,
                        },
                    },
                    insight="TODO: è§£é‡Šä¸ºç©ºçš„åŸå› ï¼ˆå¦‚ï¼šæ ·æœ¬ä¸è¶³/è¿‡æ»¤è¿‡ä¸¥/æ•°æ®ç¼ºå¤±/é˜ˆå€¼å›é€€ç­‰ï¼‰ã€‚",
                )

            # TODO: æ’åº + æˆªæ–­
            df_top = (
                df_score.sort_values("score", ascending=False)
                .head(int(top_k))
                .copy()
            )

            # TODO: è¯»å–é˜ˆå€¼ metaï¼ˆå¦‚ algo å†™å…¥ attrsï¼‰
            threshold_meta = getattr(df_score, "attrs", {}).get("threshold_meta")

            # TODO: è¡Œ -> EtfCandidateï¼ˆæ³¨æ„ extra åˆå¹¶ï¼šå…¨å±€ meta + å•æ ‡çš„ extraï¼‰
            for _, row in df_top.iterrows():
                symbol = str(row["symbol"])
                score = float(row["score"])
                reason = str(row.get("reason", ""))

                item_extra = row.get("extra", None)
                if not isinstance(item_extra, dict):
                    item_extra = {}

                merged_extra = {
                    "strategy": strategy,
                    "window": int(window),
                    "liquidity_filter": str(liquidity_filter),
                    "threshold_mode": str(threshold_mode),
                    "threshold_meta": threshold_meta,
                    "universe_size": universe_size,
                    "score_scale": "percentile_0_100",
                    **item_extra,
                }

                candidates.append(
                    EtfCandidate(
                        symbol=symbol,
                        score=score,
                        reason=reason,
                        source_skill="quantitative_sniper",  # æœ¬å…³å›ºå®šï¼›è¿ç§»æ—¶å†æ”¹ TODO å†™æˆä½ çš„ skill åç§°
                        extra=merged_extra,
                    )
                )

            # 5) Return: SkillResult.ok
            # TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
            # - data å¿…é¡»åŒ…å« type/items/meta
            # - insight ç®€æ´æ€»ç»“ï¼šèŒƒå›´/ç­–ç•¥/æ•°é‡/é¦–é€‰/é˜ˆå€¼ä¿¡æ¯
            data = {
                "type": "EtfCandidateList",
                "items": [c.model_dump() for c in candidates],
                "meta": {
                    "strategy": strategy,
                    "window": int(window),
                    "top_k": int(len(candidates)),
                    "universe_size": universe_size,
                    "liquidity_filter": str(liquidity_filter),
                    "threshold_mode": str(threshold_mode),
                    "threshold_meta": threshold_meta,
                    "score_scale": "percentile_0_100",
                    "ref_date": ctx.ref_date,
                },
            }

            insight = "TODO: ç”Ÿæˆä¸€å¥å¯è§£é‡Šæ‘˜è¦ï¼ˆåŒ…å«æ•°é‡ã€é¦–é€‰æ ‡çš„ã€æ˜¯å¦è§¦å‘é˜ˆå€¼/å›é€€ç­‰ï¼‰ã€‚"
            return SkillResult.ok(data=data, insight=insight)

        except NotImplementedError as e:
            # TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘: user_defined æœªå®ç°æ—¶ç»™å‡ºæ˜ç¡®æŠ¥é”™
            return SkillResult.fail(f"TODO: è‡ªå®šä¹‰ç­–ç•¥æœªå®ç°ï¼š{e}")

        except Exception as e:
            # TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘: æ•è·å¼‚å¸¸å¹¶è½¬ failï¼ˆä¸è¦ silentï¼‰
            return SkillResult.fail(f"TODO: æ‰§è¡Œå¤±è´¥ï¼ˆå¯è§£é‡Šä¿¡æ¯ï¼‰ï¼š{e}")
```
</details>


#### D) `SKILL.md`ï¼ˆæŠ€èƒ½â€œå¯¹å¤–è¯´æ˜ + å‚æ•° Schema + è°ƒç”¨çº¦æŸâ€ï¼‰
**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- å›ºå®šå­—æ®µï¼šname / role / version / outputs.type
- è¯´æ˜è¯¥æŠ€èƒ½ï¼š
  - ä¾èµ–è¡¨ï¼š`etf_daily`
  - æœ€å°å¿…éœ€åˆ—ï¼š`code/date/close`
  - è¾“å‡ºç±»å‹ï¼š`EtfCandidateList`
  - score ç»Ÿä¸€å°ºåº¦ï¼š0~100 percentile

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- å†™å‡ºç­–ç•¥æšä¸¾ï¼šmomentum/sharpe/reversal/composite/user_defined
- å†™å‡ºé˜ˆå€¼æ¨¡å¼ï¼šnone/quantile/psrï¼ˆpsr ä»… sharpeï¼‰

> è¿™ä»½æ–‡ä»¶ä¼šæˆä¸ºâ€œæŠŠæŠ€èƒ½è¿ç§»åˆ°åˆ«çš„ä¸šåŠ¡â€çš„å…¥å£æ–‡æ¡£ï¼Œæ‰€ä»¥å­—æ®µå°½é‡ç¨³å®šã€‚

<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šSKILL.mdç»ƒä¹ éª¨æ¶</b></summary>

```md
---
name: TODO_skill_name
chinese_name: TODO_ä¸­æ–‡å
version: TODO_semver
role: TODO_role
group: TODO_group
tags: [TODO, TODO]
description: >
  TODOï¼šä¸€å¥è¯è¯´æ˜è¿™æ˜¯åšä»€ä¹ˆçš„æŠ€èƒ½ï¼ˆé¢å‘è¿ç§»/å¤ç”¨åœºæ™¯ï¼Œå°½é‡ç¨³å®šï¼‰ã€‚

outputs:
  type: EtfCandidateList

data_dependencies:
  - table: etf_daily
    required_columns: [code, date, close]
    optional_columns: [TODO_optional_cols]

schema_notes: >
  TODOï¼šè¯´æ˜è¿”å›ç»“æ„çš„ç¨³å®šå­—æ®µï¼ˆitems/meta/extra çº¦å®šï¼‰ï¼Œä»¥åŠå¯è¿½æº¯æ€§è®¾è®¡ï¼ˆraw/pct/threshold_metaï¼‰ã€‚
---

# SKILLï¼ˆå¯¹å¤–è¯´æ˜ï¼‰

> æœ¬æ–‡æ¡£æ˜¯æŠ€èƒ½è¿ç§»/å¤ç”¨çš„å…¥å£è¯´æ˜ï¼šæè¿°â€œä¾èµ–ä»€ä¹ˆæ•°æ®ã€æ€ä¹ˆè°ƒç”¨ã€è¿”å›ä»€ä¹ˆã€æœ‰å“ªäº›çº¦æŸâ€ã€‚

---

## TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘

### 1) å›ºå®šå­—æ®µï¼ˆè¿ç§»ç¨³å®šé”šç‚¹ï¼‰
- **name**: TODO
- **role**: TODO
- **version**: TODO
- **outputs.type**: `EtfCandidateList`ï¼ˆå›ºå®šï¼‰

### 2) æ•°æ®ä¾èµ–ï¼ˆData Dependenciesï¼‰
- ä¾èµ–è¡¨ï¼š`etf_daily`
- æœ€å°å¿…éœ€åˆ—ï¼š`code` / `date` / `close`
- TODOï¼šè¯´æ˜å­—æ®µè¯­ä¹‰ä¸ç±»å‹çº¦æŸ
  - `code`: TODOï¼ˆç±»å‹/æ ¼å¼ï¼‰
  - `date`: TODOï¼ˆç±»å‹/æ—¶åŒº/è§£æï¼‰
  - `close`: TODOï¼ˆç±»å‹/å•ä½ï¼‰
- TODOï¼šè¯´æ˜ç¼ºåˆ—è¡Œä¸ºï¼š**å¿…é¡» fail ä¸”å¯è§£é‡Š**ï¼ˆä¸¾ä¾‹è¯´æ˜ï¼‰

### 3) é˜²æœªæ¥ï¼ˆRef Date Constraintï¼‰
- TODOï¼šè¯´æ˜ `ref_date` çš„ä½œç”¨ï¼ˆåªå…è®¸ä½¿ç”¨ ref_date åŠä¹‹å‰çš„æ•°æ®ï¼‰
- TODOï¼šè¯´æ˜å¦‚æœ ref_date ç¼ºå¤±/éæ³•çš„è¡Œä¸ºï¼ˆfail æˆ–é»˜è®¤ç­–ç•¥ï¼‰

### 4) è¾“å‡ºç±»å‹ï¼ˆOutputsï¼‰
- è¾“å‡ºç±»å‹ï¼š`EtfCandidateList`
- `score` ç»Ÿä¸€å°ºåº¦ï¼š**0~100 percentile**
- TODOï¼šè¯´æ˜ items çš„æœ€å°å­—æ®µé›†ï¼š
  - `symbol`
  - `score`
  - `reason`
  - `source_skill`
  - `extra`
- TODOï¼šè¯´æ˜ meta çš„æœ€å°å­—æ®µé›†ï¼ˆå¿…é¡»ç¨³å®šï¼‰ï¼š
  - `strategy`
  - `window`
  - `top_k`
  - `universe_size`
  - `threshold_mode`
  - `threshold_meta`
  - `score_scale`
  - `ref_date`

---

## TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘

### 5) ç­–ç•¥æšä¸¾ï¼ˆStrategy Enumï¼‰
- TODOï¼šåˆ—å‡ºç­–ç•¥æšä¸¾å¹¶ç®€è¿°ç”¨é€”ï¼ˆä¿æŒç¨³å®šå‘½åï¼‰
  - `momentum`
  - `sharpe`
  - `reversal`
  - `composite`
  - `user_defined`ï¼ˆç»ƒä¹ /æ‰©å±•å…¥å£ï¼‰

### 6) é˜ˆå€¼æ¨¡å¼ï¼ˆThreshold Modeï¼‰
- TODOï¼šåˆ—å‡ºé˜ˆå€¼æ¨¡å¼å¹¶è¯´æ˜ä¸ç­–ç•¥çš„å…¼å®¹å…³ç³»
  - `none`
  - `quantile`
  - `psr`ï¼ˆTODOï¼šå¼ºè°ƒä»…å¯¹ sharpe ç”Ÿæ•ˆï¼›å…¶ä»–ç­–ç•¥çš„è¡Œä¸ºè¯´æ˜ï¼‰

---

# Action Guideï¼ˆè°ƒç”¨è¯´æ˜ï¼‰

## ä½ èƒ½åšä»€ä¹ˆ
TODOï¼šç”¨ 3~5 è¡Œè¯´æ˜èƒ½åŠ›è¾¹ç•Œï¼ˆæ’åº/ç­›é€‰/è§£é‡Šï¼‰ï¼Œä»¥åŠä¸åšä»€ä¹ˆï¼ˆä¸åšäº¤æ˜“æ‰§è¡Œ/ä¸åšé¢„æµ‹ç­‰ï¼‰ã€‚

## ä»€ä¹ˆæ—¶å€™è°ƒç”¨
- TODOï¼šè§¦å‘æ¡ä»¶ï¼ˆæŒ‰ä¸šåŠ¡è¯­ä¹‰æ˜ å°„åˆ° strategyï¼‰
- TODOï¼šç¦æ­¢æ¡ä»¶ï¼ˆç¼ºè¡¨ã€ç¼ºåˆ—ã€ref_date ç¼ºå¤±ç­‰ï¼‰

## è°ƒç”¨çº¦æŸï¼ˆå¿…é¡»éµå®ˆï¼‰
TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘
1. è¯»å–æ•°æ®ï¼šä»æ¡ˆå·è¯»å– `etf_daily`
2. é˜²æœªæ¥ï¼šæŒ‰ `ref_date` è¿‡æ»¤
3. å­—æ®µæ ‡å‡†åŒ–ï¼šåˆ—åæ ‡å‡†åŒ–ã€åˆ«åå…¼å®¹ï¼ˆå¦‚æœ‰ï¼‰
4. Universe è¿‡æ»¤ï¼šæ”¯æŒå¤šç§è¾“å…¥å½¢å¼ï¼ˆlist/dict-like/json/é€—å·ç­‰ï¼‰
5. ç­–ç•¥è®¡ç®—ï¼šdf -> df_score
6. é˜ˆå€¼/æˆªæ–­ï¼štop_k + threshold_metaï¼ˆå¦‚å¯ç”¨ï¼‰
7. å°è£…è¾“å‡ºï¼šEtfCandidateList + å¯è§£é‡Š insight

---

# Inputsï¼ˆå‚æ•° Schemaï¼‰

## Args
- `strategy` (str):
  - TODOï¼šé»˜è®¤å€¼ä¸å¯é€‰æšä¸¾
- `window` (int):
  - TODOï¼šçª—å£å®šä¹‰ä¸æœ€å°è¦æ±‚
- `top_k` (int):
  - TODOï¼šè¿”å›æ•°é‡ä¸è¾¹ç•Œï¼ˆ<=0 æ€ä¹ˆåŠï¼‰
- `universe` (list | str | None):
  - TODOï¼šæ”¯æŒçš„è¾“å…¥å½¢æ€ä¸è§£æè§„åˆ™ï¼ˆç”± dataloader è´Ÿè´£ï¼‰
- `min_amount` (float):
  - TODOï¼šæˆäº¤é¢é˜ˆå€¼è¯­ä¹‰ä¸å•ä½
- `liquidity_filter` (str):
  - TODOï¼šå¯é€‰æ¨¡å¼ä¸è¯´æ˜
- `amount_scale` (float):
  - TODOï¼šamount æ¢ç®—è§„åˆ™ï¼ˆå¦‚å­˜åœ¨ï¼‰
- `illiq_quantile` (float):
  - TODOï¼šåˆ†ä½ä¿ç•™è§„åˆ™ï¼ˆå¦‚å­˜åœ¨ï¼‰
- `threshold_mode` (str):
  - TODOï¼šnone/quantile/psrï¼ˆpsr çš„é™åˆ¶å†™æ¸…æ¥šï¼‰
- `quantile_q` (float | None):
  - TODOï¼šèŒƒå›´ä¸é»˜è®¤æ¨å¯¼è§„åˆ™
- `psr_confidence` (float):
  - TODOï¼šèŒƒå›´ä¸æ„ä¹‰ï¼ˆä»… sharpe + psr æ—¶ä½¿ç”¨ï¼‰
- `psr_ref_sharpe` (float):
  - TODOï¼šå‚è€ƒå€¼æ„ä¹‰ï¼ˆä»… sharpe æ—¶ä½¿ç”¨ï¼‰
- `composite_weights` (dict | str | None):
  - TODOï¼šæƒé‡å­—æ®µä¸å½’ä¸€åŒ–è§„åˆ™ï¼ˆä»… composite æ—¶ä½¿ç”¨ï¼‰

## Returns
- æˆåŠŸï¼š`SkillResult.ok`
  - `data.type = "EtfCandidateList"`
  - `data.items = [EtfCandidate, ...]`
  - `data.meta = { ... }`
  - `insight = "TODO: ä¸€å¥è¯æ‘˜è¦ï¼ˆå¯è§£é‡Šï¼‰"`
- ç©ºç»“æœï¼šä»ç„¶ `SkillResult.ok`
  - `items = []`
  - `insight = "TODO: è§£é‡Šä¸ºç©ºåŸå› ï¼ˆè¿‡æ»¤è¿‡ä¸¥/æ ·æœ¬ä¸è¶³/é˜ˆå€¼å›é€€ç­‰ï¼‰"`
- å¤±è´¥ï¼š`SkillResult.fail("TODO: å¯è§£é‡Šå¤±è´¥åŸå› ")`

---

# Output Examplesï¼ˆå¯¹ç…§ç¤ºä¾‹ï¼‰

> TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘ç»™ä¸€ä¸ªæœ€å°å¯ç”¨çš„ EtfCandidateList ç¤ºä¾‹ç»“æ„ï¼ˆä¸ templates/output.json å¯¹é½ï¼‰ï¼Œç”¨äºè¿ç§»å¯¹ç…§ã€‚

```
</details>


#### E) `references/data_contract.md`ï¼ˆæ•°æ®ä¾èµ–å¥‘çº¦ï¼‰
**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- å†™æ¸…æ¥šï¼šè¡¨åã€å¿…éœ€åˆ—ã€å¯é€‰åˆ—ã€åˆ—ç±»å‹å«ä¹‰
- å†™æ¸…æ¥šï¼šç¼ºåˆ—æ—¶çš„è¡Œä¸ºï¼ˆå¿…é¡» fail ä¸”å¯è§£é‡Šï¼‰

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- å…¼å®¹å­—æ®µåˆ«åï¼š`data -> date`ï¼ˆä½ ä»£ç ä¸­å·²æœ‰å…¼å®¹é€»è¾‘ï¼‰

<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šreferences/data_contract.mdç»ƒä¹ éª¨æ¶</b></summary>

```md
# æ•°æ®å¥‘çº¦ï¼ˆData Contractï¼‰

> æœ¬æ–‡æ¡£æè¿°æœ¬ Skill ä¾èµ–çš„æ•°æ®è¡¨ä¸å­—æ®µå¥‘çº¦ã€‚
> **ç¼ºåˆ—/ç¼ºè¡¨å¿…é¡» fail ä¸”å¯è§£é‡Š**ï¼ˆä¸èƒ½ silentï¼‰ã€‚

---

## TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘

- å†™æ¸…æ¥šï¼š**ä¾èµ–è¡¨å**
- å†™æ¸…æ¥šï¼š**å¿…éœ€åˆ—**ï¼ˆrequiredï¼‰
- å†™æ¸…æ¥šï¼š**å¯é€‰åˆ—**ï¼ˆoptionalï¼‰
- å†™æ¸…æ¥šï¼šæ¯åˆ—çš„ **ç±»å‹** ä¸ **å«ä¹‰**
- å†™æ¸…æ¥šï¼šå½“æ•°æ®ä¸æ»¡è¶³å¥‘çº¦æ—¶çš„è¡Œä¸º
  - ç¼ºè¡¨ï¼šåº”å¦‚ä½• failï¼ˆæç¤ºç”¨æˆ·å»å“ªæ‰¾/æ€ä¹ˆè¡¥ï¼‰
  - ç¼ºå¿…éœ€åˆ—ï¼šåº”å¦‚ä½• failï¼ˆæ˜ç¡®åˆ—ååˆ—è¡¨ï¼‰
  - æ¸…æ´—åä¸ºç©ºï¼šåº”å¦‚ä½• failï¼ˆè¯´æ˜å¯èƒ½åŸå› ï¼‰

## TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘

- å†™æ¸…æ¥šï¼šå­—æ®µåˆ«åå…¼å®¹ç­–ç•¥ï¼ˆä¾‹å¦‚ï¼šæŸå­—æ®µå¯æ¥å—åˆ«åå¹¶åœ¨ä»£ç ä¸­æ ‡å‡†åŒ–ï¼‰
- å†™æ¸…æ¥šï¼šå•ä½/ç¼©æ”¾ï¼ˆä¾‹å¦‚ amount çš„å•ä½ã€æ˜¯å¦éœ€è¦æ¢ç®—ï¼‰

---

## è¡¨ï¼š`TODO_TABLE_NAME`

### å¿…éœ€åˆ—ï¼ˆRequiredï¼‰
| åˆ—å | ç±»å‹ | å«ä¹‰ | ç¼ºå¤±æ—¶è¡Œä¸º |
|---|---|---|---|
| TODO | TODO | TODO | failï¼ˆè§£é‡ŠåŸå› ï¼‰ |
| TODO | TODO | TODO | failï¼ˆè§£é‡ŠåŸå› ï¼‰ |

### å¯é€‰åˆ—ï¼ˆOptionalï¼‰
| åˆ—å | ç±»å‹ | å«ä¹‰ | ç¼ºå¤±æ—¶è¡Œä¸º |
|---|---|---|---|
| TODO | TODO | TODO | è·³è¿‡ç›¸å…³åŠŸèƒ½/å›é€€é»˜è®¤é€»è¾‘ |
| TODO | TODO | TODO | è·³è¿‡ç›¸å…³åŠŸèƒ½/å›é€€é»˜è®¤é€»è¾‘ |


### è¯´æ˜
TODO

---
```
</details>


#### F) `references/metrics.md`ï¼ˆå…¬å¼å®šä¹‰ï¼‰
**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- ç™¾åˆ†ä½æ˜ å°„ï¼š`pct_rank -> score âˆˆ [0,100]`
- Momentum / Reversal / Sharpe / PSR / Composite çš„å®šä¹‰ï¼ˆä¸ algo å¯¹é½ï¼‰

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- å¯¹ PSR åšæ›´å¼ºè§£é‡Šï¼šä¸ºä»€ä¹ˆç”¨ `sharpe_adj = SR * PSR` åšæ’åº


<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šreferences/metrics.mdç»ƒä¹ éª¨æ¶</b></summary>

```md
# æŒ‡æ ‡å…¬å¼ï¼ˆMetrics / Formulasï¼‰

> æœ¬æ–‡æ¡£å¿…é¡»ä¸ `scripts/algo.py` çš„å®ç°å¯¹é½ï¼šåŒåæŒ‡æ ‡ã€åŒæ ·çš„ score æ˜ å°„ä¸é˜ˆå€¼è§„åˆ™ã€‚

---

## TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘

### 0) ç»Ÿä¸€å¾—åˆ†å°ºåº¦ï¼ˆPercentile Scoreï¼‰
- å†™æ¸…æ¥šï¼šå¦‚ä½•ä»æ¨ªæˆªé¢æ•°å€¼æ˜ å°„åˆ° `score âˆˆ [0,100]`
- å†™æ¸…æ¥šï¼šç¼ºå¤±å€¼å¦‚ä½•å¤„ç†ï¼ˆneutral=50ï¼‰
- å†™æ¸…æ¥šï¼šè¯¥æ˜ å°„åœ¨æ‰€æœ‰ç­–ç•¥ä¸­ä¸€è‡´ä½¿ç”¨

### 1) Momentumï¼ˆåŠ¨é‡ï¼‰
- å†™æ¸…æ¥šï¼šåŠ¨é‡ raw çš„å®šä¹‰ï¼ˆåŸºäºä»·æ ¼/æ”¶ç›Šï¼‰
- å†™æ¸…æ¥šï¼šæœ€ç»ˆ score å¦‚ä½•ç”± raw å¾—åˆ°ï¼ˆpercentileï¼‰
- å†™æ¸…æ¥šï¼šçª—å£ window çš„å«ä¹‰

### 2) Reversalï¼ˆåè½¬ / è¶…è·Œï¼‰
- å†™æ¸…æ¥šï¼šè¶…è·Œ raw çš„å®šä¹‰ï¼ˆåŸºäºå‡çº¿ä¹–ç¦»æˆ–å…¶ä»–ï¼‰
- å†™æ¸…æ¥šï¼šæ˜¯å¦éœ€è¦ sign ç¿»è½¬ï¼ˆè¶Šè¶…è·Œè¶Šé«˜ï¼‰
- å†™æ¸…æ¥šï¼šæ˜¯å¦åªä¿ç•™ raw>0ï¼ˆä½“ç°â€œè¶…è·Œæ‰ç®—ä¿¡å·â€ï¼‰
- å†™æ¸…æ¥šï¼šscore çš„æ„é€ ï¼ˆpercentileï¼‰

### 3) Sharpeï¼ˆå¤æ™®ï¼‰
- å†™æ¸…æ¥šï¼šæ”¶ç›Šç‡åºåˆ— r_t çš„å®šä¹‰
- å†™æ¸…æ¥šï¼šSR çš„è®¡ç®—æ–¹å¼ï¼ˆæ˜¯å¦å¹´åŒ–ã€å¸¸æ•°å› å­ç­‰ï¼‰
- å†™æ¸…æ¥šï¼šæ ·æœ¬é•¿åº¦ n çš„å®šä¹‰ï¼ˆä¸å®ç°ä¸€è‡´ï¼‰

### 4) PSRï¼ˆæ¦‚ç‡å¤æ™®ï¼‰
- å†™æ¸…æ¥šï¼šPSR çš„è¾“å…¥å˜é‡ï¼ˆsr_hat / sr_ref / n / skew / kurtï¼‰
- å†™æ¸…æ¥šï¼šPSR çš„è¾“å‡ºèŒƒå›´ä¸å«ä¹‰
- å†™æ¸…æ¥šï¼šä¸é˜ˆå€¼è¿‡æ»¤ï¼ˆthreshold_mode="psr"ï¼‰å¦‚ä½•é…åˆ

### 5) Compositeï¼ˆä¸‰å› å­èåˆï¼‰
- å†™æ¸…æ¥šï¼šå„å› å­ raw / pct çš„å®šä¹‰
- å†™æ¸…æ¥šï¼šæƒé‡å¦‚ä½•å½’ä¸€åŒ–ï¼ˆsum=1ï¼‰
- å†™æ¸…æ¥šï¼šæœ€ç»ˆ score çš„åŠ æƒæ–¹å¼

### 6) Thresholdï¼ˆé˜ˆå€¼è§„åˆ™ï¼‰
- Quantileï¼šå¦‚ä½•è®¡ç®— cutoffï¼Œå¦‚ä½• fallbackï¼ˆä¸è¶³ top_k æ—¶ï¼‰
- PSRï¼šé˜ˆå€¼ä¸è¶³ top_k æ—¶å¦‚ä½•æ”¾å®½æˆ–å›é€€
- è¦æ±‚ï¼šé˜ˆå€¼ä¿¡æ¯å†™å…¥ attrs/meta ä»¥ä¾¿å®¡è®¡

---

## TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘

- æ›´å¼ºè§£é‡Šï¼šä¸ºä»€ä¹ˆè¦ç”¨ â€œæŸç§ adjusted æŒ‡æ ‡â€ åšæ’åºï¼ˆä¾‹å¦‚å°† SR ä¸ PSR ç»„åˆï¼‰
- ç»™å‡ºä¸€æ®µç›´è§‰è§£é‡Šï¼šPSR åœ¨æ’åºé‡Œèµ·åˆ°çš„â€œå»å™ª/å¯ä¿¡åº¦â€ä½œç”¨
- ç»™å‡ºä¸€ä¸ªæœ€å°ç¤ºä¾‹ï¼šraw â†’ pct â†’ score çš„æ•°å€¼ä¾‹å­ï¼ˆ3~5 ä¸ªæ ·æœ¬å³å¯ï¼‰

```
</details>


#### G) `references/README.md`ï¼ˆå¼€å‘è€…æŒ‡å—ï¼‰
**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- è§£é‡Šå››å±‚ç»“æ„ï¼š
  - dataloaderï¼šå¥‘çº¦/æ¸…æ´—
  - algoï¼šçº¯è®¡ç®—
  - handlerï¼šç³»ç»Ÿå…¥å£/å°è£… SkillResult
  - templatesï¼šå±•ç¤ºå±‚ï¼ˆreportï¼‰

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- ç»™å‡ºâ€œæ‰©å±•æ­¥éª¤â€ï¼šå¦‚ä½•æ–°å¢ç­–ç•¥ï¼ˆåœ¨ algo å¢åŠ å‡½æ•° + handler è·¯ç”± + æ–‡æ¡£è¡¥é½ï¼‰

<details>
<summary><b>ğŸ“„Checkpoint-08ï¼šreferences/README.mdç»ƒä¹ éª¨æ¶</b></summary>

```md
# Developer Guideï¼ˆå¼€å‘è€…æŒ‡å—ï¼‰

> æœ¬æ–‡æ¡£é¢å‘å¼€å‘/æ•™å­¦ä½¿ç”¨ï¼šè§£é‡Šæœ¬ Skill çš„ç»“æ„åˆ†å±‚ã€è¾“å…¥è¾“å‡ºã€ä»¥åŠå¦‚ä½•æ‰©å±•ã€‚

---

## TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘

### 1) å››å±‚ç»“æ„ï¼ˆå¿…é¡»å†™æ¸…æ¥šå„è‡ªèŒè´£ï¼‰
- **dataloaderï¼ˆå¥‘çº¦/æ¸…æ´—ï¼‰**
  - TODOï¼šè´Ÿè´£ä»€ä¹ˆ
  - TODOï¼šè¾“å…¥/è¾“å‡ºï¼ˆå« fail è¡Œä¸ºï¼‰
- **algoï¼ˆçº¯è®¡ç®—ï¼‰**
  - TODOï¼šè´Ÿè´£ä»€ä¹ˆï¼ˆdf -> df_scoreï¼‰
  - TODOï¼šdf_score å¿…å«åˆ—ï¼ˆsymbol/score/reason/extraï¼‰
  - TODOï¼šscore ç»Ÿä¸€å°ºåº¦ï¼ˆ0~100 percentileï¼‰
- **handlerï¼ˆç³»ç»Ÿå…¥å£ï¼‰**
  - TODOï¼šè´Ÿè´£ä»€ä¹ˆï¼ˆexecute ä¸²è” dataloader + algo + å°è£… SkillResultï¼‰
  - TODOï¼šç©ºç»“æœ ok çš„çº¦å®šï¼ˆitems=[] + insight è§£é‡Šï¼‰
  - TODOï¼šå¼‚å¸¸è½¬ fail çš„çº¦å®š
- **templatesï¼ˆå±•ç¤ºå±‚ï¼‰**
  - TODOï¼šoutput.md / output.json ç”¨äºæ•™å­¦å±•ç¤ºä¸å¯¹ç…§

### 2) è¾“å…¥ä¾èµ–
- TODOï¼šä¾èµ–å“ªäº›è¡¨ï¼ˆè¡¨åï¼‰
- TODOï¼šå…³é”®å­—æ®µï¼ˆè‡³å°‘å“ªäº›åˆ—ï¼‰
- TODOï¼šé˜²æœªæ¥è§„åˆ™ï¼ˆref_date åˆ‡ç‰‡ï¼‰

### 3) è¾“å‡ºçº¦å®š
- TODOï¼šSkillResult.data.type å›ºå®šä¸º EtfCandidateList
- TODOï¼šitems æ¯ä¸€é¡¹åŒ…å«å“ªäº›å­—æ®µ
- TODOï¼šmeta å¿…é¡»åŒ…å«å“ªäº›å­—æ®µï¼ˆstrategy/window/top_k/threshold_meta ç­‰ï¼‰

---

## TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘

### A) æ‰©å±•æ­¥éª¤ï¼šå¦‚ä½•æ–°å¢ä¸€ä¸ªç­–ç•¥
1. TODOï¼šåœ¨ algo.py å¢åŠ ç­–ç•¥å‡½æ•°ï¼ˆè¾“å‡º df_scoreï¼‰
2. TODOï¼šåœ¨ algo.py çš„ run_strategy å¢åŠ è·¯ç”±
3. TODOï¼šåœ¨ metrics.md è¡¥é½å…¬å¼å®šä¹‰
4. TODOï¼šåœ¨ output.md é‡Œç¡®ä¿å±•ç¤ºå­—æ®µå¯¹é½ meta
5. TODOï¼šåœ¨ handler.py é‡Œç¡®ä¿ meta/insight/å¼‚å¸¸å¤„ç†ä¸€è‡´

### B) ç»ƒä¹ å…¥å£ï¼šuser_defined
- TODOï¼šè¯´æ˜å­¦ä¹ è€…è¦æ”¹å“ªé‡Œï¼ˆalgo æˆ– handlerï¼‰
- TODOï¼šNotImplemented æ—¶æç¤ºä¿¡æ¯è§„èŒƒ

### C) è°ƒè¯•ä¸éªŒæ”¶ï¼ˆå¯é€‰ï¼‰
- TODOï¼šå¦‚ä½•ç”¨æœ€å°æ•°æ®è·‘é€š
- TODOï¼šå¸¸è§æŠ¥é”™ï¼ˆç¼ºè¡¨/ç¼ºåˆ—/çª—å£ä¸è¶³/è¿‡æ»¤è¿‡ä¸¥ï¼‰ä¸å®šä½å»ºè®®

```
</details>


#### H) `templates/output.md` ä¸ `templates/output.json`ï¼ˆè¾“å‡ºæ¨¡æ¿ï¼‰
**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `output.md`ï¼šç»™å‡º top_k çš„å±•ç¤ºæ ¼å¼
- `output.json`ï¼šç»™å‡º EtfCandidateList çš„ç»“æ„ç¤ºä¾‹

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- è®© md æ¨¡æ¿å­—æ®µä¸ meta å¯¹é½ï¼ˆstrategy/window/top_k/threshold_metaï¼‰

<details>
<summary><b>ğŸ“„Checkpoint-08ï¼štemplates/output.mdç»ƒä¹ éª¨æ¶</b></summary>

```md
<!-- templates/output.md -->
# é‡åŒ–é€‰è‚¡ç»“æœ

## å‚æ•°
- Strategy: **{{ meta.strategy }}**
- RefDate: **{{ meta.ref_date }}**
- Window: **{{ meta.window }}**
- TopK: **{{ meta.top_k }}**
- Universe: **{{ meta.universe_size | default("ALL") }}**
- LiquidityFilter: **{{ meta.liquidity_filter }}**
- ThresholdMode: **{{ meta.threshold_mode }}**
- ThresholdMeta: **{{ meta.threshold_meta }}**
- ScoreScale: **{{ meta.score_scale }}**

> TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘
> - å±•ç¤ºå­—æ®µå¿…é¡»ä¸ meta å¯¹é½ï¼ˆstrategy/window/top_k/threshold_metaï¼‰
> - items ä¸ºç©ºæ—¶ä¹Ÿè¦ç»™å‡ºâ€œä¸ºä»€ä¹ˆä¸ºç©ºâ€çš„è§£é‡Šæ®µè½

---

## Top {{ meta.top_k }} Candidates

| Rank | Symbol | Score (0~100) | Reason |
|---:|---|---:|---|
{% for item in items %}
| {{ loop.index }} | {{ item.symbol }} | {{ item.score }} | {{ item.reason }} |
{% endfor %}

---

## Notes
- TODOï¼šè§£é‡Š score çš„å«ä¹‰ï¼ˆåˆ†ä½å¾—åˆ†ï¼‰
- TODOï¼šæç¤º extra ä¸­å¯æŸ¥çœ‹ raw/pct/é˜ˆå€¼ä¿¡æ¯
- TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘ï¼šå¦‚éœ€å±•ç¤º threshold_meta çš„å…³é”®å­—æ®µï¼Œå¯åœ¨æ­¤æ¸²æŸ“
```
</details>

<details>
<summary><b>ğŸ“„Checkpoint-08ï¼štemplates/output.jsonç»ƒä¹ éª¨æ¶</b></summary>

```json
// templates/output.json
{
  "status": "ok",
  "insight": "TODO: ä¸€å¥è¯æ€»ç»“ï¼ˆèŒƒå›´/ç­–ç•¥/æ•°é‡/é¦–é€‰/é˜ˆå€¼ä¿¡æ¯ï¼‰",
  "data": {
    "type": "EtfCandidateList",
    "items": [
      {
        "symbol": "TODO_SYMBOL",
        "score": 0.0,
        "reason": "TODO: å¯è§£é‡Šç†ç”±ï¼ˆå«çª—å£/æ ¸å¿ƒæŒ‡æ ‡/åˆ†ä½ç­‰ï¼‰",
        "source_skill": "TODO: skill_name",
        "extra": {
          "strategy": "TODO",
          "window": 0,
          "liquidity_filter": "TODO",
          "threshold_mode": "TODO",
          "threshold_meta": { "TODO": "..." },
          "universe_size": null,
          "score_scale": "percentile_0_100",

          "TODO_raw_metric": 0.0,
          "TODO_pct_metric": 0.0
        }
      }
    ],
    "meta": {
      "strategy": "TODO",
      "window": 0,
      "top_k": 0,
      "universe_size": null,
      "ref_date": "YYYY-MM-DD",
      "liquidity_filter": "TODO",
      "threshold_mode": "TODO",
      "threshold_meta": { "TODO": "..." },
      "score_scale": "percentile_0_100"
    }
  }
}
```
</details>

### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_quantitative_sniper.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_quantitative_sniper.py</b></summary>

   ```py
    from __future__ import annotations

    from dataclasses import dataclass
    from typing import Any, Dict, Optional

    import pandas as pd
    import numpy as np
    import pytest

    from debate_mas.skills.inventory.quantitative_sniper.scripts.handler import SkillHandler

    class FakeDossier:
        def __init__(self, tables: Optional[Dict[str, pd.DataFrame]] = None):
            self._tables = tables or {}

        def get_table(self, name: str) -> Optional[pd.DataFrame]:
            return self._tables.get(name)


    @dataclass
    class FakeSkillContext:
        dossier: FakeDossier
        ref_date: str = "2025-07-10"
        agent_role: str = "hunter"


    def make_etf_daily_df(
        *,
        days: int = 40,
        start: str = "2025-01-01",
        with_amount: bool = True,
        amount_value: float = 1e9,
    ) -> pd.DataFrame:
        dates = pd.date_range(start=start, periods=days, freq="D")
        codes = ["AAA", "BBB", "CCC"]

        rows = []
        for code in codes:
            for i, d in enumerate(dates):
                if code == "AAA":
                    close = 100 + i * 1.0
                elif code == "BBB":
                    close = 100 + np.sin(i / 3.0) * 2.0
                else:
                    close = 100 - i * 1.0

                row = {"code": code, "date": d, "close": close}
                if with_amount:
                    row["amount"] = amount_value
                rows.append(row)

        return pd.DataFrame(rows)


    def _get_attr(res: Any, name: str, default: Any = None) -> Any:
        if isinstance(res, dict):
            return res.get(name, default)
        return getattr(res, name, default)


    def assert_ok_etf_list(res: Any) -> None:
        assert res is not None

        success = _get_attr(res, "success", None)
        status = _get_attr(res, "status", None)
        assert (success is True) or (status == "ok"), f"Expected ok, got success={success}, status={status}"

        data = _get_attr(res, "data", None)
        assert isinstance(data, dict), f"Expected data dict, got {type(data)}"
        assert data.get("type") == "EtfCandidateList"
        assert isinstance(data.get("items"), list)
        assert isinstance(data.get("meta"), dict)

        insight = _get_attr(res, "insight", "")
        assert isinstance(insight, str) and len(insight) > 0


    def assert_fail(res: Any) -> None:
        assert res is not None

        success = _get_attr(res, "success", None)
        status = _get_attr(res, "status", None)
        assert (success is False) or (status == "fail"), f"Expected fail, got success={success}, status={status}"

        msg = _get_attr(res, "error_msg", None) or _get_attr(res, "message", None) or _get_attr(res, "insight", None)
        assert isinstance(msg, str) and len(msg) > 0


    def test_handler_momentum_ok_minimal() -> None:
        df = make_etf_daily_df(days=40, start="2025-01-01", with_amount=True, amount_value=1e9)
        ctx = FakeSkillContext(dossier=FakeDossier({"etf_daily": df}), ref_date="2025-07-10")

        handler = SkillHandler()

        res = handler.execute(
            ctx, 
            strategy="momentum",
            window=20,
            top_k=2,
            min_amount=1000,
            liquidity_filter="amount_latest",
            threshold_mode="none",
        )

        assert_ok_etf_list(res)

        data = _get_attr(res, "data")
        items = data["items"]
        meta = data["meta"]

        assert len(items) == 2

        for it in items:
            assert set(["symbol", "score", "reason", "extra"]).issubset(it.keys())
            assert 0.0 <= float(it["score"]) <= 100.0
            ex = it["extra"]
            assert ex.get("score_scale") == "percentile_0_100"
            assert ex.get("strategy") == "momentum"

        assert meta.get("strategy") == "momentum"
        assert meta.get("window") == 20
        assert meta.get("top_k") == len(items)


    def test_handler_empty_result_returns_ok_with_explain_insight() -> None:
        dates = pd.date_range(start="2025-01-01", periods=40, freq="D")
        rows = []
        for code in ["AAA", "BBB"]:
            for i, d in enumerate(dates):
                rows.append({"code": code, "date": d, "close": 100 + i, "amount": 1e9})
        df = pd.DataFrame(rows)

        ctx = FakeSkillContext(dossier=FakeDossier({"etf_daily": df}), ref_date="2025-07-10")
        handler = SkillHandler()

        res = handler.execute(
            ctx, 
            strategy="reversal",
            window=20,
            top_k=5,
            liquidity_filter="amount_latest",
            threshold_mode="none",
        )

        assert_ok_etf_list(res)
        data = _get_attr(res, "data")
        assert data["items"] == []

        insight = _get_attr(res, "insight")
        assert isinstance(insight, str) and len(insight) > 0


    def test_handler_missing_table_fail_explainable() -> None:
        ctx = FakeSkillContext(dossier=FakeDossier({}), ref_date="2025-07-10")
        handler = SkillHandler()

        res = handler.execute(ctx, strategy="momentum") 
        assert_fail(res)


    def test_handler_universe_filter_no_match_fail_explainable() -> None:
        df = make_etf_daily_df(days=40, start="2025-01-01", with_amount=True, amount_value=1e9)
        ctx = FakeSkillContext(dossier=FakeDossier({"etf_daily": df}), ref_date="2025-07-10")
        handler = SkillHandler()

        res = handler.execute(
            ctx, 
            strategy="momentum",
            window=20,
            top_k=5,
            universe=["NOT_EXIST_1", "NOT_EXIST_2"],
        )
        assert_fail(res)


    def test_handler_sharpe_psr_threshold_meta_pass_through() -> None:
        df = make_etf_daily_df(days=80, start="2025-01-01", with_amount=True, amount_value=1e9)
        ctx = FakeSkillContext(dossier=FakeDossier({"etf_daily": df}), ref_date="2025-07-10")
        handler = SkillHandler()

        res = handler.execute(
            ctx, 
            strategy="sharpe",
            window=20,
            top_k=3,
            liquidity_filter="amount_latest",
            threshold_mode="psr",
            psr_confidence=0.95,
            psr_ref_sharpe=0.0,
        )

        assert_ok_etf_list(res)
        meta = _get_attr(res, "data")["meta"]

        assert "threshold_meta" in meta
        tm = meta["threshold_meta"]
        if tm is not None:
            assert isinstance(tm, dict)
            assert tm.get("mode") == "psr"


    def test_handler_user_defined_must_fail_with_clear_message() -> None:
        df = make_etf_daily_df(days=40, start="2025-01-01", with_amount=True, amount_value=1e9)
        ctx = FakeSkillContext(dossier=FakeDossier({"etf_daily": df}), ref_date="2025-07-10")
        handler = SkillHandler()

        res = handler.execute(ctx, strategy="user_defined") 
        assert_fail(res)

   ```

   </details>

2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_quantitative_sniper.py
```


### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰
  - `6 passed in ...s`
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`KeyError`ã€`FrozenInstanceError`ã€`RuntimeError: ç¼ºå°‘ç¯å¢ƒå˜é‡...`
- å¦‚æœå¤±è´¥ï¼Œä½ åº”è¯¥èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°ä¸‰ç±»é—®é¢˜ï¼š
  - **SkillResult ç»“æ„ä¸åŒ¹é…**
    - å…¸å‹ç°è±¡ï¼šæ–­è¨€åœ¨ `status/success` ä¸Šå¤±è´¥
    - å¤„ç†æ–¹å¼ï¼šç»Ÿä¸€ç”¨ `success=True/False` æ–­è¨€ï¼Œå¿…è¦æ—¶å…¼å®¹ `status`
  - **handler ç»„è£…æ²¡ä¸²èµ·æ¥**
    - å…¸å‹ç°è±¡ï¼š`data` ä¸ºç©º / `type` ä¸å¯¹ / `items` ä¸æ˜¯ `list`
    - å¤„ç†æ–¹å¼ï¼šæ£€æŸ¥ handler æ˜¯å¦èµ°åˆ° `_wrap_result()` å¹¶è¿”å› `SkillResult.ok(...)`
  - **è¾“å‡ºä¸ç¨³å®šå¯¼è‡´ meta/extra ç¼ºå­—æ®µ**
    - å…¸å‹ç°è±¡ï¼š`meta.threshold_meta` ä¸å­˜åœ¨ã€`extra.score_scale` ç¼ºå¤±
    - å¤„ç†æ–¹å¼ï¼šåœ¨å°è£…å±‚ä¿è¯ meta/extra çš„å›ºå®šå­—æ®µæ’å®šå­˜åœ¨


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `skills/<skill_name>/` ç›®å½•è®¾è®¡ç›®æ ‡æ˜¯ï¼š**æŠŠâ€œæŠ€èƒ½äº¤ä»˜â€æ‹†æˆç¨³å®šéª¨æ¶ï¼ˆå¯å¤ç”¨ï¼‰+ å¯æ›¿æ¢ä¸šåŠ¡ï¼ˆå¯é‡å†™ï¼‰ã€‚**
>
> è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ é€šå¸¸ä¸æ˜¯â€œæ”¹ä¸€ä¸ªç±»â€è¿™ä¹ˆç®€å•ï¼Œè€Œæ˜¯**ä¿ç•™åŒä¸€å¥—æ–‡ä»¶å¤¹ç»“æ„ä¸å¥‘çº¦**ï¼ŒæŠŠ Python é€»è¾‘ä¸æ–‡æ¡£è§£é‡Šæ•´ä½“æ›¿æ¢æˆæ–°ä¸šåŠ¡ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

<details>
<summary><b>ç›®å½•éª¨æ¶ï¼ˆå»ºè®®ä¿æŒä¸å˜ï¼‰</b></summary>

- `scripts/handler.py`
  - å¯¹å¤–å…¥å£ï¼š`execute(ctx, ...)`
  - è´Ÿè´£ï¼šå–æ•°/ç»„å‚/è°ƒç”¨ algo/å°è£… `SkillResult`
- `scripts/dataloader.py`
  - æ•°æ®å¥‘çº¦ä¸æ¸…æ´—ï¼šä» dossier å–è¡¨ã€æ ‡å‡†åŒ–åˆ—åã€ç±»å‹è½¬æ¢ã€è¿‡æ»¤ã€è¿”å› `(df, universe_size)`
- `scripts/algo.py`
  - çº¯è®¡ç®—ï¼šç»™å®š clean df + params â†’ è¿”å› df_scoreï¼ˆä¸åš dossierã€ä¸åš SkillResultï¼‰
- `templates/output.json`
  - æ ‡å‡†è¾“å‡ºç»“æ„ç¤ºä¾‹ï¼ˆä¾¿äºå¯¹ç…§/æ•™å­¦/éªŒæ”¶ï¼‰
- `templates/output.md`
  - äººç±»å¯è¯»å±•ç¤ºæ¨¡æ¿ï¼ˆæ•™å­¦ç”¨ top_k è¡¨æ ¼ï¼‰
- `SKILL.md`
  - å¯¹å¤–è¯´æ˜ + å‚æ•° Schema + è°ƒç”¨çº¦æŸï¼ˆè¿ç§»å…¥å£æ–‡æ¡£ï¼‰
- `references/README.md`
  - å¼€å‘è€…æŒ‡å—ï¼šå››å±‚ç»“æ„ä¸æ‰©å±•æ­¥éª¤

> `scripts/`å¯åŠ å…¥å…¶ä»–å¯è°ƒç”¨çš„å·¥å…·pyæ–‡ä»¶
>
> `reference/`å¯åŠ å…¥å…¶ä»–è¯´æ˜mdæ–‡ä»¶

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–é‡å†™**

è¿™éƒ¨åˆ†å±äºâ€œä½ å½“å‰è¿™ä¸ª skill çš„å…·ä½“ä»»åŠ¡â€ã€‚  
è¿ç§»åˆ°åˆ«çš„ skill æ—¶ï¼Œé€šå¸¸éœ€è¦**æ•´ä½“æ›¿æ¢**ï¼ˆä¸ä»…ä»…æ”¹ä¸€ä¸ªç±»åï¼‰ï¼Œä½†ä¿æŒä¸Šé¢çš„éª¨æ¶ä¸å¥‘çº¦ã€‚


- **æ•°æ®ä¾èµ–ä¸æ•°æ®å¥‘çº¦**
  - å½“å‰ï¼š`etf_daily` + `code/date/close/(amount)`
  - è¿ç§»æ–¹å¼ï¼šæ¢æˆä½ çš„ä¸šåŠ¡è¡¨/å­—æ®µï¼Œä½†ä»ç”± dataloader ç»Ÿä¸€æ¸…æ´—å¹¶è¿”å› clean df
  
  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ ETF æ•°æ®å…¥å£æ›¿æ¢æˆâ€œè´·æ¬¾å®¡æ ¸æ•°æ®â€</b></summary>

  ```py
  # TODOï¼ˆå¿…å†™/ä¸šåŠ¡æ›¿æ¢ï¼‰ï¼š
  # 1) dataloader.py: ä» dossier.get_table("loan_applications") å–è¡¨
  # 2) æ ‡å‡†åŒ–å­—æ®µï¼Œä¾‹å¦‚ï¼šid/applicant_income/credit_score/employment_years/...
  # 3) è¿”å› (clean_df, population_size) æˆ– SkillResult.fail("å¯è§£é‡ŠåŸå› ")
  ```
  </details>


- **å› å­ç­–ç•¥æ‰©å±•ï¼ˆåŒä¸šåŠ¡ã€åŒ Skillï¼‰**
  - å½“å‰ï¼š`momentum / sharpe(psr) / reversal / composite(3-factor)`
  - è¿ç§»æ–¹å¼ï¼šä¿æŒ `dataloader â†’ algo â†’ handler` ä¸‰æ®µç»“æ„ä¸å˜ï¼Œåªåœ¨ `algo.py` æ–°å¢å› å­ä¸ç»„åˆæƒé‡å£å¾„ï¼ˆscore ä»ç»Ÿä¸€ `0~100 percentile`ï¼Œextra ç»§ç»­ä¿ç•™ raw è¯æ®ï¼‰

  
  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šåœ¨ ETF åœºæ™¯é‡Œæ–°å¢ä¸€ä¸ªå› å­ï¼ˆä¹–ç¦»ç‡ Biasï¼‰ï¼Œå¹¶æŠŠ Composite ä»ä¸‰å› å­å‡çº§ä¸ºå››å› å­</b></summary>
  
  ```py
    # TODOï¼ˆé€‰æ”¹/åŒä¸šåŠ¡æ‰©å±•ï¼‰ï¼š
    # ç›®æ ‡ï¼šåœ¨ä¸æ”¹åŠ¨ handler çš„é€šç”¨æµç¨‹å‰æä¸‹ï¼Œ
    #      1) æ–°å¢ä¸€ä¸ªâ€œä¹–ç¦»ç‡ biasâ€å› å­è®¡ç®—
    #      2) æŠŠ composite ä» mom/sharpe/rev ä¸‰å› å­ â†’ mom/sharpe/rev/bias å››å› å­
    #      3) åŒæ—¶ç»™ user_defined_strategy ä¸€ä¸ªç»ƒä¹ å…¥å£ï¼šå®ç°â€œå››å› å­ç‰ˆæœ¬â€çš„è¿”å› df_score

    # === ä½ éœ€è¦æ”¹çš„æ–‡ä»¶ ===
    # - scripts/algo.py:
    #     - æ–°å¢/è¡¥å…¨ bias å› å­è®¡ç®—
    #     - composite_weights æ”¯æŒ {"mom","sharpe","rev","bias"} å¹¶å½’ä¸€åŒ–
    #     - è¾“å‡º df_score: è‡³å°‘åŒ…å« symbol/score/reason/extra
    # - scripts/handler.py:
    #     - åªéœ€è¦æŠŠ composite_weights çš„ keys å…è®¸ biasï¼ˆå¦‚æœä½ åœ¨ handler åšäº†æ ¡éªŒï¼‰
    #     - å…¶ä»– execute æµç¨‹ä¿æŒä¸åŠ¨

    # === æ•°æ®ä¾èµ–ä¸æ•°æ®å¥‘çº¦ ===
    # - å½“å‰ï¼šetf_daily + code/date/close/(amount)
    # - è¿ç§»æ–¹å¼ï¼šä¸æ”¹è¡¨åï¼›åªæ–°å¢ bias çš„è®¡ç®—ä¸ composite çš„æƒé‡å£å¾„ï¼›score ä»éœ€æ˜ å°„åˆ° 0~100 percentile

    # === ä¹–ç¦»ç‡å› å­å®šä¹‰ï¼ˆå»ºè®®ï¼‰===
    # bias = (close_t - MA_window(close)) / MA_window(close)
    # bias_pct = pct_rank_0_100(bias) æˆ– pct_rank_0_100(-abs(bias))ï¼ˆçœ‹ä½ è¦â€œè¿½åç¦»â€è¿˜æ˜¯â€œå‡å€¼å›å½’â€ï¼‰

    def normalize_weights_4(w: dict | None) -> dict:
        # TODOï¼šæŠŠ keys æ‰©å±•ä¸º mom/sharpe/rev/biasï¼Œå¹¶åš sum=1 å½’ä¸€åŒ–
        # - å¦‚æœä¼ å…¥ Noneï¼šé»˜è®¤ç­‰æƒ 0.25
        # - å¦‚æœä¼ å…¥éƒ¨åˆ† keysï¼šå…¶ä½™ç”¨é»˜è®¤ï¼Œå†å½’ä¸€åŒ–
        return {"mom": 0.25, "sharpe": 0.25, "rev": 0.25, "bias": 0.25}

    def scan_composite_4factors(df: pd.DataFrame, params: dict) -> pd.DataFrame:
        # TODOï¼šå‚è€ƒä½ ç°æœ‰ scan_compositeï¼Œä¸€æ¬¡éå†ç®—å››ä¸ª rawï¼š
        # - mom_raw
        # - sharpe_adjï¼ˆsharpe*psrï¼‰
        # - rev_raw
        # - bias_rawï¼ˆæ–°çš„ï¼‰
        #
        # å†ç®—å››ä¸ª pctï¼š
        # - mom_pct / sharpe_pct / rev_pct / bias_pct
        #
        # æœ€ç»ˆ score = w_mom*mom_pct + w_sharpe*sharpe_pct + w_rev*rev_pct + w_bias*bias_pct
        #
        # extra å¿…é¡»åŒ…å«ï¼š
        # - å››å› å­çš„ raw ä¸ pct
        # - composite_weightsï¼ˆå« biasï¼‰
        # - composite_score
        #
        # reason å¿…é¡»å¯è§£é‡Šï¼šè‡³å°‘æ‰“å°å››ä¸ª pct + å…³é”® rawï¼ˆç®€çŸ­ï¼‰
        pass

    def user_defined_strategy(df: pd.DataFrame, params: dict) -> pd.DataFrame:
        """
        TODOï¼ˆç»ƒä¹ å…¥å£ï¼‰ï¼š
        - ç”¨â€œå››å› å­ç‰ˆæœ¬â€å®ç°ä¸€ä¸ªä½ è‡ªå·±çš„æ‰“åˆ†ï¼ˆä¾‹å¦‚ bias ç”¨ -abs(bias) è¡¨ç¤ºâ€œè¶Šæ¥è¿‘å‡å€¼è¶Šå¥½â€ï¼‰
        - è¿”å› df_scoreï¼ˆsymbol/score/reason/extraï¼‰
        - score å»ºè®®ç”¨ 0~100 ç™¾åˆ†ä½ï¼Œä¿æŒå…¨æ¡†æ¶ä¸€è‡´
        """
        # TODOï¼šå†™ä½ çš„å››å› å­é€»è¾‘
        # 1) è®¡ç®—å››ä¸ª raw
        # 2) pct_rank_0_100
        # 3) score åˆæˆ
        # 4) reason + extra
        # return df_score
        raise NotImplementedError("TODO: implement user_defined_strategy (4-factor).")
  ```
  </details>


- **æŠ€èƒ½æ•´ä½“é‡å†™ï¼ˆè·¨ä¸šåŠ¡ã€ä¿ç•™éª¨æ¶ï¼‰**
  - å½“å‰ï¼šETF å› å­æ’åºç±» Skillï¼ˆ`etf_daily` é©±åŠ¨ï¼Œè¾“å‡º `EtfCandidateList`ï¼‰
  - è¿ç§»æ–¹å¼ï¼šä¿æŒæ–‡ä»¶å¤¹éª¨æ¶ï¼ˆ`dataloader.py / algo.py / handler.py / templates/SKILL.md`ï¼‰ä¸â€œé€šç”¨å¥‘çº¦â€ï¼ˆè¿”å› `CandidateList` + 0~100 percentile + å¯è§£é‡Š reason/extraï¼‰ä¸å˜ï¼Œæ›¿æ¢ä¸ºä½ çš„ä¸šåŠ¡è¡¨ã€å­—æ®µã€ç­–ç•¥è·¯ç”±ä¸æ‰“åˆ†é€»è¾‘ï¼ˆæŠ€èƒ½ä¼šé‡æ–°å‘½åã€role/group/tags/description å…¨éƒ¨åŒæ­¥æ”¹ï¼‰

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ algo ä»â€œETF å› å­æ’åºâ€è¿ç§»æˆâ€œè´·æ¬¾å‡†å…¥è¯„åˆ†â€ï¼ˆé ETF ä¸šåŠ¡ï¼‰</b></summary>

  ```py
    # TODOï¼ˆå¿…å†™/ä¸šåŠ¡æ›¿æ¢ï¼‰ï¼š
    # ç›®æ ‡ï¼šä¿ç•™ skill éª¨æ¶ï¼ˆdataloader/algo/handler/templates/SKILL.mdï¼‰ï¼Œ
    #      ä½†æŠŠä¸šåŠ¡æ›¿æ¢æˆâ€œè´·æ¬¾å‡†å…¥è¯„åˆ†â€ã€‚

    # === æ•°æ®ä¾èµ–ä¸æ•°æ®å¥‘çº¦ ===
    # - å½“å‰ï¼šetf_daily + code/date/close/(amount)
    # - è¿ç§»æ–¹å¼ï¼šæ¢æˆ loan_applications + ä½ çš„å­—æ®µ
    #   ä½†ä»åšæŒï¼šdataloader ç»Ÿä¸€æ¸…æ´— â†’ algo åªåšè®¡ç®— â†’ handler åªåšè·¯ç”±ä¸å°è£…ï¼ˆè¾“å‡ºç¨³å®šã€å¯æµ‹è¯•ï¼‰

    # === 1) dataloader.pyï¼šæ¢æ•°æ®å…¥å£ä¸æ¸…æ´—å¥‘çº¦ ===
    def load_loan_applications(ctx: SkillContext, *, apply_date_filter) -> tuple[pd.DataFrame, int] | SkillResult:
        # TODOï¼š
        # 1) ä» dossier.get_table("loan_applications") å–è¡¨
        # 2) æ ‡å‡†åŒ–å­—æ®µï¼šid / applicant_income / credit_score / employment_years / debt_to_income / ...
        # 3) ç±»å‹è½¬æ¢ï¼šæ•°å€¼åˆ— to_numericï¼Œæ—¥æœŸåˆ— to_datetime
        # 4) å¿…éœ€å­—æ®µæ£€æŸ¥ï¼šç¼ºå¤±åˆ™ SkillResult.fail("å¯è§£é‡ŠåŸå› ")
        # 5) è¿”å› (clean_df, population_size)
        pass

    # === 2) algo.pyï¼šæŠŠ run_strategy å˜æˆè¯„åˆ†è§„åˆ™/æ¨¡å‹è¾“å‡º ===
    def run_strategy(df: pd.DataFrame, params: dict) -> pd.DataFrame:
        # TODOï¼šæ ¹æ® params["strategy"] è·¯ç”±ï¼š
        # - "rule_based": è§„åˆ™æ‰“åˆ†ï¼ˆç¡¬é—¨æ§›+åŠ åˆ†é¡¹ï¼‰
        # - "risk_score": é£é™©åˆ†ï¼ˆä¾‹å¦‚ logistic regression è¾“å‡ºæ¦‚ç‡ï¼‰
        # - "hybrid": èåˆï¼ˆè§„åˆ™ç­› + æ¨¡å‹æ’åºï¼‰
        pass

    def rule_based_score(df: pd.DataFrame, params: dict) -> pd.DataFrame:
        # TODOï¼šè¾“å‡º df_scoreï¼Œè‡³å°‘åŒ…å«ï¼š
        # - symbol: ç”¨ application_id / applicant_id
        # - score: 0~100ï¼ˆå¯ç”¨ pct_rank_0_100 æ˜ å°„ï¼‰
        # - reason: ç®€çŸ­è¯´æ˜å‘½ä¸­çš„å…³é”®è§„åˆ™ï¼ˆä¾‹å¦‚ â€œä¿¡ç”¨åˆ†>=700, DTI<0.35â€ï¼‰
        # - extra: è§„åˆ™å‘½ä¸­æ˜ç»†ï¼ˆä¾‹å¦‚ {"credit_score":720, "dti":0.31, "rule_hits":[...]}ï¼‰
        pass

    # === 3) handler.pyï¼šä¿ç•™ execute éª¨æ¶ï¼Œåªæ¢â€œè¡¨å/å‚æ•°/å°è£…è¯­ä¹‰â€ ===
    class SkillHandler(BaseFinanceSkill):
        def execute(self, ctx: SkillContext, strategy: str = "rule_based", top_k: int = 20, **kwargs) -> SkillResult:
            # TODOï¼ˆåªåšä¸‰ä»¶äº‹ï¼‰ï¼š
            # 1) df, population_size = load_loan_applications(...)
            # 2) params = {...} ç»„è£…
            # 3) df_score = run_strategy(df, params) â†’ sort/head(top_k) â†’ SkillResult.ok(...)
            pass
  ```
  </details>


**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
  - **ä¸åŠ¨**ï¼š`skills/<skill_name>/` ç›®å½•éª¨æ¶ + `execute(ctx)->SkillResult` å¥‘çº¦ + `df_score(symbol/score/reason/extra)` ä¸ `score_scale=percentile_0_100`
  - **å¯æ¢**ï¼š`dataloader` çš„è¡¨å/å­—æ®µæ¸…æ´—å¥‘çº¦ + `algo` çš„æŒ‡æ ‡/ç­–ç•¥è·¯ç”± + `templates/SKILL.md/references` çš„ä¸šåŠ¡è¯´æ˜ä¸è¾“å‡ºå­—æ®µ
  - **ä¸€å¥è¯**ï¼š**éª¨æ¶ä¸æ”¹ã€å¥‘çº¦ä¸ç ´ï¼›æ¢æ•°æ®ã€æ¢ç®—æ³•ã€æ¢æ–‡æ¡£ï¼Œå°±èƒ½æ¢ä¸šåŠ¡**

</details>

---


## å…³å¡-09ï½œæ³¨å†Œä¸å‡†å…¥ Registryï¼šæŠ€èƒ½ä¸Šæ¶

<details>
<summary><b>Checkpoint 09 â€” æ³¨å†Œä¸å‡†å…¥ ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³æŠŠå…³å¡-08 å†™å¥½çš„ Skill æ¥åˆ°ç³»ç»Ÿçš„ **æ³¨å†Œä¸­å¿ƒ SkillRegistry** ä¸Šï¼Œå®Œæˆâ€œæ’ä»¶ä¸Šæ¶â€çš„æœ€å°é—­ç¯ï¼š  
>
> **æ‰«æ inventory â†’ è§£æ SKILL.md â†’ åŠ¨æ€åŠ è½½ SkillHandler â†’ æ³¨å…¥å…ƒä¿¡æ¯ â†’ ç¼“å­˜ï¼ˆ_SKILL_CACHEï¼‰**
>
> è¿™ä¸€å…³ä¸è¿½æ±‚â€œæ›´å¤šæŠ€èƒ½â€ï¼Œåªè¿½æ±‚ **æ›´ç¨³å®šã€æ›´å¯æµ‹ã€æ›´å¯é™çº§**ï¼š  
> - æ–°å¢ä¸€ä¸ª skill æ–‡ä»¶å¤¹åï¼Œç³»ç»Ÿèƒ½è‡ªåŠ¨è¯†åˆ«å¹¶æ³¨å†Œ  
> - æ³¨å†Œè¿‡ç¨‹å¯æµ‹è¯•ï¼ˆå¯ç”¨ tmp_path æ„é€ å‡çš„ inventoryï¼‰  
> - å•ä¸ª skill åŠ è½½å¤±è´¥ä¸å½±å“å…¶ä»–æŠ€èƒ½æ³¨å†Œ


### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- ç†è§£å¹¶å®ç° **æŠ€èƒ½ä¸Šæ¶é“¾è·¯**ï¼šinventory â†’ registry â†’ tool åˆ—è¡¨
- å­¦ä¼šæŠŠâ€œå¯ç”¨æŠ€èƒ½é›†åˆâ€åšæˆ **å¯æ²»ç†çš„å‡†å…¥ç³»ç»Ÿ**ï¼ˆallowlist-by-roleï¼‰
- è®© SkillRegistry **å¯æµ‹è¯•**ï¼šå…è®¸åœ¨æµ‹è¯•ä¸­é€šè¿‡ monkeypatch registry.__file__ æŒ‡å‘ä¸´æ—¶ç›®å½•ï¼Œæ„é€ å‡çš„ inventoryã€‚


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³åªæ”¹ï¼š
  - `src/debate_mas/skills/base.py`
  - `src/debate_mas/skills/registry.py`
- ä¸æ”¹ï¼š
  - `BaseSkill.execute/safe_run/to_langchain_tool` çš„**å¯¹å¤–åè®®**
  - `protocol/SkillResult`ã€`loader/Dossier` çš„æ—¢æœ‰å¥‘çº¦
- æ³¨å†Œå¤±è´¥å¿…é¡» **å¯é™çº§**ï¼šå•ä¸ª skill åŠ è½½å¤±è´¥ä¸å½±å“å…¶ä»–æŠ€èƒ½è¢«æ³¨å†Œ


### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

> æœ¬å…³åˆ†ä¸¤æ®µå†™ï¼šå…ˆæŠŠ `base.py` å†™ç¨³ï¼Œå†æŠŠ `registry.py` å†™é€šã€‚


#### A) `skills/base.py`

**å¿…çœ‹**
- `src/debate_mas/skills/base.py`
  - `SkillContext`ï¼šskill è°ƒç”¨æ—¶çš„ä¸Šä¸‹æ–‡è¾“å…¥
  - `_auto_args_schema_from_execute`ï¼šä» `execute(...)` ç­¾åç”Ÿæˆ schema
  - `_ensure_schema_ready`ï¼šåŠ¨æ€åŠ è½½ + postponed annotations çš„è§£æå…œåº•
  - `BaseSkill.safe_run / to_langchain_tool`ï¼šé”™è¯¯å…œåº• + Tool é€‚é…å…¥å£
- `src/debate_mas/protocol/SkillResult`ï¼šæŠ€èƒ½å¿…é¡»è¿”å›çš„ç»Ÿä¸€ç»“æœç»“æ„
- `src/debate_mas/loader/dossier.py`ï¼šctx.dossier æ•°æ®å…¥å£


**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `safe_run(...)`ï¼šç¡®ä¿ **ä»»ä½•å¼‚å¸¸éƒ½è¢« SkillResult.fail æ”¶æ•›**
- `to_langchain_tool(...)`ï¼š
  - schema é€‰æ‹©ä¼˜å…ˆçº§ï¼šæ˜¾å¼ `args_schema` > è‡ªåŠ¨ç”Ÿæˆå¹¶ç¼“å­˜
  - ç»Ÿä¸€è¿”å› **JSON å­—ç¬¦ä¸²**ï¼ˆé¿å… dict->str å•å¼•å·æ±¡æŸ“ï¼‰
  - schema å¿…é¡» `model_rebuild`ï¼ˆé¿å… forward-ref / postponed annotations å´©æºƒï¼‰

**å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼Œè¿ç§»å¯æ›¿æ¢ï¼‰**
- `SkillContext` å­—æ®µå¿…é¡»åŒ…å«ï¼š
  - `dossier / agent_role / ref_date`
- `ref_date` è¯­ä¹‰ï¼š**ä¸èƒ½ä½¿ç”¨ ref_date å½“å¤©åŠä¹‹åçš„æ•°æ®**

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- å¯¹ tool çš„æè¿°åšè£å‰ªï¼ˆé¿å… prompt è¿‡é•¿ï¼‰
- schema è‡ªåŠ¨ç”Ÿæˆå¯¹ç±»å‹æ ‡æ³¨ç¼ºå¤±æ—¶ç»™å‡ºæ›´å‹å¥½çš„æŠ¥é”™
- `safe_run` æ‰“å°æ›´ç»“æ„åŒ–çš„ debug ä¿¡æ¯ï¼ˆä½†ä¿æŒè¿”å›ä»æ˜¯ SkillResultï¼‰


<details>
<summary><b>ğŸ“„ Checkpoint-09ï¼šskills/base.pyç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/skills/base.py
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Optional, Any, Dict, List, get_type_hints

import inspect
import json
import traceback

import pandas as pd
from pandas.api.types import is_datetime64_any_dtype, is_object_dtype, is_string_dtype

from pydantic import BaseModel, Field, ConfigDict, create_model

from ..protocol import SkillResult
from ..loader.dossier import Dossier


# ==========================================
# 1) Runtime Context
# ==========================================
class SkillContext(BaseModel):
    """
    [ä¸Šä¸‹æ–‡ç¯å¢ƒ]
    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - å®šä¹‰ dossier / agent_role / ref_date ä¸‰ä¸ªå­—æ®µ
      - dossier ç±»å‹ä¸º Dossierï¼ˆåªè¯»ï¼‰ï¼Œagent_role é»˜è®¤ unknownï¼Œref_date å¯é€‰

    Args:
        None

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


# ==========================================================
# 2) Pydantic schema å…œåº•
# ==========================================================
def _ensure_schema_ready(schema: Optional[type[BaseModel]], *, execute_fn=None) -> None:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - schema ä¸º None æˆ–æ—  model_rebuild æ—¶ç›´æ¥ return
      - ä¾æ¬¡å°è¯•ï¼š
        1) schema.model_rebuild(force=True)
        2) schema.model_rebuild(force=True, _types_namespace=execute_fn.__globals__)
        3) schema.model_rebuild(force=True, _types_namespace={})
      - ä»»ä½•å¼‚å¸¸éƒ½åæ‰ï¼ˆå…œåº•å‡½æ•°ä¸åº”å´©ï¼‰

    Args:
        schema: éœ€è¦è¢« model_rebuild çš„ schema
        execute_fn: å¯é€‰ï¼Œexecute å‡½æ•°å¯¹è±¡ï¼Œç”¨äºå– globals ä½œä¸º types namespace

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


def _auto_args_schema_from_execute(execute_fn, *, model_name: str) -> type[BaseModel]:
    """
    ä» execute(self, ctx: SkillContext, ...) è‡ªåŠ¨ç”Ÿæˆ args_schemaã€‚

    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - inspect.signature(execute_fn) è·å–å‚æ•°
      - æ’é™¤ self / ctx
      - æ’é™¤ *args / **kwargs
      - ç”¨ get_type_hints è§£æç±»å‹æ ‡æ³¨ï¼ˆå¤±è´¥åˆ™å›é€€ Anyï¼‰
      - default ç¼ºçœ => å¿…å¡«(...)
      - create_model(..., __config__=ConfigDict(extra="forbid"), **fields)
      - å¯¹ç”Ÿæˆçš„ model åš model_rebuildï¼ˆå¸¦ execute_fn globalsï¼‰

    Args:
        execute_fn: å­ç±»å®ç°çš„ execute æ–¹æ³•
        model_name: schema åç§°å‰ç¼€ï¼ˆç”¨äºå¯è¯»æ€§ï¼‰

    Returns:
        model: Pydantic BaseModel å­ç±»ï¼ˆargs_schemaï¼‰
    """
    # TODO
    raise NotImplementedError


# ==========================================
# 3) BaseSkill
# ==========================================
class BaseSkill(ABC):
    """
    ã€é€šç”¨æŠ€èƒ½åŸºç±»ã€‘
    """
    name: str = ""
    chinese_name: str = ""
    description: str = ""
    expert_mindset: str = ""

    args_schema: Optional[type[BaseModel]] = None

    @abstractmethod
    def execute(self, ctx: SkillContext, **kwargs) -> SkillResult:
        """
        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - å­ç±»å¿…é¡»å®ç°
          - å¿…é¡»è¿”å› SkillResult

        Args:
            ctx: SkillContext
            **kwargs: execute çš„ä¸šåŠ¡å‚æ•°

        Returns:
            SkillResult
        """
        raise NotImplementedError

    def safe_run(self, ctx: SkillContext, **kwargs) -> SkillResult:
        """
        ç³»ç»Ÿè°ƒç”¨å…¥å£ï¼šæ•è·å¼‚å¸¸å¹¶æ”¶æ•›æˆ SkillResultã€‚

        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - è°ƒç”¨ self.execute(ctx, **kwargs)
          - è‹¥è¿”å›ä¸æ˜¯ SkillResultï¼šè¿”å› SkillResult.failï¼ˆæŠ¥é”™ä¿¡æ¯åŒ…å« typeï¼‰
          - æ•è·æ‰€æœ‰å¼‚å¸¸ï¼štraceback.print_exc + SkillResult.fail

        Args:
            ctx: SkillContext
            **kwargs: execute å‚æ•°

        Returns:
            result: SkillResult
        """
        # TODO
        raise NotImplementedError

    def _dump_result(self, result: SkillResult) -> Dict[str, Any]:
        """
        å°† SkillResult è½¬æˆ dictã€‚

        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - ä¼˜å…ˆ result.model_dump()
          - å¤±è´¥åˆ™æ‰‹åŠ¨æ‹¼ success/data/insight/visuals/error_msg

        Args:
            result: SkillResult

        Returns:
            payload: Dict[str, Any]
        """
        # TODO
        raise NotImplementedError

    def to_langchain_tool(self, ctx: SkillContext):
        """
        é€‚é…æˆ LangChain StructuredToolã€‚

        TODO(ã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘):
          - æ„é€  descriptionï¼šdescription + expert_mindsetï¼ˆå¯åšé•¿åº¦è£å‰ªï¼‰
          - schema é€‰æ‹©ï¼šself.args_schema ä¼˜å…ˆï¼Œå¦åˆ™è‡ªåŠ¨ç”Ÿæˆå¹¶ç¼“å­˜åˆ° self._lc_args_schema
          - è°ƒç”¨ _ensure_schema_ready(schema, execute_fn=self.execute)
          - func(**kwargs)ï¼š
            - res = self.safe_run(ctx, **kwargs)
            - payload = self._dump_result(res)
            - return json.dumps(payload, ensure_ascii=False)
          - return StructuredTool(name=self.name, description=..., args_schema=schema, func=func)

        TODO(ã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘):
          - å¯¹ schema ç”Ÿæˆå¤±è´¥ç»™å‡ºæ›´å‹å¥½çš„é”™è¯¯æç¤ºï¼ˆä½†ä¸è¦æ”¹å˜è¿”å›ç±»å‹çº¦å®šï¼‰

        Args:
            ctx: SkillContext

        Returns:
            tool: StructuredTool
        """
        # TODO
        raise NotImplementedError


# ==========================================
# 4) BaseFinanceSkill
# ==========================================
class BaseFinanceSkill(BaseSkill):
    """
    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼Œè¿ç§»å¯æ›¿æ¢ï¼‰ã€‘:
      - æä¾› apply_date_filter / get_entity_data / rank_by_column
      - å…³é”®è¯­ä¹‰ï¼šref_date é˜²æœªæ¥å‡½æ•°

    Args:
        None

    Returns:
        None
    """
    # TODOï¼ˆå¦‚è¯¥æ–‡ä»¶åœ¨å‰ç½®å…³å¡å·²å®ç°ï¼Œå¯ä¿æŒä¸åŠ¨ï¼‰
    raise NotImplementedError

```
</details>

#### B) `skills/registry.py`

**å¿…çœ‹**
- `src/debate_mas/skills/registry.py`
  - `load_all_skills(...)`ï¼šinventory æ‰«æå…¥å£
  - `_parse_skill_md(...)`ï¼šè§£æ `SKILL.md` çš„ frontmatter + prompt
  - `_load_package(...)`ï¼šåŠ¨æ€ import + å®ä¾‹åŒ– SkillHandler + æ³¨å…¥ meta
  - `_SKILL_CACHE`ï¼šæ³¨å†Œç¼“å­˜
- `skills/inventory/<skill_name>/SKILL.md`ï¼šname/chinese_name/description + expert prompt
- `skills/inventory/<skill_name>/scripts/handler.py`ï¼šå¿…é¡»æš´éœ² SkillHandler


#### **å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `load_all_skills()`ï¼šæ‰«æ `inventory/`ï¼Œé€ä¸ªåŒ…åŠ è½½ï¼›å•ä¸ªå¤±è´¥ä¸å½±å“æ•´ä½“ï¼ˆå¯é™çº§ï¼‰
- `_parse_skill_md()`ï¼šç¨³å¥è§£æ frontmatterï¼ˆå…¼å®¹ BOM / \n / \r\nï¼‰ï¼Œè¿”å› `(meta, prompt_text)` æˆ– `None`
- `_load_package()`ï¼šåŠ¨æ€ import handlerï¼›æ‰¾ä¸åˆ° `SkillHandler` / ç¼ºæ–‡ä»¶è¦ç»™æ¸…æ™°æç¤ºå¹¶è·³è¿‡
- `_SKILL_CACHE`ï¼šä»¥ `skill_name` ä¸º key ç¼“å­˜å®ä¾‹ï¼›é‡å¤ key çš„ç­–ç•¥è¦ä¸€è‡´ï¼ˆè¦†ç›–/è·³è¿‡äºŒé€‰ä¸€ï¼‰

#### **å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼Œè¿ç§»å¯æ›¿æ¢ï¼‰**
- å…ƒä¿¡æ¯æ³¨å…¥ï¼šæŠŠ `SKILL.md` çš„ `name/chinese_name/description` ä¸ prompt æ³¨å…¥åˆ° instanceï¼ˆä¾› LLM/tool æè¿°ä½¿ç”¨ï¼‰
- åç§°ä¸€è‡´æ€§æç¤ºï¼šfolder åä¸ `SKILL.md.name` ä¸ä¸€è‡´æ—¶ç»™ warningï¼ˆä¸é˜»æ–­åŠ è½½ï¼‰

#### **é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- `force_reload=True`ï¼šæ¸…ç©ºç¼“å­˜å¹¶é‡æ–°æ‰«æï¼ˆä¾¿äºå¼€å‘çƒ­åŠ è½½ï¼‰
- `get_skill()`ï¼šé¦–æ¬¡è®¿é—®è‹¥ç¼“å­˜ä¸ºç©ºè‡ªåŠ¨è§¦å‘åŠ è½½ï¼›æ‰¾ä¸åˆ° skill æ—¶æŠ›å‡ºå¯è¯»é”™è¯¯
- å¯é€‰æš´éœ² `list_skills()`ï¼šè¿”å›å·²æ³¨å†ŒæŠ€èƒ½ååˆ—è¡¨ 


<details>
<summary><b>ğŸ“„ src/debate_mas/skills/registry.pyç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/skills/registry.py
from __future__ import annotations

from pathlib import Path
from typing import Dict, Tuple, Any, Optional

# TODO: import åŠ¨æ€åŠ è½½æ‰€éœ€æ¨¡å—ï¼ˆimportlib.util / sysï¼‰
# TODO: import è§£æ frontmatter æ‰€éœ€æ¨¡å—ï¼ˆre / yamlï¼‰

from .base import BaseSkill

_SKILL_CACHE: Dict[str, BaseSkill] = {}


class SkillRegistry:
    @staticmethod
    def load_all_skills(force_reload: bool = False) -> None:
        """
        åŠ è½½ inventory ä¸‹æ‰€æœ‰æŠ€èƒ½ï¼ˆæ‰«æå…¥å£ï¼‰ã€‚

        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - force_reload=True æ—¶æ¸…ç©º _SKILL_CACHE
          - æ‰«æ skills/inventory/ ä¸‹çš„å­ç›®å½•ï¼ˆè·³è¿‡éç›®å½•ä¸ __*ï¼‰
          - é€ä¸ªè°ƒç”¨ _load_package(...)ï¼Œå•ä¸ªå¤±è´¥è¦å¯é™çº§ï¼ˆä¸ä¸­æ–­æ•´ä½“ï¼‰

        TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
          - è®°å½•åŠ è½½æ•°é‡/å¤±è´¥æ•°é‡ï¼ˆprint æˆ–è¿”å›ç»Ÿè®¡äºŒé€‰ä¸€ï¼‰

        Args:
            force_reload: æ˜¯å¦å¼ºåˆ¶æ¸…ç©ºç¼“å­˜å¹¶é‡æ–°åŠ è½½

        Returns:
            None
        """
        # TODO
        raise NotImplementedError

    @staticmethod
    def _parse_skill_md(content: str) -> Optional[Tuple[Dict[str, Any], str]]:
        """
        è§£æ SKILL.mdï¼šfrontmatter(YAML) + prompt(æ­£æ–‡)ã€‚

        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - å…¼å®¹ BOM/ç©ºè¡Œï¼›å…¼å®¹ \n ä¸ \r\n
          - æˆåŠŸè¿”å› (meta_dict, prompt_text)ï¼Œå¤±è´¥è¿”å› None
          - meta å¿…é¡»æ˜¯ dictï¼Œå¦åˆ™è§†ä¸ºå¤±è´¥

        Args:
            content: SKILL.md å…¨æ–‡å­—ç¬¦ä¸²

        Returns:
            parsed: Optional[(meta, prompt_text)]
        """
        # TODO
        raise NotImplementedError

    @staticmethod
    def _load_package(skill_dir: Path) -> None:
        """
        åŠ è½½å•ä¸ª skill æ–‡ä»¶å¤¹ï¼ˆå•åŒ…åŠ è½½ï¼‰ã€‚

        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - è¯»å–å¹¶è§£æ SKILL.mdï¼ˆè°ƒç”¨ _parse_skill_mdï¼‰
          - å®šä½ scripts/handler.pyï¼ŒåŠ¨æ€ import æ¨¡å—
          - æ‰¾åˆ° SkillHandler ç±»å¹¶å®ä¾‹åŒ–
          - ç¼ºæ–‡ä»¶/ç¼ºç±»/è§£æå¤±è´¥ï¼šç»™ warning å¹¶è·³è¿‡ï¼ˆä¸ä¸­æ–­ï¼‰

        TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
          - å°† meta.name/chinese_name/description ä¸ prompt æ³¨å…¥åˆ° instance
          - folder åä¸ meta.name ä¸ä¸€è‡´æ—¶ç»™æç¤ºï¼ˆä¸é˜»æ–­ï¼‰

        TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
          - é‡å key çš„å¤„ç†ç­–ç•¥ï¼šè¦†ç›–æˆ–è·³è¿‡ï¼ˆä¿æŒä¸€è‡´å¹¶ç»™æç¤ºï¼‰

        Args:
            skill_dir: inventory ä¸‹çš„æŸä¸ªæŠ€èƒ½ç›®å½•è·¯å¾„

        Returns:
            None
        """
        # TODO
        raise NotImplementedError

    @staticmethod
    def get_skill(name: str) -> BaseSkill:
        """
        æŒ‰ name è·å–å·²æ³¨å†Œçš„æŠ€èƒ½å®ä¾‹ã€‚

        TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
          - è‹¥ _SKILL_CACHE ä¸ºç©ºï¼Œå…ˆè§¦å‘ load_all_skills()
          - æ‰¾ä¸åˆ° nameï¼šæŠ›å‡º ValueErrorï¼ˆä¿¡æ¯å¯è¯»ï¼‰

        Args:
            name: æŠ€èƒ½åï¼ˆSKILL.md ä¸­çš„ nameï¼‰

        Returns:
            skill: BaseSkill å®ä¾‹
        """
        # TODO
        raise NotImplementedError
```
</details>


### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_skills.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_skills.py</b></summary>

   ```py
    import json
    from pathlib import Path

    import pytest

    from debate_mas.skills.base import SkillContext, BaseSkill, _auto_args_schema_from_execute
    from debate_mas.protocol import SkillResult
    from debate_mas.skills import registry as reg



    def _ctx_stub():
        return SkillContext.model_construct(
            dossier=object(),
            agent_role="hunter",
            ref_date="2025-01-01",
        )


    class OkSkill(BaseSkill):
        name = "ok_skill"
        description = "desc"
        expert_mindset = "expert"

        def execute(self, ctx: SkillContext, x: int = 1) -> SkillResult:
            return SkillResult.ok(data={"x": x}, insight="ok")


    class BadReturnSkill(BaseSkill):
        name = "bad_return"

        def execute(self, ctx: SkillContext, **kwargs):
            return {"not": "SkillResult"}


    class CrashSkill(BaseSkill):
        name = "crash"

        def execute(self, ctx: SkillContext, **kwargs) -> SkillResult:
            raise RuntimeError("boom")


    def test_safe_run_converges_errors_to_skillresult_fail():
        ctx = _ctx_stub()

        out1 = BadReturnSkill().safe_run(ctx)
        assert out1.success is False
        assert "SkillResult" in (out1.error_msg or "")

        out2 = CrashSkill().safe_run(ctx)
        assert out2.success is False
        assert "boom" in (out2.error_msg or "")


    def test_to_langchain_tool_returns_json_string():
        ctx = _ctx_stub()
        tool = OkSkill().to_langchain_tool(ctx)

        if hasattr(tool, "invoke"):
            raw = tool.invoke({"x": 7})
        else:
            raw = tool.run({"x": 7})

        payload = json.loads(raw)
        assert payload["success"] is True
        assert payload["data"]["x"] == 7


    def test_auto_args_schema_from_execute_basic():
        class S(BaseSkill):
            def execute(self, ctx: SkillContext, x: int, y: str = "a") -> SkillResult:
                return SkillResult.ok(data={"x": x, "y": y})

        schema = _auto_args_schema_from_execute(S.execute, model_name="S")
        fields = schema.model_fields

        assert "ctx" not in fields
        assert "x" in fields and "y" in fields
        assert fields["x"].is_required() is True
        assert fields["y"].is_required() is False



    def _write_skill_pkg(inventory: Path, *, folder: str, skill_name: str, broken: bool = False):
        skill_dir = inventory / folder
        (skill_dir / "scripts").mkdir(parents=True, exist_ok=True)

        (skill_dir / "SKILL.md").write_text(
            "\n".join(
                [
                    "---",
                    f"name: {skill_name}",
                    f"chinese_name: {skill_name}_CN",
                    "description: demo desc",
                    "---",
                    "EXPERT PROMPT HERE",
                    "",
                ]
            ),
            encoding="utf-8",
        )

        handler = skill_dir / "scripts" / "handler.py"
        if broken:
            handler.write_text("x = 1\n", encoding="utf-8") 
        else:
            handler.write_text(
                "\n".join(
                    [
                        "from debate_mas.skills.base import BaseSkill, SkillContext",
                        "from debate_mas.protocol import SkillResult",
                        "",
                        "class SkillHandler(BaseSkill):",
                        "    def execute(self, ctx: SkillContext, **kwargs) -> SkillResult:",
                        "        return SkillResult.ok(data={'ping': 1}, insight='ok')",
                        "",
                    ]
                ),
                encoding="utf-8",
            )


    def test_registry_loads_good_skill_and_degrades_bad_skill(monkeypatch: pytest.MonkeyPatch, tmp_path: Path):
        inventory = tmp_path / "inventory"
        inventory.mkdir(parents=True, exist_ok=True)
        _write_skill_pkg(inventory, folder="good_skill", skill_name="good_skill", broken=False)
        _write_skill_pkg(inventory, folder="bad_skill", skill_name="bad_skill", broken=True)

        monkeypatch.setattr(reg, "__file__", str(tmp_path / "registry.py"), raising=False)

        reg._SKILL_CACHE.clear()
        reg.SkillRegistry.load_all_skills(force_reload=True)

        assert "good_skill" in reg._SKILL_CACHE
        s = reg._SKILL_CACHE["good_skill"]
        assert s.name == "good_skill"
        assert s.chinese_name == "good_skill_CN"
        assert s.description == "demo desc"
        assert "EXPERT PROMPT HERE" in (s.expert_mindset or "")



    def test_get_skill_autoloads_when_empty(monkeypatch: pytest.MonkeyPatch):
        reg._SKILL_CACHE.clear()
        called = {"n": 0}

        def fake_load_all_skills(force_reload: bool = False):
            called["n"] += 1
            sk = OkSkill()
            sk.name = "x"
            reg._SKILL_CACHE["x"] = sk

        monkeypatch.setattr(reg.SkillRegistry, "load_all_skills", staticmethod(fake_load_all_skills), raising=True)

        s = reg.SkillRegistry.get_skill("x")
        assert called["n"] == 1
        assert s.name == "x"

  ```
  </details>

2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_skills.py
```


### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰
  - `5 passed in ...s`
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`ValidationError`ã€`AttributeError: ...model_rebuild...`
- å¦‚æœå¤±è´¥ï¼Œä½ åº”è¯¥èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°ä¸‰ç±»é—®é¢˜ï¼š
  - **SkillContext / Pydantic æ ¡éªŒä¸åŒ¹é…**
    - å…¸å‹ç°è±¡ï¼š`ValidationError: dossier Input should be ... Dossier`
    - å¤„ç†æ–¹å¼ï¼šæµ‹è¯•é‡Œç”¨ `SkillContext.model_construct(...)`ï¼ˆæˆ–æŒ‰çœŸå® Dossier æ„é€ ï¼‰
  - **safe_run / SkillResult æ”¶æ•›ä¸ç¨³å®š**
    - å…¸å‹ç°è±¡ï¼šæ–­è¨€ `success is False` å¤±è´¥ï¼Œæˆ– `error_msg` ä¸ºç©º
    - å¤„ç†æ–¹å¼ï¼šç¡®ä¿ `execute` è¿”å›é `SkillResult` æ—¶è½¬ `SkillResult.fail`ï¼Œå¼‚å¸¸è¢«æ•è·å¹¶å†™å…¥ `error_msg`
  - **registry åŠ¨æ€åŠ è½½/é™çº§é€»è¾‘æ–­è£‚**
    - å…¸å‹ç°è±¡ï¼š`good_skill` æ²¡è¿› `_SKILL_CACHE` æˆ–ååŒ…å¯¼è‡´æ•´ä½“ä¸­æ–­
    - å¤„ç†æ–¹å¼ï¼šæ£€æŸ¥ `inventory` æ‰«æã€`_parse_skill_md` è§£æã€`_load_package` çš„ try/except


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `skills/base.py + skills/registry.py` ç›®æ ‡æ˜¯ï¼š**æŠŠâ€œæŠ€èƒ½ï¼ˆSkillï¼‰â€åšæˆå¯æ’ä»¶åŒ–åŠ è½½ã€å¯ç»“æ„åŒ–è¿”å›ã€å¯è¢« LLM è°ƒç”¨çš„æœ€å°åè®®å±‚**ã€‚  
> 
> è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ é€šå¸¸åªéœ€è¦æ¢â€œæŠ€èƒ½ç›®å½•å†…å®¹ï¼ˆinventoryï¼‰â€ï¼Œè€Œä¸å¿…é‡å†™æ³¨å†Œä¸è°ƒç”¨åè®®ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

<details>
<summary><b>skills/base.py ä¸éœ€è¦åŠ¨çš„åœ°æ–¹</b></summary>

- **Skill çš„ç»Ÿä¸€å…¥å£**
  - `BaseSkill.safe_run(ctx, **kwargs) -> SkillResult`
  - åŸåˆ™ï¼šä»»ä½•å¼‚å¸¸éƒ½å¿…é¡»æ”¶æ•›ä¸º `SkillResult.fail(...)`ï¼Œä¸Šå±‚æ°¸ä¸å› å•ä¸ª skill å´©æºƒ

- **Tool é€‚é…åè®®**
  - `BaseSkill.to_langchain_tool(ctx)`
  - åŸåˆ™ï¼šç»Ÿä¸€è¿”å› **JSON å­—ç¬¦ä¸²**ï¼›schema é€‰æ‹©è§„åˆ™ç¨³å®šï¼ˆæ˜¾å¼ `args_schema` > è‡ªåŠ¨ç”Ÿæˆå¹¶ç¼“å­˜ï¼‰

- **Pydantic schema å…œåº•**
  - `_ensure_schema_ready(schema, execute_fn=...)`
  - åŸåˆ™ï¼šåŠ¨æ€åŠ è½½/forward-ref è§£æå¤±è´¥æ—¶ä¸å´©ï¼ˆå…è®¸åå¼‚å¸¸å…œåº•ï¼‰

</details>

<details>
<summary><b>skills/registry.py ä¸éœ€è¦åŠ¨çš„åœ°æ–¹</b></summary>

- **æ’ä»¶å¼æ³¨å†Œå…¥å£**
  - `SkillRegistry.load_all_skills(force_reload=False)`
  - åŸåˆ™ï¼šæ‰«æ `skills/inventory/*`ï¼›å•åŒ…å¤±è´¥å¯é™çº§ï¼Œä¸å½±å“æ•´ä½“

- **å•åŒ…åŠ è½½åè®®**
  - `_parse_skill_md(...)` + `_load_package(...)`
  - åŸåˆ™ï¼šSKILL.md è´Ÿè´£å…ƒä¿¡æ¯ï¼›handler.py æš´éœ² `SkillHandler`ï¼›æ³¨å†Œåªåšâ€œè§£æ + import + æ³¨å…¥ + ç¼“å­˜â€

- **ç¼“å­˜è®¿é—®**
  - `_SKILL_CACHE` + `get_skill(name)`
  - åŸåˆ™ï¼šç”¨ name ä½œä¸ºç¨³å®š keyï¼›æ‰¾ä¸åˆ°æ—¶æŠ›å¯è¯»é”™è¯¯

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–æ–°å¢**

è¿™éƒ¨åˆ†æ˜¯â€œä½ è¦æ–°å¢/æ›¿æ¢ skill çš„å†…å®¹â€ï¼Œè€Œä¸æ˜¯æ”¹æ³¨å†Œå±‚ã€‚

- **æ–°å¢ä¸€ä¸ªæ–°ä»»åŠ¡çš„æŠ€èƒ½**
  - è¿ç§»æ–¹å¼ï¼šæ–°å¢ä¸€ä¸ªç›®å½• `skills/inventory/<skill_name>/`
    - å†™ `SKILL.md`ï¼ˆname/chinese_name/description + expert promptï¼‰
    - å†™ `scripts/handler.py`ï¼ˆæš´éœ² `SkillHandler.execute(ctx, ...) -> SkillResult`ï¼‰
  - åŸåˆ™ï¼šåªè¦éµå®ˆåè®®ï¼Œregistry ä¼šè‡ªåŠ¨è¯†åˆ«å¹¶æ³¨å†Œ

- **æ›¿æ¢/æ‰©å±•å…ƒä¿¡æ¯å­—æ®µï¼ˆè°¨æ…ï¼‰**
  - å¦‚æœä½ ç¡®å®éœ€è¦æ›´å¤š metaï¼ˆä¾‹å¦‚ `version/tags/owner`ï¼‰ï¼Œä¼˜å…ˆåªæ‰©å±• `SKILL.md` çš„ YAML å­—æ®µï¼Œ
    å¹¶åœ¨ `_load_package` æ³¨å…¥åˆ° instance çš„é¢å¤–å±æ€§ï¼ˆä¸æ”¹å˜ BaseSkill çš„æ ¸å¿ƒåè®®ï¼‰ã€‚


**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
- **ä¸åŠ¨**ï¼š`skills/base.py + skills/registry.py` çš„åè®®éª¨æ¶ï¼ˆ`safe_run(ctx)->SkillResult` / `to_langchain_tool(ctx)` ç»Ÿä¸€ JSON è¾“å‡º / `load_all_skills()` æ‰«ææ³¨å†Œä¸ç¼“å­˜ï¼‰
- **åªæ”¹**ï¼š`skills/inventory/<skill_name>/` é‡Œçš„ä¸‰ä»¶å¥—ï¼š`SKILL.md`ï¼ˆå…ƒä¿¡æ¯+expert promptï¼‰/ `scripts/handler.py`ï¼ˆ`SkillHandler.execute(ctx, ...)->SkillResult`ï¼‰/ `references/*`ï¼ˆä¸šåŠ¡è¯´æ˜ä¸è¾“å‡ºå­—æ®µï¼‰
- **è°¨æ…æ”¹**ï¼šéœ€è¦æ–°å¢ meta å­—æ®µæ—¶ï¼Œåªæ‰© `SKILL.md` çš„ YAMLï¼Œå¹¶åœ¨ registry æ³¨å…¥åˆ°å®ä¾‹å±æ€§ï¼ˆåˆ«åŠ¨ BaseSkill å¥‘çº¦ï¼‰
- **ä¸€å¥è¯**ï¼š**åè®®ä¸æ”¹ã€æ³¨å†Œä¸åŠ¨ï¼›åªæ¢ inventory çš„å†…å®¹ï¼ˆæ–‡æ¡£+handler+å‚è€ƒï¼‰ï¼Œå°±èƒ½æ¢ä¸šåŠ¡**

</details>

---


## å…³å¡-10ï½œå·¥å…· Toolsï¼šskillâ†’tools æ˜ å°„ + ç»Ÿä¸€è°ƒç”¨å…¥å£ + å‡†å…¥å®ˆå«

<details>
<summary><b>Checkpoint 10 â€” å·¥å…· Tools ã€è¯¦æƒ…ã€‘</b></summary>

> æœ¬å…³è¦è§£å†³â€œ**å¦‚ä½•å®‰å…¨åœ°è®© LLM è°ƒç”¨**â€ï¼šæŠŠ skill è£…é…æˆ toolsï¼Œå¹¶åœ¨è°ƒç”¨å…¥å£åŠ ä¸Šå¯æ²»ç†çš„å®ˆå«æœºåˆ¶ã€‚
>
> æœ¬å…³é—­ç¯æ˜¯â€œå¯è°ƒç”¨ + å¯æ‹¦æˆªâ€çš„æœ€å°é—­ç¯ï¼š  
>
> **ä» registry å– skill â†’ è½¬æˆ StructuredTool â†’ æŒ‰è§’è‰² allowlist è£…é… â†’ Guard æ‹¦æˆªï¼ˆç™½åå•/ä¸Šé™/dedupï¼‰â†’ ç»Ÿä¸€è¿”å›ç¨³å®š JSON â†’ å†™ tool_trace**
>
> è¿™ä¸€å…³çš„ç›®æ ‡ä¸æ˜¯æ›´èªæ˜ï¼Œè€Œæ˜¯æ›´å¯æ§ï¼š  
> - ä¸åŒè§’è‰²çœ‹åˆ°çš„å¯ç”¨å·¥å…·é›†åˆä¸åŒ
> - ä¸åˆè§„è°ƒç”¨ä¸ä¼šæŠ›å¼‚å¸¸ï¼Œè€Œæ˜¯è¿”å›å¯å®¡è®¡çš„æ‹’ç»ç»“æœ
> - æ¯æ¬¡è°ƒç”¨éƒ½ç•™ä¸‹ traceï¼Œä¾¿äºå¤ç›˜ä¸æµ‹è¯•


### ğŸ¯ ç›®æ ‡æ”¶è· Outcome
- å­¦ä¼šæŠŠ skill è£…æˆ **StructuredTool** å¹¶æŒ‰ role è¾“å‡º tools åˆ—è¡¨
- å®ç°â€œç»Ÿä¸€è°ƒç”¨å…¥å£â€ï¼š
  - è°ƒç”¨å‰ï¼šschema è¿‡æ»¤ + policy æ³¨å…¥
  - è°ƒç”¨ä¸­ï¼šallowlist / max_calls / dedup æ‹¦æˆª
  - è°ƒç”¨åï¼šç»Ÿä¸€ JSON è¾“å‡º + tool_trace è®°å½•ï¼ˆå« denied/produced_nï¼‰
- è®©å‡†å…¥æœºåˆ¶ **å¯æµ‹è¯•**ï¼šé€šè¿‡ monkeypatch é…ç½®ä¸ registryï¼Œä¸ä¾èµ–çœŸå®æŠ€èƒ½æ•°é‡


### ğŸ§± çº¦æŸå¥‘çº¦ Contract
- æœ¬å…³ä¼˜å…ˆåªæ”¹ï¼š
  - `src/debate_mas/core/tools.py`
- ä¸æ”¹ï¼š
  - `skills/base.py` çš„ `BaseSkill.execute/safe_run/to_langchain_tool` åè®®
  - `protocol/SkillResult`ã€`loader/Dossier` çš„æ—¢æœ‰å¥‘çº¦
- ä»»ä½•è¢«æ‹’ç»æˆ–å¼‚å¸¸çš„ tool è°ƒç”¨éƒ½å¿…é¡» **è¿”å› JSON å­—ç¬¦ä¸²**ï¼Œè€Œä¸æ˜¯æŠ›å¼‚å¸¸


### ğŸ—ºï¸ ä»»åŠ¡æ¸…å•ï¼ˆTODO Mapï¼‰

**å¿…çœ‹**
- `src/debate_mas/core/tools.py`
  - `build_ctx(...)`ï¼šç»™ tool æ³¨å…¥ ctxï¼ˆdossier/role/ref_dateï¼‰
  - `build_tools_for_role(...)`ï¼šä» allowlist è£…é… tools
  - `_wrap_tool_with_guard(...)`ï¼šç»Ÿä¸€è°ƒç”¨å…¥å£ï¼ˆpolicy â†’ guard â†’ invoke â†’ traceï¼‰
  - `tool_guard_check(...)`ï¼šallowlist / max_calls / dedup ä¸‰é“é—¸
  - `_append_tool_trace(...)`ï¼šæŠŠè°ƒç”¨ç»“æœå†™è¿› state.tool_trace

**å¿…å†™ï¼ˆæ¡†æ¶é€šç”¨ï¼‰**
- `build_tools_for_role(...)`ï¼šåªè£…é… allowlist å†…å·¥å…·ï¼›registry è·å– skill åè½¬ tool
- `tool_guard_check(...)`ï¼šä¸‰é“é—¸å¿…é¡»å¯è¯»å¯è¯Šæ–­ï¼ˆè¿”å› bool, reasonï¼‰
- `_wrap_tool_with_guard(...)`ï¼š
  - è°ƒç”¨å‰ï¼šæŒ‰ schema keys è¿‡æ»¤å‚æ•° + policy æ³¨å…¥
  - è°ƒç”¨å¤±è´¥/æ‹’ç»ï¼šå¿…é¡»è¿”å› JSONï¼ˆGUARD_DENY / SkillResult.failï¼‰
  - è°ƒç”¨åï¼šå†™ traceï¼ˆok/denied/elapsed_ms/produced_nï¼‰

**å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼Œè¿ç§»å¯æ›¿æ¢ï¼‰**
- `quantitative_sniper` çš„ policy æ³¨å…¥ï¼ˆstrategy/defaults/profile/enforce/top_k ä¸Šé™ï¼‰
- `portfolio_allocator` ä» state æ³¨å…¥ `candidates/risk_reports`ï¼ˆä»…å½“ schema æ”¯æŒï¼‰

**é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰**
- `ToolNode` å‰å¯¹ tool_calls args åšè½»é‡æ¸…æ´—ï¼ˆå­—ç¬¦ä¸² list â†’ listï¼‰
- `produced_n` ç»Ÿè®¡ï¼šä» `data.items/candidates/results` æ¨æ–­äº§å‡ºæ¡æ•°ï¼ˆä¾¿äº summaryï¼‰
  
<details>
<summary><b>ğŸ“„ src/debate_mas/core/tools.py ç»ƒä¹ éª¨æ¶</b></summary>

```py
# src/debate_mas/core/tools.py
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple, Callable, Set
from contextvars import ContextVar

from langchain_core.tools import StructuredTool
from langchain_core.messages import AIMessage
from langgraph.prebuilt import ToolNode

from debate_mas.skills.registry import SkillRegistry
from debate_mas.skills.base import SkillContext
from debate_mas.protocol import SkillResult

from .config import CONFIG
from .state import DebateState, mark_guard_denied


# ============================================================
# SECTION 0) ç±»å‹ä¸è¿è¡Œæ—¶ state æ³¨å…¥
# ============================================================
_CURRENT_STATE: ContextVar[Optional[DebateState]] = ContextVar("_CURRENT_STATE", default=None)
ToolRunner = Callable[[DebateState], DebateState]


def _get_runtime_state(fallback: DebateState) -> DebateState:
    """
    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - ä» ContextVar è¯»å–â€œè¿è¡Œæ—¶ stateâ€
      - è‹¥å–ä¸åˆ°åˆ™å›é€€åˆ° fallback
      - ç›®çš„ï¼šé¿å…é—­åŒ…æ•è·æ—§ state

    Args:
        fallback: å…œåº•ç”¨çš„ state

    Returns:
        st: å½“å‰è¿è¡Œæ—¶åº”ä½¿ç”¨çš„ state
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 1) æŒ‡çº¹ / ç¨³å®šåºåˆ—åŒ–
# ============================================================
def _json_dumps_stable(obj: Any) -> str:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å°† obj ç¨³å®šåºåˆ—åŒ–ä¸º JSON å­—ç¬¦ä¸²
      - ä¼˜å…ˆï¼šsort_keys + å›ºå®š separators
      - å¤±è´¥ï¼šé€€åŒ–ä¸º json.dumps(str(obj))
      - ç›®çš„ï¼šdedup æŒ‡çº¹è¾“å…¥å¿…é¡»ç¨³å®š

    Args:
        obj: ä»»æ„å¯åºåˆ—åŒ–å¯¹è±¡

    Returns:
        s: ç¨³å®š JSON å­—ç¬¦ä¸²
    """
    # TODO
    raise NotImplementedError


def fingerprint(tool_name: str, tool_args: Dict[str, Any]) -> str:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ç»„åˆ tool_name ä¸ç¨³å®šåºåˆ—åŒ–åçš„ tool_args
      - ç”¨ sha1 è®¡ç®—æŒ‡çº¹ï¼ˆhex digestï¼‰
      - ç›®çš„ï¼šåŒå›åˆåŒ tool åŒå‚æ•°çš„ dedup

    Args:
        tool_name: å·¥å…·å
        tool_args: å·¥å…·å‚æ•°ï¼ˆdictï¼‰

    Returns:
        fp: æŒ‡çº¹å­—ç¬¦ä¸²ï¼ˆsha1 hexï¼‰
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 2) ctx æ„å»ºï¼ˆæ³¨å…¥ role/ref_date/dossierï¼‰
# ============================================================
def build_ctx(dossier, role: str, ref_date: Optional[str]) -> SkillContext:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - æ„é€  SkillContext
      - æ³¨å…¥ dossier / agent_role / ref_date
      - ä¸åœ¨è¿™é‡Œåšä¸šåŠ¡æ ¡éªŒï¼ˆåªè´Ÿè´£è£…é…ï¼‰

    Args:
        dossier: æ•°æ®æ¡ˆå·ï¼ˆDossierï¼‰
        role: è§’è‰²åï¼ˆhunter/auditor/pmï¼‰
        ref_date: åŸºå‡†æ—¥ï¼ˆå¯é€‰ï¼‰

    Returns:
        ctx: SkillContext
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 3) schema è¿‡æ»¤å·¥å…·
# ============================================================
def _is_empty_value(v: Any) -> bool:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - åˆ¤ç©ºï¼šNone æˆ–ç©ºå­—ç¬¦ä¸²ï¼ˆstrip åä¸ºç©ºï¼‰
      - ç›®çš„ï¼špolicy æ³¨å…¥æ—¶åŒºåˆ†â€œæœªæä¾›â€ vs â€œæä¾›äº†æœ‰æ•ˆå€¼â€

    Args:
        v: ä»»æ„å€¼

    Returns:
        is_empty: æ˜¯å¦ä¸ºç©ºå€¼
    """
    # TODO
    raise NotImplementedError


def _schema_keys_from_tool(base_tool: StructuredTool) -> Optional[Set[str]]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ä» base_tool.args_schema æå–å­—æ®µåé›†åˆ
      - å…¼å®¹ pydantic v2 çš„ model_fields ä¸ v1 çš„ __fields__
      - å¤±è´¥è¿”å› Noneï¼ˆè¡¨ç¤ºä¸åš schema è¿‡æ»¤ï¼‰

    Args:
        base_tool: StructuredToolï¼ˆå« args_schemaï¼‰

    Returns:
        keys: schema å­—æ®µåé›†åˆï¼›æœªçŸ¥åˆ™ None
    """
    # TODO
    raise NotImplementedError


def _filter_to_schema(args: Dict[str, Any], schema_keys: Optional[Set[str]]) -> Dict[str, Any]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - è‹¥ schema_keys ä¸º Noneï¼šåŸæ ·è¿”å›
      - å¦åˆ™åªä¿ç•™ keys å†…çš„å‚æ•°
      - ç›®çš„ï¼šé¿å…â€œæœªçŸ¥å­—æ®µâ€è§¦å‘ args_schema æ ¡éªŒå¤±è´¥

    Args:
        args: åŸå§‹å‚æ•°
        schema_keys: schema å­—æ®µé›†åˆæˆ– None

    Returns:
        filtered: è¿‡æ»¤åçš„å‚æ•°
    """
    # TODO
    raise NotImplementedError


def _fill_missing(args: Dict[str, Any], defaults: Dict[str, Any], schema_keys: Optional[Set[str]]) -> Dict[str, Any]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - åªå¯¹ç¼ºå¤±/ç©ºå€¼çš„å­—æ®µè¡¥ defaultsï¼ˆä¸è¦†ç›–æœ‰æ•ˆå€¼ï¼‰
      - è‹¥ schema_keys ç»™å®šï¼šåªè¡¥ schema æ”¯æŒçš„å­—æ®µ
      - ç›®çš„ï¼šç»™å·¥å…·æä¾›ç¨³å®šé»˜è®¤å€¼ä½†ä¸æŠ¢ LLM çš„æ˜¾å¼è¾“å…¥

    Args:
        args: åŸå‚æ•°
        defaults: é»˜è®¤å€¼é›†åˆ
        schema_keys: schema å­—æ®µé›†åˆæˆ– None

    Returns:
        out: è¡¥é½åçš„å‚æ•°
    """
    # TODO
    raise NotImplementedError


def _force_override(args: Dict[str, Any], overrides: Dict[str, Any], schema_keys: Optional[Set[str]]) -> Dict[str, Any]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å¼ºåˆ¶è¦†ç›–ï¼šoverrides ä¸­å­—æ®µç›´æ¥å†™å…¥
      - è‹¥ schema_keys ç»™å®šï¼šåªè¦†ç›– schema æ”¯æŒçš„å­—æ®µ
      - ç›®çš„ï¼šå°‘é‡ç¡¬å¼ºæ§å‚æ•°ï¼ˆä¸Šå±‚æ²»ç†éœ€è¦ï¼‰

    Args:
        args: åŸå‚æ•°
        overrides: å¼ºæ§è¦†ç›–é¡¹
        schema_keys: schema å­—æ®µé›†åˆæˆ– None

    Returns:
        out: è¦†ç›–åçš„å‚æ•°
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 4) policy åº”ç”¨
# ============================================================
def _apply_tool_policy(tool_name: str, tool_args: Dict[str, Any], schema_keys: Optional[Set[str]]) -> Dict[str, Any]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å¯¹å…¥å‚åšæœ€å°â€œçº é”™ + é»˜è®¤å€¼ + å¼ºæ§â€
      - æœ€åå¿…é¡» _filter_to_schema(...)ï¼Œé¿å…æœªçŸ¥å­—æ®µ

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - quantitative_sniperï¼šstrategy/defaults/profile/enforce/top_k ä¸Šé™
      - composite_weightsï¼šå…è®¸ str/list å…œåº•æˆ dict[str,float]ï¼ˆä»… schema æ”¯æŒæ—¶å†™å›ï¼‰
      - portfolio_allocatorï¼šæœ¬å‡½æ•°é‡Œåªåš enforceï¼Œcandidates/risk_reports æ³¨å…¥åœ¨ wrapper é‡Œåš

    Args:
        tool_name: å·¥å…·å
        tool_args: åŸå§‹å‚æ•°
        schema_keys: schema å­—æ®µé›†åˆæˆ– None

    Returns:
        args: policy å¤„ç†åçš„å‚æ•°ï¼ˆå·²æŒ‰ schema è¿‡æ»¤ï¼‰
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 5) Guardï¼šç™½åå•/ä¸Šé™/å»é‡
# ============================================================
def tool_guard_check(
    role: str,
    tool_name: str,
    tool_args: Dict[str, Any],
    state: DebateState,
) -> Tuple[bool, str]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - allowlistï¼štool ä¸åœ¨è§’è‰²ç™½åå•ç›´æ¥æ‹’ç»
      - max_callsï¼šè¶…è¿‡æœ¬è½®ä¸Šé™æ‹’ç»ï¼ˆè¯»å– state é‡Œçš„è®¡æ•°ï¼‰
      - dedupï¼šåŒå›åˆåŒ tool+args æŒ‡çº¹å‘½ä¸­åˆ™æ‹’ç»ï¼ˆå¯å¼€å…³ï¼‰
      - è¿”å› (allowed, reason)ï¼Œreason å¿…é¡»å¯è¯»å¯è¯Šæ–­

    Args:
        role: è§’è‰²å
        tool_name: å·¥å…·å
        tool_args: å·¥å…·å‚æ•°
        state: è¿è¡Œæ—¶ stateï¼ˆå«æœ¬è½®è®¡æ•°/æŒ‡çº¹é›†ï¼‰

    Returns:
        allowed: æ˜¯å¦å…è®¸è°ƒç”¨
        reason: å…è®¸åˆ™ "ok"ï¼Œæ‹’ç»åˆ™ç»™å‡ºåŸå› 
    """
    # TODO
    raise NotImplementedError


def _guard_deny_payload(reason: str) -> str:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å°†æ‹’ç»åŸå› åŒ…è£…æˆ SkillResult.fail
      - ç»Ÿä¸€è¿”å› JSON å­—ç¬¦ä¸²ï¼ˆensure_ascii=Falseï¼‰
      - error_msg éœ€å¸¦ [GUARD_DENY] å‰ç¼€ä¾¿äºå®šä½

    Args:
        reason: æ‹’ç»åŸå› 

    Returns:
        payload_json: JSON å­—ç¬¦ä¸²
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 6) tool è¾“å‡ºè§£æï¼šç”¨äº trace ç»Ÿè®¡ produced_n
# ============================================================
def _try_parse_tool_json(text: str) -> Optional[Dict[str, Any]]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - å°è¯•æŠŠ text è§£ææˆ dict
      - å¤±è´¥è¿”å› Noneï¼ˆä¸æŠ›å¼‚å¸¸ï¼‰
      - ç›®çš„ï¼štrace/produced_n ç»Ÿè®¡éœ€è¦ç»“æ„åŒ–ç»“æœ

    Args:
        text: å·¥å…·è¾“å‡ºæ–‡æœ¬ï¼ˆæœŸæœ›ä¸º JSONï¼‰

    Returns:
        obj: dict æˆ– None
    """
    # TODO
    raise NotImplementedError


def _count_produced(obj: Optional[Dict[str, Any]]) -> int:
    """
    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - ä» SkillResult ç»“æ„æ¨æ–­äº§å‡ºæ¡æ•°
      - ä¼˜å…ˆ data.items / data.candidates / data.results çš„ list é•¿åº¦
      - å…œåº•ï¼šé¡¶å±‚ items è‹¥å­˜åœ¨ä¹Ÿå¯ç»Ÿè®¡

    Args:
        obj: è§£æåçš„å·¥å…·è¾“å‡º dict

    Returns:
        n: äº§å‡ºæ¡æ•°ï¼ˆæ— æ³•ç»Ÿè®¡åˆ™ 0ï¼‰
    """
    # TODO
    raise NotImplementedError


def _append_tool_trace(
    state: DebateState,
    *,
    role: str,
    tool: str,
    args: Dict[str, Any],
    ok: bool,
    insight: str = "",
    error_msg: Optional[str] = None,
    visuals: Optional[List] = None,
    elapsed_ms: Optional[int] = None,
    denied: bool = False,
    produced_n: Optional[int] = None,
) -> None:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ç¡®ä¿ state.tool_trace æ˜¯ list
      - è¿½åŠ ä¸€æ¡ traceï¼šrole/tool/args/ok/denied/elapsed_ms/produced_n
      - round_idx/ts å¯å†™å…¥ï¼ˆä¾¿äºå¤ç›˜ï¼‰ï¼Œå­—æ®µç¼ºå¤±ä¹Ÿä¸åº”æŠ¥é”™

    Args:
        state: è¿è¡Œæ—¶ stateï¼ˆä¼šè¢«åŸåœ°æ›´æ–°ï¼‰
        role: è§’è‰²å
        tool: å·¥å…·å
        args: è°ƒç”¨å‚æ•°
        ok: è°ƒç”¨æ˜¯å¦æˆåŠŸï¼ˆæŒ‰ success æ¨æ–­ï¼‰
        insight: ç»“æœæ‘˜è¦ï¼ˆå¯é€‰ï¼‰
        error_msg: é”™è¯¯ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
        visuals: å¯è§†åŒ–ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
        elapsed_ms: è€—æ—¶æ¯«ç§’ï¼ˆå¯é€‰ï¼‰
        denied: æ˜¯å¦è¢« guard æ‹’ç»
        produced_n: äº§å‡ºæ¡æ•°ï¼ˆå¯é€‰ï¼‰

    Returns:
        None
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 7) Tool æ„å»ºï¼šç»™ LangChain çš„ StructuredTool
# ============================================================
def build_tools_for_role(
    role: str,
    ctx: SkillContext,
    state: DebateState,
) -> List[StructuredTool]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - è§¦å‘ SkillRegistry.load_all_skills()
      - è¯»å– CONFIG.ROLE_TOOL_ALLOWLIST[role]
      - åªä¸º allowlist ä¸­æ¯ä¸ª tool_nameï¼š
        - skill = SkillRegistry.get_skill(tool_name)
        - base_tool = skill.to_langchain_tool(ctx)
        - tools.append(_wrap_tool_with_guard(...))
      - è‹¥ allowlist ä¸ºç©ºï¼šè¿”å›ç©º listï¼ˆä¸æŠ¥é”™ï¼‰

    Args:
        role: è§’è‰²å
        ctx: SkillContextï¼ˆå·²æ³¨å…¥ dossier/role/ref_dateï¼‰
        state: è¿è¡Œæ—¶ stateï¼ˆç”¨äº guard/traceï¼‰

    Returns:
        tools: å¯è°ƒç”¨çš„ StructuredTool åˆ—è¡¨
    """
    # TODO
    raise NotImplementedError


def _wrap_tool_with_guard(
    *,
    role: str,
    tool_name: str,
    base_tool: StructuredTool,
    state: DebateState,
) -> StructuredTool:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ç»Ÿä¸€è°ƒç”¨å…¥å£ï¼špolicy â†’ guard â†’ invoke â†’ trace
      - è°ƒç”¨å‰ï¼š
        - schema_keys = _schema_keys_from_tool(base_tool)
        - tool_args = _apply_tool_policy(tool_name, kwargs, schema_keys)
      - è°ƒç”¨å¤±è´¥/æ‹’ç»ï¼š
        - å¿…é¡» return JSONï¼ˆ_guard_deny_payload æˆ– SkillResult.failï¼‰
      - è°ƒç”¨åï¼š
        - out_json å¿…é¡»æ˜¯ strï¼ˆè‹¥æ˜¯ dict è¦ json.dumpsï¼‰
        - è§£æ out_objï¼Œæ¨æ–­ ok ä¸ produced_nï¼Œå¹¶å†™ trace

    TODOã€å¿…å†™ï¼ˆETFä»»åŠ¡ç›¸å…³ï¼‰ã€‘:
      - portfolio_allocatorï¼šä» state æ³¨å…¥ candidates/risk_reportsï¼ˆä»…å½“ schema æ”¯æŒï¼‰
      - quantitative_sniperï¼šå¯è®°å½• strategy ä½¿ç”¨æƒ…å†µï¼ˆå†™å…¥ state çš„ç»Ÿè®¡å­—æ®µï¼Œéå¿…é¡»ï¼‰

    Args:
        role: è§’è‰²å
        tool_name: å·¥å…·å
        base_tool: skill.to_langchain_tool(ctx) å¾—åˆ°çš„ tool
        state: è¿è¡Œæ—¶ stateï¼ˆä¼šè¢«åŸåœ°æ›´æ–°ï¼‰

    Returns:
        wrapped: å¸¦ guard çš„ StructuredTool
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 8) ToolNode æ„å»ºï¼ˆç»™ graph.py ç”¨ï¼‰
# ============================================================
def build_tool_node_for_role(
    role: str,
    tools: List[StructuredTool],
    state: DebateState,
) -> Optional[ToolRunner]:
    """
    TODOã€é€‰æ”¹ï¼ˆæ‹“å±•ä½ï¼‰ã€‘:
      - è‹¥ tools ä¸ºç©ºï¼šè¿”å› None
      - ç”¨ ToolNode(tools=tools) æ„å»ºåŸå§‹èŠ‚ç‚¹
      - è¿è¡Œæ—¶æŠŠ state_in æ³¨å…¥ ContextVarï¼Œä¿è¯ wrapper è¯»åˆ°æœ€æ–° state
      - å¯å¯¹ last_msg.tool_calls çš„ args åšè½»é‡æ¸…æ´—ï¼ˆå­—ç¬¦ä¸² list â†’ listï¼‰

    Args:
        role: è§’è‰²å
        tools: è¯¥è§’è‰²å¯ç”¨ tools
        state: fallback stateï¼ˆé—­åŒ…å…œåº•ï¼‰

    Returns:
        node: ToolRunner(state)->stateï¼›æ—  tools æ—¶è¿”å› None
    """
    # TODO
    raise NotImplementedError


# ============================================================
# SECTION 9) ä¾¿åˆ©å‡½æ•°ï¼šæŒ‰ role ç›´æ¥è£…é…
# ============================================================
def build_role_tools_and_node(
    *,
    role: str,
    dossier,
    ref_date: Optional[str],
    state: DebateState,
) -> Tuple[List[StructuredTool], ToolRunner, SkillContext]:
    """
    TODOã€å¿…å†™ï¼ˆé€šç”¨æ¡†æ¶ï¼‰ã€‘:
      - ctx = build_ctx(...)
      - tools = build_tools_for_role(...)
      - node = build_tool_node_for_role(...)
      - è‹¥ node ä¸º Noneï¼šæŠ› ValueErrorï¼ˆä¿¡æ¯å¯è¯»ï¼‰

    Args:
        role: è§’è‰²å
        dossier: æ•°æ®æ¡ˆå·ï¼ˆDossierï¼‰
        ref_date: åŸºå‡†æ—¥ï¼ˆå¯é€‰ï¼‰
        state: è¿è¡Œæ—¶ state

    Returns:
        tools: å¯è°ƒç”¨ tools åˆ—è¡¨
        node: ToolRunnerï¼ˆå¯è¢« graph è°ƒç”¨ï¼‰
        ctx: SkillContext
    """
    # TODO
    raise NotImplementedError

```
</details>


### â–¶ï¸ æ‰§è¡Œå‘½ä»¤ Run

æœ¬å…³ç”¨ **pytest** åšæœ€å°éªŒæ”¶ã€‚

1) æ–°å»ºæµ‹è¯•æ–‡ä»¶ï¼š`tests/test_tools.py`
   æŠŠä¸‹é¢ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ï¼š

   <details>
   <summary><b>tests/test_tools.py</b></summary>

   ```py
    import json
    from typing import Any, Dict, List, Optional

    import pytest
    from pydantic import BaseModel, Field

    from debate_mas.protocol import SkillResult
    from debate_mas.skills.base import SkillContext
    from debate_mas.core import tools as t


    class _FakeConfig:
        ROLE_TOOL_ALLOWLIST = {
            "hunter": ["quantitative_sniper"],
            "pm": ["portfolio_allocator"],
            "auditor": [],
        }
        ROLE_TOOL_MAX_CALLS = {"hunter": 1, "pm": 2, "auditor": 0}
        FORBID_SAME_TOOL_SAME_ARGS_IN_SAME_ROUND = True

        HUNTER_PIPELINE_SNIPER_STRATEGY = "composite"
        HUNTER_RERANK_OUTPUT_TOPN = 3

        SNIPER_DEFAULTS = {"top_k": 5, "min_amount": 0}
        SNIPER_PROFILES = {
            "composite": {"top_k": 9},  
            "momentum": {"top_k": 7},
        }
        SNIPER_ENFORCE = {}  
        SNIPER_LIMITS = {"max_top_k": 4}  
        PM_PORTFOLIO_ALLOCATOR_ENFORCE = {}


    class _DummyDossier:
        """æœ€å° dossier å ä½ã€‚æµ‹è¯•ä¸ä¾èµ–å…¶å†…å®¹ã€‚"""


    def _ctx_stub(role: str) -> SkillContext:
        return SkillContext.model_construct(dossier=_DummyDossier(), agent_role=role, ref_date="2025-01-01")


    class _SniperArgs(BaseModel):
        strategy: Optional[str] = None
        top_k: int = 10
        composite_weights: Optional[dict] = None


    class _AllocatorArgs(BaseModel):
        candidates: List[dict] = Field(default_factory=list)
        risk_reports: List[dict] = Field(default_factory=list)


    class _FakeStructuredTool:
        """
        è½»é‡æ›¿èº«ï¼šåªæä¾› invoke() / args_schema / name / description
        ï¼ˆé¿å… LangChain ç‰ˆæœ¬å·®å¼‚å¯¼è‡´æµ‹è¯•è„†å¼±ï¼‰
        """
        def __init__(self, *, name: str, args_schema, handler):
            self.name = name
            self.description = ""
            self.args_schema = args_schema
            self._handler = handler

        def invoke(self, tool_args: Dict[str, Any]):
            return self._handler(tool_args)


    class _FakeSkill:
        def __init__(self, name: str, base_tool: _FakeStructuredTool):
            self.name = name
            self._tool = base_tool

        def to_langchain_tool(self, ctx: SkillContext):
            return self._tool

    def test_build_ctx_injects_fields():
        ctx = t.build_ctx(_DummyDossier(), role="hunter", ref_date="2025-01-01")
        assert ctx.agent_role == "hunter"
        assert ctx.ref_date == "2025-01-01"
        assert ctx.dossier is not None


    def test_build_tools_for_role_uses_allowlist_only(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)

        called = {"get": [], "load": 0}

        def fake_load_all_skills():
            called["load"] += 1

        def fake_get_skill(name: str):
            called["get"].append(name)
            tool = _FakeStructuredTool(
                name=name,
                args_schema=_SniperArgs,
                handler=lambda _: json.dumps(SkillResult.ok(data={"ping": 1}).model_dump(), ensure_ascii=False),
            )
            return _FakeSkill(name, tool)

        monkeypatch.setattr(t.SkillRegistry, "load_all_skills", staticmethod(fake_load_all_skills), raising=True)
        monkeypatch.setattr(t.SkillRegistry, "get_skill", staticmethod(fake_get_skill), raising=True)

        st = {}
        ctx = _ctx_stub("hunter")
        tools = t.build_tools_for_role("hunter", ctx, st)

        assert called["load"] == 1
        assert called["get"] == ["quantitative_sniper"]
        assert len(tools) == 1
        assert tools[0].name == "quantitative_sniper"


    def test_guard_denies_not_in_allowlist(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)
        st = {"_round_tool_calls": {"hunter": 0}, "_round_fingerprints": set()}
        ok, reason = t.tool_guard_check("hunter", "not_allowed", {}, st)
        assert ok is False
        assert "ç™½åå•" in reason


    def test_guard_denies_over_max_calls(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)
        st = {"_round_tool_calls": {"hunter": 1}, "_round_fingerprints": set()}
        ok, reason = t.tool_guard_check("hunter", "quantitative_sniper", {}, st)
        assert ok is False
        assert "ä¸Šé™" in reason


    def test_guard_denies_dedup_same_tool_same_args(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)
        args = {"x": 1}
        fp = t.fingerprint("quantitative_sniper", args)

        st = {"_round_tool_calls": {"hunter": 0}, "_round_fingerprints": {fp}}
        ok, reason = t.tool_guard_check("hunter", "quantitative_sniper", args, st)
        assert ok is False
        assert "dedup" in reason.lower() or "é‡å¤" in reason


    def test_wrap_tool_with_guard_denied_returns_json_and_writes_trace(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)

        base_tool = _FakeStructuredTool(
            name="quantitative_sniper",
            args_schema=_SniperArgs,
            handler=lambda _: (_ for _ in ()).throw(RuntimeError("should not call")),
        )

        st = {"round_idx": 0, "_round_tool_calls": {"hunter": 0}, "_round_fingerprints": set()}
        wrapped = t._wrap_tool_with_guard(role="hunter", tool_name="not_allowed", base_tool=base_tool, state=st)

        out = wrapped.invoke({"top_k": 10})
        obj = json.loads(out)
        assert obj["success"] is False
        assert "[GUARD_DENY]" in (obj.get("error_msg") or "")
        assert st.get("tool_trace") and st["tool_trace"][-1]["denied"] is True


    def test_wrap_tool_with_guard_ok_returns_json_and_trace(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)

        def handler(args: Dict[str, Any]) -> str:
            payload = SkillResult.ok(data={"items": [1, 2]}, insight="ok").model_dump()
            payload["data"]["seen_top_k"] = args.get("top_k")
            payload["data"]["seen_strategy"] = args.get("strategy")
            return json.dumps(payload, ensure_ascii=False)

        base_tool = _FakeStructuredTool(
            name="quantitative_sniper",
            args_schema=_SniperArgs,
            handler=handler,
        )

        st = {"round_idx": 0, "_round_tool_calls": {"hunter": 0}, "_round_fingerprints": set()}
        wrapped = t._wrap_tool_with_guard(role="hunter", tool_name="quantitative_sniper", base_tool=base_tool, state=st)

        out = wrapped.invoke({})
        obj = json.loads(out)

        assert obj["success"] is True
        assert st["tool_trace"][-1]["produced_n"] == 2
        assert st["tool_trace"][-1]["ok"] is True

        assert obj["data"]["seen_strategy"] == "composite"
        assert int(obj["data"]["seen_top_k"]) <= 4


    def test_portfolio_allocator_injects_state_fields_when_schema_supports(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)

        def handler(args: Dict[str, Any]) -> str:
            payload = SkillResult.ok(data={"candidates": args.get("candidates"), "risk_reports": args.get("risk_reports")}).model_dump()
            return json.dumps(payload, ensure_ascii=False)

        base_tool = _FakeStructuredTool(
            name="portfolio_allocator",
            args_schema=_AllocatorArgs,
            handler=handler,
        )

        st = {
            "round_idx": 0,
            "_round_tool_calls": {"pm": 0},
            "_round_fingerprints": set(),
            "candidates_cur": [{"code": "510300"}],
            "risk_reports": [{"code": "510300", "risk": "low"}],
        }

        wrapped = t._wrap_tool_with_guard(role="pm", tool_name="portfolio_allocator", base_tool=base_tool, state=st)
        out = wrapped.invoke({}) 
        obj = json.loads(out)

        assert obj["success"] is True
        assert obj["data"]["candidates"] == [{"code": "510300"}]
        assert obj["data"]["risk_reports"] == [{"code": "510300", "risk": "low"}]


    def test_runtime_state_contextvar_affects_wrapper_trace(monkeypatch: pytest.MonkeyPatch):
        monkeypatch.setattr(t, "CONFIG", _FakeConfig, raising=True)

        def handler(_args: Dict[str, Any]) -> str:
            payload = SkillResult.ok(data={"items": [1]}).model_dump()
            return json.dumps(payload, ensure_ascii=False)

        base_tool = _FakeStructuredTool(
            name="quantitative_sniper",
            args_schema=_SniperArgs,
            handler=handler,
        )

        fallback_state = {"round_idx": 0, "_round_tool_calls": {"hunter": 0}, "_round_fingerprints": set()}
        wrapped = t._wrap_tool_with_guard(
            role="hunter",
            tool_name="quantitative_sniper",
            base_tool=base_tool,
            state=fallback_state,
        )

        state_in = {"round_idx": 7, "_round_tool_calls": {"hunter": 0}, "_round_fingerprints": set()}
        token = t._CURRENT_STATE.set(state_in)
        try:
            out = wrapped.invoke({})
            assert json.loads(out)["success"] is True
        finally:
            t._CURRENT_STATE.reset(token)

        assert state_in.get("tool_trace")
        assert state_in["tool_trace"][-1]["round_idx"] == 7

   ```
   </details>


2) è¿è¡Œæµ‹è¯•
   
```bash
uv run pytest -q tests/test_tools.py
```


### âœ… éªŒæ”¶æ ‡å‡† Pass

- ç»ˆç«¯è¾“å‡ºç±»ä¼¼ä¸‹é¢ä¿¡æ¯ï¼ˆæ•°å­—å¯èƒ½ä¸åŒï¼Œä½†æ ¸å¿ƒæ˜¯ **passed**ï¼‰
  - `9 passed in ...s`
- è¿‡ç¨‹ä¸­æ²¡æœ‰å‡ºç° `ImportError`ã€`pydantic ValidationError`ã€`AttributeError: ...args_schema...`ã€`KeyError: tool_trace`
- å¦‚æœå¤±è´¥ï¼Œä½ åº”è¯¥èƒ½ä»æŠ¥é”™å¿«é€Ÿå®šä½åˆ°ä¸‰ç±»é—®é¢˜ï¼š
  - **allowlist/guard æ²¡æ¥å¯¹**
    - å…¸å‹ç°è±¡ï¼š`not_allowed` ä»èƒ½è°ƒç”¨æˆåŠŸï¼Œæˆ– deny çš„ reason ä¸å«â€œç™½åå•/ä¸Šé™/dedupâ€
    - å¤„ç†æ–¹å¼ï¼šæ£€æŸ¥ `tool_guard_check(...)` ä¸‰é“é—¸ä¸ CONFIG å­—æ®µåæ˜¯å¦ä¸æµ‹è¯•çš„ `_FakeConfig` ä¸€è‡´
  - **wrapper æ²¡ç»Ÿä¸€ JSON + trace**
    - å…¸å‹ç°è±¡ï¼š`json.loads(out)` å¤±è´¥ / `tool_trace` ä¸ºç©º / ç¼ºå­—æ®µï¼ˆå¦‚ `denied/produced_n/ok`ï¼‰
    - å¤„ç†æ–¹å¼ï¼šç¡®ä¿ deny/exception ä¹Ÿè¿”å› JSONï¼Œå¹¶åœ¨æ‰€æœ‰åˆ†æ”¯å†™ `_append_tool_trace`
  - **runtime state æ³¨å…¥å¤±æ•ˆ**
    - å…¸å‹ç°è±¡ï¼štrace çš„ `round_idx` ä¸æ˜¯ 7ï¼ˆä»æ˜¯é—­åŒ…æ—§å€¼ï¼‰
    - å¤„ç†æ–¹å¼ï¼šæ£€æŸ¥ `ContextVar set/reset` ä¸ `_get_runtime_state` æ˜¯å¦çœŸæ­£ä½¿ç”¨æ³¨å…¥çš„ æ˜¯å¦çœŸçš„ä¼˜å…ˆä½¿ç”¨æ³¨å…¥çš„ `state_in`


### ğŸ” å¯è¿ç§»ç‚¹ Transfer

> æœ¬å…³çš„ `core/tools.py` è®¾è®¡ç›®æ ‡æ˜¯ï¼š**æŠŠâ€œæŠ€èƒ½ Skillâ€å°è£…æˆå¯æ§çš„ Toolsï¼Œå¹¶æä¾›ç»Ÿä¸€çš„è°ƒç”¨å…¥å£ï¼ˆpolicy â†’ guard â†’ invoke â†’ traceï¼‰ã€‚**
>
> è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶ï¼Œä½ é€šå¸¸åªéœ€è¦æ¢â€œallowlist / policy è§„åˆ™ / æ³¨å…¥çš„ä¸šåŠ¡çŠ¶æ€å­—æ®µâ€ï¼Œè€Œä¸å¿…é‡å†™å·¥å…·è£…é…ä¸å®ˆå«æ¡†æ¶ã€‚

**1. æ¡†æ¶é€šç”¨ ä¸è¦åŠ¨**

<details>
<summary><b>tools.py ä¸éœ€è¦åŠ¨çš„åœ°æ–¹</b></summary>

- **ctx æ³¨å…¥ï¼ˆSkillContextï¼‰**
  - `build_ctx(dossier, role, ref_date) -> SkillContext`
  - åŸåˆ™ï¼šåªè´Ÿè´£è£…é…ä¸Šä¸‹æ–‡ï¼ˆdossier/role/ref_dateï¼‰ï¼Œä¸åœ¨æ­¤å¤„å†™ä¸šåŠ¡æ ¡éªŒ

- **skill â†’ tools è£…é…å…¥å£**
  - `build_tools_for_role(role, ctx, state) -> List[StructuredTool]`
  - åŸåˆ™ï¼šç”± allowlist å†³å®šâ€œè£…å“ªäº›â€ï¼Œç”± registry å†³å®šâ€œæœ‰å“ªäº›â€ï¼Œå·¥å…·å±‚åªåšå°è£…

- **ç»Ÿä¸€è°ƒç”¨å…¥å£ï¼ˆwrapperï¼‰**
  - `_wrap_tool_with_guard(role, tool_name, base_tool, state) -> StructuredTool`
  - åŸåˆ™ï¼šæ‰€æœ‰åˆ†æ”¯éƒ½éµå®ˆåŒä¸€é“¾è·¯ï¼špolicy â†’ guard â†’ invoke â†’ traceï¼Œå¹¶ç»Ÿä¸€è¿”å› JSON å­—ç¬¦ä¸²

- **ä¸‰é“é—¸æ²»ç†**
  - `tool_guard_check(role, tool_name, tool_args, state) -> (bool, reason)`
  - åŸåˆ™ï¼šå¯è¯»ã€å¯è¯Šæ–­ï¼›æ‹’ç»å¿…é¡»è§£é‡Šâ€œä¸ºä½•æ‹’ç»â€ï¼ˆç™½åå•/ä¸Šé™/dedupï¼‰

- **trace ç¨³å®šè½ç›˜**
  - `_append_tool_trace(state, ...)`
  - åŸåˆ™ï¼štrace æ°¸è¿œæ˜¯ listï¼›å­—æ®µç¼ºå¤±ä¸å´©ï¼›ç¡®ä¿ `ok/denied/elapsed_ms/produced_n/round_idx` å¯ç”¨äºå¤ç›˜ä¸ç»Ÿè®¡

</details>

**2. ä¸šåŠ¡ç›¸å…³ å¯æ›¿æ¢æˆ–é‡å†™**

è¿™éƒ¨åˆ†å±äºâ€œä½ ä»¬å½“å‰æ˜¯ ETF çš„ç¤ºä¾‹ä¸šåŠ¡â€ã€‚  

è¿ç§»åˆ°åˆ«çš„ä»»åŠ¡æ—¶å¯ä»¥**æ•´ä½“æ›¿æ¢**ï¼Œä½†å»ºè®®ä¿ç•™åŒä¸€æ¡åŸåˆ™ï¼š**å°‘è€Œç¡¬çš„ policyï¼ˆStrong Policyï¼‰+ æ˜ç¡®å¯è¯Šæ–­çš„ guardï¼ˆDiagnosable Guardï¼‰**ï¼Œè®©å·¥å…·å±‚é•¿æœŸç¨³å®šã€å¯æµ‹è¯•ã€‚

- **å‡†å…¥ç­–ç•¥ï¼šallowlist / é…é¢ / dedup**
  - ETF å½“å‰ç”¨ `CONFIG.ROLE_TOOL_ALLOWLIST / ROLE_TOOL_MAX_CALLS / FORBID_SAME_TOOL_SAME_ARGS_IN_SAME_ROUND`
  - è¿ç§»æ–¹å¼ï¼šæ”¹ CONFIG å³å¯ï¼Œä¸å»ºè®®åœ¨å‡½æ•°é‡Œå†™æ­»è§’è‰²/å·¥å…·å

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠâ€œè§’è‰²å‡†å…¥â€æ¢æˆä½ çš„ä¸šåŠ¡å‡†å…¥è§„åˆ™</b></summary>

  ```py
  # TODOï¼š
  # 1) é…ç½®ä¸åŒ role çš„ allowlistï¼ˆæŒ‰å²—ä½/æƒé™åˆ†å±‚ï¼‰
  # 2) ç»™æ¯ä¸ª role é… max_callsï¼ˆæ§åˆ¶æˆæœ¬/é¢‘ç‡ï¼‰
  # 3) æ˜¯å¦å¼€å¯ dedupï¼ˆé¿å…åŒè½®é‡å¤è°ƒç”¨ï¼‰
  #
  # è§„åˆ™å°½é‡æ”¾ CONFIGï¼›tool_guard_check åªè¯»é…ç½®å¹¶ç»™å‡ºå¯è¯Šæ–­ reason
  pass
  ```
  </details>

- **policy æ³¨å…¥è§„åˆ™**
  - ETF å½“å‰åœ¨ `_apply_tool_policy(...)` é‡Œåšâ€œçº é”™ + é»˜è®¤å€¼ + å¼ºæ§â€
  - è¿ç§»æ–¹å¼ï¼šä¿ç•™å‡½æ•°æ¡†æ¶ï¼ŒæŒ‰ä½ çš„å·¥å…·åå¢åŠ åˆ†æ”¯ï¼ˆæ¯ä¸ªåˆ†æ”¯éƒ½åº”æœ€ç»ˆ `_filter_to_schema`ï¼‰

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šä¸ºä½ çš„å…³é”®å·¥å…·å†™ policy æ³¨å…¥</b></summary>

  ```py
  # TODOï¼š
  # 1) å¯¹è¾“å…¥åšè½»é‡çº é”™ï¼ˆstr/list/dict å…œåº•ï¼‰
  # 2) defaultsï¼šåªè¡¥ç¼ºå¤±ï¼ˆä¸è¦†ç›– LLM æ˜¾å¼å€¼ï¼‰
  # 3) enforceï¼šå°‘é‡ç¡¬å¼ºæ§ï¼ˆæ²»ç†éœ€è¦ï¼‰
  # 4) æœ€åæŒ‰ schema è¿‡æ»¤ï¼Œé¿å…æœªçŸ¥å­—æ®µå¯¼è‡´æ ¡éªŒå¤±è´¥
  pass

  ```
  </details>

- **çŠ¶æ€æ³¨å…¥å­—æ®µï¼ˆä» state â†’ tool_argsï¼‰**
  - ETF å½“å‰åœ¨ wrapper å†…ç»™ portfolio_allocator æ³¨å…¥ `candidates/risk_reports`
  - è¿ç§»æ–¹å¼ï¼šæŠŠâ€œéœ€è¦åƒç¡¬çŠ¶æ€çš„å­—æ®µâ€é›†ä¸­åœ¨ wrapper çš„å°‘æ•°åˆ†æ”¯é‡Œï¼Œä¸”å…ˆæ£€æŸ¥ schema æ˜¯å¦æ”¯æŒ

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šè®©æŸäº›å·¥å…·åƒâ€œè¿è¡Œæ—¶ stateâ€å­—æ®µ</b></summary>

  ```py
  # TODOï¼š
  # 1) ä»…å¯¹å°‘æ•°ç¡®å®éœ€è¦çš„ tool æ³¨å…¥ state å­—æ®µ
  # 2) æ³¨å…¥å‰å…ˆåˆ¤æ–­ schema_keys æ˜¯å¦åŒ…å«è¯¥å­—æ®µ
  # 3) æ³¨å…¥å€¼å°½é‡æ¥è‡ª state çš„ç¨³å®šé”®ï¼ˆcur/history åˆ†å±‚æ›´æ¸…æ™°ï¼‰
  pass

  ```
  </details>

- **äº§å‡ºç»Ÿè®¡ï¼ˆproduced_nï¼‰è§„åˆ™**
  - ETF å½“å‰ä» `data.items/candidates/results` æ¨æ–­æ¡æ•°ï¼Œç”¨äº summary çš„çœŸå®ç»Ÿè®¡
  - è¿ç§»æ–¹å¼ï¼šæŒ‰ä½ çš„ SkillResult.data ç»“æ„æ›¿æ¢ key åˆ—è¡¨å³å¯ï¼ˆä¿æŒâ€œæ¨æ–­å¤±è´¥=0â€çš„å…œåº•ï¼‰

  <details>
  <summary><b>ç¤ºä¾‹ TODOï¼šæŠŠ produced_n ç»Ÿè®¡æ”¹æˆä½ çš„ä¸šåŠ¡è¾“å‡ºç»“æ„</b></summary>

  ```py
  # TODOï¼š
  # 1) çº¦å®šä½ çš„ç»“æœ list å­—æ®µåï¼ˆå¦‚ data.issues / data.recommendationsï¼‰
  # 2) ç»Ÿè®¡ä¼˜å…ˆçº§ï¼šæœ€å¸¸ç”¨å­—æ®µä¼˜å…ˆ
  # 3) æ¨æ–­å¤±è´¥è¿”å› 0ï¼ˆä¸æŠ¥é”™ï¼‰
  pass

  ```
  </details>

**â€¼ï¸è¿ç§»æ—¶çš„â€œåªæ”¹å“ªé‡Œâ€å£è¯€**
- **ä¸åŠ¨**ï¼š`build_ctx / build_tools_for_role / _wrap_tool_with_guard / tool_guard_check / _append_tool_trace` è¿™å¥— **è£…é…+ç»Ÿä¸€å…¥å£+ä¸‰é“é—¸+trace** æ¡†æ¶ï¼ˆpolicyâ†’guardâ†’invokeâ†’trace é“¾è·¯ä¸ç ´ã€è¿”å›ç»Ÿä¸€ JSON ä¸ç ´ï¼‰
- **å¯æ¢**ï¼š`CONFIG` é‡Œçš„ **allowlist / max_calls / dedup å¼€å…³** + `_apply_tool_policy` çš„ **å·¥å…·åˆ†æ”¯è§„åˆ™** + wrapper é‡Œå°‘æ•°éœ€è¦çš„ **stateâ†’tool_args æ³¨å…¥å­—æ®µ**ï¼ˆå…ˆéªŒ schema å†æ³¨å…¥ï¼‰
- **ä¸€å¥è¯**ï¼š**æ¡†æ¶ä¸æ”¹ã€é“¾è·¯ä¸ç ´ï¼›æ¢å‡†å…¥ã€æ¢ policyã€æ¢æ³¨å…¥å­—æ®µï¼Œå°±èƒ½æ¢ä¸šåŠ¡**

</details>

---


## âœ… ç»ƒä¹ å®Œæˆæ¸…å•ï¼ˆ10 å…³å›é¡¾ï¼‰

ä½ å·²ç»æŠŠ â€œDebate MASâ€ ä» **èƒ½è·‘** èµ°åˆ°äº† **å¯æ§ã€å¯å®¡è®¡ã€å¯æ‰©å±•**ï¼š

- **å…³å¡ 01**ï¼šè·‘é€š Demoã€ä¼šè¯»äº§ç‰©ï¼ˆmemo / csv / log / transcriptï¼‰
- **å…³å¡ 02**ï¼šå…±äº«è´¦æœ¬ Stateï¼ˆcur + history + stop_reasonï¼‰
- **å…³å¡ 03**ï¼šç»“æ„åŒ–åè®® Protocolï¼ˆschema + renderer ä¸‰ä»¶å¥—ï¼‰
- **å…³å¡ 04**ï¼šè¯æ®æ¡ˆå· Loaderï¼ˆfolder â†’ dossierï¼‰
- **å…³å¡ 05**ï¼šæç¤ºè¯å·¥å‚ Personasï¼ˆç™½åå• + è¾“å‡ºå¥‘çº¦ï¼‰
- **å…³å¡ 06**ï¼šæµç¨‹ç¼–æ’ Graphï¼ˆè·³è½¬ + åœæœºï¼‰
- **å…³å¡ 07**ï¼šå¼•æ“ä¸²è” Engineï¼ˆæœ€å°å¾ªç¯è·‘å®Œï¼‰
- **å…³å¡ 08**ï¼šå†™ä¸€ä¸ª Skillï¼ˆå¯è°ƒç”¨ã€å¯ç»“æ„åŒ–è¿”å›ï¼‰
- **å…³å¡ 09**ï¼šæ³¨å†Œä¸å‡†å…¥ï¼ˆregistry + allowlistï¼‰
- **å…³å¡ 10**ï¼šå·¥å…·å°è£…ä¸å®ˆå«ï¼ˆskill â†’ tool + ç»Ÿä¸€å…¥å£ + æ‹¦æˆªï¼‰

> ä½ ä¸éœ€è¦â€œè®°ä½æ‰€æœ‰ä»£ç ç»†èŠ‚â€ã€‚  
> çœŸæ­£é‡è¦çš„æ˜¯ï¼šä½ å·²ç»æŒæ¡äº†**ä¸€å¥—èƒ½åå¤å¤ç”¨çš„éª¨æ¶**â€”â€”ä»è¯æ®è¾“å…¥ã€åˆ°å¤šè§’è‰²åä½œã€åˆ°ç»“æ„åŒ–äº¤ä»˜ã€‚

---

## ğŸ§© è¿è¡Œæ•´å¥—é¡¹ç›®ä¹‹å‰çš„å°æé†’

å¦‚æœä½ å‡†å¤‡å®Œæ•´è·‘é€šé¡¹ç›®ï¼ˆè€Œä¸åªæ˜¯åšå…³å¡å•æµ‹ï¼‰ï¼Œè¯·ç¡®ä¿ä½ åœ¨é¡¹ç›®é‡Œå‡†å¤‡å¥½å¿…è¦çš„é…ç½®æ–‡ä»¶ï¼š

- éœ€è¦ä½ **æ ¹æ® README çš„å‚æ•°è¡¨**åˆ›å»ºå¹¶å¡«å†™ `config.py`ï¼ˆè·¯å¾„ã€é˜ˆå€¼ã€å¼€å…³ç­‰ï¼‰ã€‚  
  è¿™é‡Œç›´æ¥è·³è½¬åˆ°å‚æ•°è¡¨ï¼š**[README.md â€º 6.2 æ ¸å¿ƒå‚æ•°é€ŸæŸ¥è¡¨](README.md#62-æ ¸å¿ƒå‚æ•°é€ŸæŸ¥è¡¨)**

> å»ºè®®åšæ³•ï¼šå…ˆæŒ‰å‚æ•°è¡¨å†™ä¸€ä¸ªâ€œæœ€å°å¯è¿è¡Œâ€çš„ `config.py`ï¼Œè·‘é€šåå†é€é¡¹ç²¾è°ƒã€‚  
> è¿™èƒ½æ˜¾è‘—å‡å°‘ä½ åœ¨â€œç¯å¢ƒ/è·¯å¾„/é»˜è®¤å€¼â€ä¸Šçš„æ—¶é—´æŸè€—ã€‚

---

## ğŸ“š é™„å½•ï¼šå‚è€ƒèµ„æºï¼ˆå®˜æ–¹æ–‡æ¡£ï¼‰

ä»¥ä¸‹èµ„æºèƒ½å¸®ä½ æŠŠç»ƒä¹ é‡Œçš„æ¦‚å¿µâ€œå¯¹ç…§åˆ°çœŸå®ä¸–ç•Œçš„å·¥ç¨‹ç”Ÿæ€â€ï¼Œéƒ½ç»™ä½ æ”¾äº†å®˜æ–¹å…¥å£ï¼š

- **LangChain**ï¼ˆæ¶ˆæ¯/å·¥å…·/æ¨¡å‹æ¥å£ï¼‰ï¼š[LangChain Documentation](https://python.langchain.com/docs/)
- **LangGraph**ï¼ˆçŠ¶æ€å›¾ç¼–æ’ã€å¾ªç¯ä¸åˆ†æ”¯ï¼‰ï¼š[LangGraph Documentation](https://langchain-ai.github.io/langgraph/)
- **Pydantic**ï¼ˆç»“æ„åŒ–åè®®ã€æ•°æ®æ ¡éªŒï¼‰ï¼š[Pydantic Documentation](https://docs.pydantic.dev/)
- **pytest**ï¼ˆå•æµ‹ä¸éªŒæ”¶ï¼‰ï¼š[pytest Documentation](https://docs.pytest.org/)
- **uv**ï¼ˆæ›´å¿«çš„ Python åŒ…ä¸ç¯å¢ƒç®¡ç†ï¼‰ï¼š[uv Documentation](https://docs.astral.sh/uv/)
- **pandas**ï¼ˆè¡¨æ ¼æ•°æ®å¤„ç†ï¼‰ï¼š[pandas Documentation](https://pandas.pydata.org/docs/)
- **pypdf**ï¼ˆPDF è¯»å–ï¼Œå¯é€‰ä¾èµ–ï¼‰ï¼š[pypdf Documentation](https://pypdf.readthedocs.io/)
- **python-docx**ï¼ˆWord è¯»å–ï¼Œå¯é€‰ä¾èµ–ï¼‰ï¼š[python-docx Documentation](https://python-docx.readthedocs.io/)

---

## ğŸ‰ ä½ å·²ç»å…·å¤‡çš„èƒ½åŠ›

**æ­å–œä½ å®Œæˆäº† Debate MAS ä¸‰æ®µå¼å®æˆ˜ç»ƒä¹ ï¼**  
åˆ°è¿™é‡Œï¼Œä½ å·²ç»èƒ½å¤Ÿï¼š

- [ ] ç”¨æœ€å°‘çš„æ”¹åŠ¨è·‘é€šä¸€ä¸ªå¯å®¡è®¡çš„å¤šè§’è‰²å†³ç­–ç³»ç»Ÿ
- [ ] ç”¨ State è®©è§’è‰²â€œå…±äº«äº‹å®â€ï¼Œè€Œä¸æ˜¯å…±äº«å£å¤´ç»“è®º
- [ ] ç”¨ Schema + Renderer æŠŠäº§ç‰©å˜æˆå¯äº¤ä»˜çš„ä¸‰ä»¶å¥—ï¼ˆjson / md / csvï¼‰
- [ ] ç”¨ Loader æŠŠæ‚ä¹±ææ–™ç»Ÿä¸€è¿› Dossierï¼Œç»™ç³»ç»Ÿä¸€ä¸ªç¨³å®šçš„è¯æ®å…¥å£
- [ ] ç”¨ Personas + Allowlist æŠŠå·¥å…·æƒè´£ä¸è¾“å‡ºå¥‘çº¦â€œå†™æ­»åˆ°æç¤ºè¯é‡Œâ€
- [ ] ç”¨ Graph æŠŠæµç¨‹å˜æˆå¯æ§çš„çŠ¶æ€æœºï¼ŒçŸ¥é“ä¸ºä»€ä¹ˆåœã€åœ¨å“ªåœã€æ€ä¹ˆç»§ç»­
- [ ] å†™å‡ºèƒ½è¢«ç³»ç»Ÿè°ƒç”¨çš„ Skillï¼Œå¹¶æŠŠå®ƒçº³å…¥æ²»ç†ï¼ˆæ³¨å†Œ/å‡†å…¥/å®ˆå«ï¼‰

> æ¥ä¸‹æ¥æœ€å€¼å¾—åšçš„ä¸€ä»¶äº‹ï¼š  
> **æŠŠä½ æœ€ç†Ÿæ‚‰çš„ä¸šåŠ¡ææ–™ä¸¢è¿› dossier**ï¼Œç„¶åç”¨åŒæ ·çš„æµç¨‹è®©ç³»ç»Ÿäº§å‡ºç¬¬ä¸€ç‰ˆâ€œå¯å¤ç›˜â€çš„å†³ç­– memoã€‚  
> ä½ ä¼šéå¸¸ç›´è§‚åœ°æ„Ÿå—åˆ°ï¼šæ¡†æ¶ä¸€æ—¦ç¨³å®šï¼Œå‰©ä¸‹å°±æ˜¯æ›¿æ¢ææ–™ä¸æŒ‡æ ‡ï¼Œè€Œä¸æ˜¯é‡å†™ç³»ç»Ÿã€‚

---

### ğŸ«¶ å°å°çš„é¼“åŠ±

ä½ åšå®Œçš„ä¸æ˜¯â€œåä¸ªç»ƒä¹ é¢˜â€ï¼Œè€Œæ˜¯å®Œæˆäº†ä¸€ä¸ªå¾ˆéš¾å¾—çš„å·¥ç¨‹èƒ½åŠ›é—­ç¯ï¼š  
**æŠŠ Agent ä»â€œèƒ½è¯´â€å˜æˆâ€œèƒ½è·‘ã€èƒ½æ§ã€èƒ½äº¤ä»˜â€ã€‚**

ç»§ç»­å¾€å‰èµ°â€”â€”ä½ ä¼šè¶Šæ¥è¶Šåƒä¸€ä¸ªçœŸæ­£çš„ AI Agent Builderã€‚ ğŸ”§âœ¨